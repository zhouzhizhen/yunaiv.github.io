<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="google-site-verification" content="GkJ68PCnxM9Ih7Zm9v8p91FOCV7ymNCO2KdGbflLh3E"><meta name="360-site-verification" content="dd6547587641bfede036f7c79561e8a0"><meta name="shenma-site-verification" content="fd96cf3751972c9b05f8471d2ccadddc_1496951214"><meta name="msvalidate.01" content="1D38B05050A977F6FDEDA481198343F1"><meta name="sogou_site_verification" content="MpPsku240L"><title>芋艿V的博客</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=3,minimum-scale=1"><meta name="author" content="王文斌"><meta name="description" content="1. 概述本文主要分享 Elastic-Job-Lite 作业执行。
涉及到主要类的类图如下( 打开大图 )：


黄色的类在 elastic-job-common-core 项目里，为 Elastic-Job-Lite、Elastic-Job-Cloud 公用作业执行类。

Lite调度作业( L"><meta name="keywords" content="Java,架构,后端,服务端,RocketMQ,MyCAT,分布式消息队列,分布式存储,技术博客,Sharding-JDBC,分库分表"><link rel="alternate" href="atom.xml" title="芋艿V的博客" type="application/atom+xml"><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/style.css"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?ef4ed89f6dc83d01803a2440ae21e666";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script>!function(){var t="http:"==document.location.protocol?"http://js.passport.qihucdn.com/11.0.1.js?f05b61dd54bbc38386611a5238672938":"https://jspassport.ssl.qhimg.com/11.0.1.js?f05b61dd54bbc38386611a5238672938";document.write('<script src="'+t+'" id="sozz"><\/script>')}()</script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></head></html><body><header><div><div id="textlogo"><h1 class="site-name"><a href="/" title="芋艿V的博客">芋艿V的博客</a></h1><a class="blog-motto">愿编码半生，如老友相伴！</a></div><div class="navbar"><a class="navbutton navmobile" href="#" title="菜单"></a></div><nav class="animated"><ul><ul><li><a href="/">文章</a></li><li><a href="https://github.com/YunaiV" rel="external nofollow noopener noreferrer" target="_blank">Github</a></li><li><a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31_bak.jpg">微信公众号</a></li></ul></ul></nav></div></header><div id="container"><div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div><div id="toc" class="toc-aside"><strong class="toc-title">文章目录</strong><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-概述"><span class="toc-number">1.</span> <span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-执行器创建"><span class="toc-number">2.</span> <span class="toc-text">3. 执行器创建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-加载作业配置"><span class="toc-number">2.1.</span> <span class="toc-text">3.1 加载作业配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-获取作业执行线程池"><span class="toc-number">2.2.</span> <span class="toc-text">3.2 获取作业执行线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-获取作业异常执行器"><span class="toc-number">2.3.</span> <span class="toc-text">3.3 获取作业异常执行器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-执行器执行"><span class="toc-number">3.</span> <span class="toc-text">4. 执行器执行</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-检查作业执行环境"><span class="toc-number">3.1.</span> <span class="toc-text">4.1 检查作业执行环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-获取当前作业服务器的分片上下文"><span class="toc-number">3.2.</span> <span class="toc-text">4.2 获取当前作业服务器的分片上下文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-发布作业状态追踪事件"><span class="toc-number">3.3.</span> <span class="toc-text">4.3 发布作业状态追踪事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-跳过存在运行中的被错过作业"><span class="toc-number">3.4.</span> <span class="toc-text">4.4 跳过存在运行中的被错过作业</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-执行作业执行前的方法"><span class="toc-number">3.5.</span> <span class="toc-text">4.5 执行作业执行前的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-执行普通触发的作业"><span class="toc-number">3.6.</span> <span class="toc-text">4.6 执行普通触发的作业</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-1-简单作业执行器"><span class="toc-number">3.6.1.</span> <span class="toc-text">4.6.1 简单作业执行器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-2-数据流作业执行器"><span class="toc-number">3.6.2.</span> <span class="toc-text">4.6.2 数据流作业执行器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-3-脚本作业执行器"><span class="toc-number">3.6.3.</span> <span class="toc-text">4.6.3 脚本作业执行器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-执行被错过触发的作业"><span class="toc-number">3.7.</span> <span class="toc-text">4.7 执行被错过触发的作业</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-执行作业失效转移"><span class="toc-number">3.8.</span> <span class="toc-text">4.8 执行作业失效转移</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-执行作业执行后的方法"><span class="toc-number">3.9.</span> <span class="toc-text">4.9 执行作业执行后的方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#666-彩蛋"><span class="toc-number">4.</span> <span class="toc-text">666. 彩蛋</span></a></li></ol></div><div id="asidepart"><aside class="clearfix"><div id="authorInfo"><div><img width="100%" src="/images/common/wechat_mp_2017_07_31_bak.jpg"></div><div class="social-list"></div></div><div class="categorieslist"><p class="asidetitle">微信公众号福利：芋道源码</p><ul><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">0. 阅读源码葵花宝典</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">1. RocketMQ / MyCAT / Sharding-JDBC 详细中文注释源码</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">2. 您对于源码的疑问每条留言都将得到认真回复</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">3. 新的源码解析文章实时收到通知，每周六十点更新</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">4. 认真的源码交流微信群</a></li></ul></div><div class="categorieslist"><p class="asidetitle">分类</p><ul><li><a href="/categories/Docker/" title="Docker">Docker<sup>2</sup></a></li><li><a href="/categories/Elastic-Job/" title="Elastic-Job">Elastic-Job<sup>3</sup></a></li><li><a href="/categories/MyCAT/" title="MyCAT">MyCAT<sup>9</sup></a></li><li><a href="/categories/Nginx/" title="Nginx">Nginx<sup>1</sup></a></li><li><a href="/categories/RocketMQ/" title="RocketMQ">RocketMQ<sup>14</sup></a></li><li><a href="/categories/Sharding-JDBC/" title="Sharding-JDBC">Sharding-JDBC<sup>18</sup></a></li><li><a href="/categories/技术杂文/" title="技术杂文">技术杂文<sup>2</sup></a></li></ul></div></aside></div><div id="main" class="post" itemscope="" itemprop="blogPost"><article itemprop="articleBody"><header class="article-info clearfix"><h1 itemprop="name"><a href="/Elastic-Job/2017_09_23_Elastic-Job-Lite 源码解析 —— 作业执行/" title="" itemprop="url"></a></h1><p class="article-author"></p><p class="article-time">总阅读量:<span id="busuanzi_value_page_pv"></span>次</p></header><div class="article-content"><div id="toc" class="toc-article"><strong class="toc-title">文章目录</strong><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-概述"><span class="toc-number">1.</span> <span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-执行器创建"><span class="toc-number">2.</span> <span class="toc-text">3. 执行器创建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-加载作业配置"><span class="toc-number">2.1.</span> <span class="toc-text">3.1 加载作业配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-获取作业执行线程池"><span class="toc-number">2.2.</span> <span class="toc-text">3.2 获取作业执行线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-获取作业异常执行器"><span class="toc-number">2.3.</span> <span class="toc-text">3.3 获取作业异常执行器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-执行器执行"><span class="toc-number">3.</span> <span class="toc-text">4. 执行器执行</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-检查作业执行环境"><span class="toc-number">3.1.</span> <span class="toc-text">4.1 检查作业执行环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-获取当前作业服务器的分片上下文"><span class="toc-number">3.2.</span> <span class="toc-text">4.2 获取当前作业服务器的分片上下文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-发布作业状态追踪事件"><span class="toc-number">3.3.</span> <span class="toc-text">4.3 发布作业状态追踪事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-跳过存在运行中的被错过作业"><span class="toc-number">3.4.</span> <span class="toc-text">4.4 跳过存在运行中的被错过作业</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-执行作业执行前的方法"><span class="toc-number">3.5.</span> <span class="toc-text">4.5 执行作业执行前的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-执行普通触发的作业"><span class="toc-number">3.6.</span> <span class="toc-text">4.6 执行普通触发的作业</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-1-简单作业执行器"><span class="toc-number">3.6.1.</span> <span class="toc-text">4.6.1 简单作业执行器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-2-数据流作业执行器"><span class="toc-number">3.6.2.</span> <span class="toc-text">4.6.2 数据流作业执行器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-3-脚本作业执行器"><span class="toc-number">3.6.3.</span> <span class="toc-text">4.6.3 脚本作业执行器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-执行被错过触发的作业"><span class="toc-number">3.7.</span> <span class="toc-text">4.7 执行被错过触发的作业</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-执行作业失效转移"><span class="toc-number">3.8.</span> <span class="toc-text">4.8 执行作业失效转移</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-执行作业执行后的方法"><span class="toc-number">3.9.</span> <span class="toc-text">4.9 执行作业执行后的方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#666-彩蛋"><span class="toc-number">4.</span> <span class="toc-text">666. 彩蛋</span></a></li></ol></div><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Lite 作业执行</strong>。</p><p>涉及到主要类的类图如下( <a href="http://www.yunai.me/images/Elastic-Job/2017_09_23/01.png">打开大图</a> )：</p><p><img src="http://www.yunai.me/images/Elastic-Job/2017_09_23/01.png" alt=""></p><ul><li><strong>黄色</strong>的类在 <code>elastic-job-common-core</code> 项目里，为 Elastic-Job-Lite、Elastic-Job-Cloud <strong>公用</strong>作业执行类。</li></ul><p>Lite调度作业( LiteJob )，作业被调度后，调用 <code>#execute()</code> 执行作业。</p><p><strong>为什么是 LiteJob 作为入口呢？</strong></p><p>在<a href="http://www.yunai.me/Elastic-Job/job-init/?self">《Elastic-Job-Lite 源码分析 —— 作业初始化》的「3.2.3」创建作业调度控制器</a>里，我们可以看到 Quartz 的 JobDetail 创建代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">JobDetail result = JobBuilder.newJob(LiteJob.class).withIdentity(liteJobConfig.getJobName()).build();</div></pre></td></tr></table></figure><p><code>#newJob()</code> 里的参数是 LiteJob，因此，每次 Quartz 到达调度时间时，会创建该对象进行作业执行。</p><hr><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LiteJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Setter</span></div><div class="line">    <span class="keyword">private</span> ElasticJob elasticJob;</div><div class="line">    </div><div class="line">    <span class="meta">@Setter</span></div><div class="line">    <span class="keyword">private</span> JobFacade jobFacade;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</div><div class="line">        JobExecutorFactory.getJobExecutor(elasticJob, jobFacade).execute();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>LiteJob 通过 JobExecutorFactory 获得到作业执行器( AbstractElasticJobExecutor )，并进行执行：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobExecutorFactory</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取作业执行器.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> elasticJob 分布式弹性作业</div><div class="line">     * <span class="doctag">@param</span> jobFacade 作业内部服务门面服务</div><div class="line">     * <span class="doctag">@return</span> 作业执行器</div><div class="line">     */</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractElasticJobExecutor <span class="title">getJobExecutor</span><span class="params">(<span class="keyword">final</span> ElasticJob elasticJob, <span class="keyword">final</span> JobFacade jobFacade)</span> </span>&#123;</div><div class="line">        <span class="comment">// ScriptJob</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == elasticJob) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ScriptJobExecutor(jobFacade);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// SimpleJob</span></div><div class="line">        <span class="keyword">if</span> (elasticJob <span class="keyword">instanceof</span> SimpleJob) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleJobExecutor((SimpleJob) elasticJob, jobFacade);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// DataflowJob</span></div><div class="line">        <span class="keyword">if</span> (elasticJob <span class="keyword">instanceof</span> DataflowJob) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DataflowJobExecutor((DataflowJob) elasticJob, jobFacade);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> JobConfigurationException(<span class="string">"Cannot support job type '%s'"</span>, elasticJob.getClass().getCanonicalName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>JobExecutorFactory，作业执行器工厂，根据不同的作业类型，返回对应的<strong>作业执行器</strong>。</li></ul></li></ul><table><thead><tr><th style="text-align:left">作业</th><th style="text-align:left">作业接口</th><th style="text-align:left">执行器</th></tr></thead><tbody><tr><td style="text-align:left">简单作业</td><td style="text-align:left">SimpleJob</td><td style="text-align:left">SimpleJobExecutor</td></tr><tr><td style="text-align:left">数据流作业</td><td style="text-align:left">DataflowJob</td><td style="text-align:left">DataflowJobExecutor</td></tr><tr><td style="text-align:left">脚本作业</td><td style="text-align:left">ScriptJob</td><td style="text-align:left">ScriptJobExecutor</td></tr></tbody></table><h1 id="3-执行器创建"><a href="#3-执行器创建" class="headerlink" title="3. 执行器创建"></a>3. 执行器创建</h1><p>AbstractElasticJobExecutor，作业执行器抽象类。不同作业执行器都继承该类，创建的过程是一致的。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractElasticJobExecutor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业门面对象</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span>(AccessLevel.PROTECTED)</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobFacade jobFacade;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业配置</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span>(AccessLevel.PROTECTED)</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobRootConfiguration jobRootConfig;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业名称</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String jobName;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业执行线程池</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executorService;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业异常处理器</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobExceptionHandler jobExceptionHandler;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 分片错误信息集合</div><div class="line">     * key：分片序号</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, String&gt; itemErrorMessages;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractElasticJobExecutor</span><span class="params">(<span class="keyword">final</span> JobFacade jobFacade)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.jobFacade = jobFacade;</div><div class="line">        <span class="comment">// 加载 作业配置</span></div><div class="line">        jobRootConfig = jobFacade.loadJobRootConfiguration(<span class="keyword">true</span>);</div><div class="line">        jobName = jobRootConfig.getTypeConfig().getCoreConfig().getJobName();</div><div class="line">        <span class="comment">// 获取 作业执行线程池</span></div><div class="line">        executorService = ExecutorServiceHandlerRegistry.getExecutorServiceHandler(jobName, (ExecutorServiceHandler) getHandler(JobProperties.JobPropertiesEnum.EXECUTOR_SERVICE_HANDLER));</div><div class="line">        <span class="comment">// 获取 作业异常处理器</span></div><div class="line">        jobExceptionHandler = (JobExceptionHandler) getHandler(JobProperties.JobPropertiesEnum.JOB_EXCEPTION_HANDLER);</div><div class="line">        <span class="comment">// 设置 分片错误信息集合</span></div><div class="line">        itemErrorMessages = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(jobRootConfig.getTypeConfig().getCoreConfig().getShardingTotalCount(), <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// SimpleJobExecutor.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleJobExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractElasticJobExecutor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 简单作业实现</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SimpleJob simpleJob;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleJobExecutor</span><span class="params">(<span class="keyword">final</span> SimpleJob simpleJob, <span class="keyword">final</span> JobFacade jobFacade)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(jobFacade);</div><div class="line">        <span class="keyword">this</span>.simpleJob = simpleJob;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// DataflowJobExecutor.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DataflowJobExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractElasticJobExecutor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 数据流作业对象</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DataflowJob&lt;Object&gt; dataflowJob;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DataflowJobExecutor</span><span class="params">(<span class="keyword">final</span> DataflowJob&lt;Object&gt; dataflowJob, <span class="keyword">final</span> JobFacade jobFacade)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(jobFacade);</div><div class="line">        <span class="keyword">this</span>.dataflowJob = dataflowJob;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ScriptJobExecutor.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ScriptJobExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractElasticJobExecutor</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScriptJobExecutor</span><span class="params">(<span class="keyword">final</span> JobFacade jobFacade)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(jobFacade);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3-1-加载作业配置"><a href="#3-1-加载作业配置" class="headerlink" title="3.1 加载作业配置"></a>3.1 加载作业配置</h2><p>从<strong>缓存</strong>中读取作业配置。在<a href="http://www.yunai.me/Elastic-Job/job-config/?self">《Elastic-Job-Lite 源码分析 —— 作业配置》的「3.1」读取作业配置</a> 已经解析。</p><h2 id="3-2-获取作业执行线程池"><a href="#3-2-获取作业执行线程池" class="headerlink" title="3.2 获取作业执行线程池"></a>3.2 获取作业执行线程池</h2><p>作业每次执行时，可能涉及<strong>多个分片</strong>，需要使用线程池实现<strong>并行</strong>执行。考虑到作业和作业之间的隔离性，<strong>一个作业一个线程池</strong>。线程池服务处理器注册表( ExecutorServiceHandlerRegistry ) 获取线程池( <code>#getExecutorServiceHandler(....)</code> )代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorServiceHandlerRegistry</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 线程池集合</div><div class="line">     * key：作业名字</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, ExecutorService&gt; REGISTRY = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取线程池服务.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> jobName 作业名称</div><div class="line">     * <span class="doctag">@param</span> executorServiceHandler 线程池服务处理器</div><div class="line">     * <span class="doctag">@return</span> 线程池服务</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">getExecutorServiceHandler</span><span class="params">(<span class="keyword">final</span> String jobName, <span class="keyword">final</span> ExecutorServiceHandler executorServiceHandler)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!REGISTRY.containsKey(jobName)) &#123;</div><div class="line">            REGISTRY.put(jobName, executorServiceHandler.createExecutorService(jobName));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> REGISTRY.get(jobName);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>ExecutorServiceHandlerRegistry 使用 ExecutorServiceHandler 创建线程池。ExecutorServiceHandler 本身是个<strong>接口</strong>，默认使用 DefaultExecutorServiceHandler 实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ExecutorServiceHandler.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorServiceHandler</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建线程池服务对象.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> jobName 作业名</div><div class="line">     * </div><div class="line">     * <span class="doctag">@return</span> 线程池服务对象</div><div class="line">     */</div><div class="line">    <span class="function">ExecutorService <span class="title">createExecutorService</span><span class="params">(<span class="keyword">final</span> String jobName)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// DefaultExecutorServiceHandler.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultExecutorServiceHandler</span> <span class="keyword">implements</span> <span class="title">ExecutorServiceHandler</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">createExecutorService</span><span class="params">(<span class="keyword">final</span> String jobName)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExecutorServiceObject(<span class="string">"inner-job-"</span> + jobName, Runtime.getRuntime().availableProcessors() * <span class="number">2</span>).createExecutorService();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 ExecutorServiceObject 的 <code>#createExecutorService(....)</code> 方法创建线程池：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorServiceObject</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor threadPoolExecutor;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecutorServiceObject</span><span class="params">(<span class="keyword">final</span> String namingPattern, <span class="keyword">final</span> <span class="keyword">int</span> threadSize)</span> </span>&#123;</div><div class="line">        workQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class="line">        threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(threadSize, threadSize, <span class="number">5L</span>, TimeUnit.MINUTES, workQueue, </div><div class="line">                <span class="keyword">new</span> BasicThreadFactory.Builder().namingPattern(Joiner.on(<span class="string">"-"</span>).join(namingPattern, <span class="string">"%s"</span>)).build());</div><div class="line">        threadPoolExecutor.allowCoreThreadTimeOut(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建线程池服务对象.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> 线程池服务对象</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">createExecutorService</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> MoreExecutors.listeningDecorator(MoreExecutors.getExitingExecutorService(threadPoolExecutor));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>MoreExecutors#listeningDecorator(...)</code> 在<a href="http://www.yunai.me/Sharding-JDBC/sql-execute/?self">《Sharding-JDBC 源码分析 —— SQL 执行》</a> 已经解析。</li><li><p><code>MoreExecutors#getExitingExecutorService(...)</code> 方法逻辑：将 ThreadPoolExecutor 转换成 ExecutorService，并增加 JVM 关闭钩子，实现 <strong>120s</strong> 等待任务完成：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">service.shutdown();</div><div class="line">service.awaitTermination(terminationTimeout, timeUnit);</div></pre></td></tr></table></figure></li></ul></li></ul><p><strong>如何实现自定义 ExecutorServiceHandler ?</strong></p><p>先看下 AbstractElasticJobExecutor 是如何获得<strong>每个作业</strong>的 ExecutorServiceHandler ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 获得【自定义】处理器</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> jobPropertiesEnum 作业属性枚举</div><div class="line">* <span class="doctag">@return</span> 处理器</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getHandler</span><span class="params">(<span class="keyword">final</span> JobProperties.JobPropertiesEnum jobPropertiesEnum)</span> </span>&#123;</div><div class="line">   String handlerClassName = jobRootConfig.getTypeConfig().getCoreConfig().getJobProperties().get(jobPropertiesEnum);</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       Class&lt;?&gt; handlerClass = Class.forName(handlerClassName);</div><div class="line">       <span class="keyword">if</span> (jobPropertiesEnum.getClassType().isAssignableFrom(handlerClass)) &#123; <span class="comment">// 必须是接口实现，才使用【自定义】</span></div><div class="line">           <span class="keyword">return</span> handlerClass.newInstance();</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> getDefaultHandler(jobPropertiesEnum, handlerClassName);</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> ReflectiveOperationException ex) &#123;</div><div class="line">       <span class="keyword">return</span> getDefaultHandler(jobPropertiesEnum, handlerClassName);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 获得【默认】处理器</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> jobPropertiesEnum 作业属性枚举</div><div class="line">* <span class="doctag">@param</span> handlerClassName 处理器类名</div><div class="line">* <span class="doctag">@return</span> 处理器</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getDefaultHandler</span><span class="params">(<span class="keyword">final</span> JobProperties.JobPropertiesEnum jobPropertiesEnum, <span class="keyword">final</span> String handlerClassName)</span> </span>&#123;</div><div class="line">   log.warn(<span class="string">"Cannot instantiation class '&#123;&#125;', use default '&#123;&#125;' class."</span>, handlerClassName, jobPropertiesEnum.getKey());</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">return</span> Class.forName(jobPropertiesEnum.getDefaultValue()).newInstance();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(e);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>每个处理器都会对应一个 JobPropertiesEnum，使用枚举获得处理器。优先从 <code>JobProperties.map</code> 获取<strong>自定义</strong>的处理器实现类，如果不符合条件( 未实现正确接口 或者 创建处理器失败 )，使用<strong>默认</strong>的处理器实现。</li><li>每个作业可以配置<strong>不同</strong>的处理器。</li></ul><h2 id="3-3-获取作业异常执行器"><a href="#3-3-获取作业异常执行器" class="headerlink" title="3.3 获取作业异常执行器"></a>3.3 获取作业异常执行器</h2><p>获取作业异常执行器( JobExceptionHandler )和ExecutorServiceHandler( ExecutorServiceHandler )<strong>相同</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ExecutorServiceHandler.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JobExceptionHandler</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 处理作业异常.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> jobName 作业名称</div><div class="line">     * <span class="doctag">@param</span> cause 异常原因</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleException</span><span class="params">(String jobName, Throwable cause)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// DefaultJobExceptionHandler.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultJobExceptionHandler</span> <span class="keyword">implements</span> <span class="title">JobExceptionHandler</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleException</span><span class="params">(<span class="keyword">final</span> String jobName, <span class="keyword">final</span> Throwable cause)</span> </span>&#123;</div><div class="line">        log.error(String.format(<span class="string">"Job '%s' exception occur in job processing"</span>, jobName), cause);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>默认实现 DefaultJobExceptionHandler <strong>打印异常日志，不会抛出异常</strong>。</li></ul><h1 id="4-执行器执行"><a href="#4-执行器执行" class="headerlink" title="4. 执行器执行"></a>4. 执行器执行</h1><h2 id="4-1-检查作业执行环境"><a href="#4-1-检查作业执行环境" class="headerlink" title="4.1 检查作业执行环境"></a>4.1 检查作业执行环境</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkJobExecutionEnvironment</span><span class="params">()</span> <span class="keyword">throws</span> JobExecutionEnvironmentException </span>&#123;</div><div class="line">   configService.checkMaxTimeDiffSecondsTolerable();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>ConfigService#checkMaxTimeDiffSecondsTolerable()</code> 方法校验本机时间是否合法，在<a href="http://www.yunai.me/Elastic-Job/job-config/?self">《Elastic-Job-Lite 源码分析 —— 作业配置》的「3.3」校验本机时间是否合法</a> 已经解析。</li><li>当校验本机时间不合法时，抛出异常。若使用 DefaultJobExceptionHandler 作为异常处理，<strong>只打印日志，不会终止作业执行</strong>。如果你期望作业<strong>终止</strong>执行，需要自定义 JobExceptionHandler 实现。</li></ul><h2 id="4-2-获取当前作业服务器的分片上下文"><a href="#4-2-获取当前作业服务器的分片上下文" class="headerlink" title="4.2 获取当前作业服务器的分片上下文"></a>4.2 获取当前作业服务器的分片上下文</h2><p>调用 <code>LiteJobFacade#getShardingContexts()</code> 方法获取当前作业服务器的分片上下文。通过这个方法，作业获得<strong>其所需要执行的分片</strong>，在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31_bak.jpg">《Elastic-Job-Lite 源码解析 —— 作业执行》</a>详细分享。</p><h2 id="4-3-发布作业状态追踪事件"><a href="#4-3-发布作业状态追踪事件" class="headerlink" title="4.3 发布作业状态追踪事件"></a>4.3 发布作业状态追踪事件</h2><p>调用 <code>LiteJobFacade#postJobStatusTraceEvent()</code> 方法发布作业状态追踪事件，在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31_bak.jpg">《Elastic-Job-Lite 源码解析 —— 任务事件与追踪》</a>详细分享。</p><h2 id="4-4-跳过存在运行中的被错过作业"><a href="#4-4-跳过存在运行中的被错过作业" class="headerlink" title="4.4 跳过存在运行中的被错过作业"></a>4.4 跳过存在运行中的被错过作业</h2><p>该逻辑和<strong>「4.7」执行被错过触发的作业</strong>，一起解析，不然会比较闷逼。</p><h2 id="4-5-执行作业执行前的方法"><a href="#4-5-执行作业执行前的方法" class="headerlink" title="4.5 执行作业执行前的方法"></a>4.5 执行作业执行前的方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeJobExecuted</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (ElasticJobListener each : elasticJobListeners) &#123;</div><div class="line">       each.beforeJobExecuted(shardingContexts);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用作业监听器执行作业<strong>执行前</strong>的方法，在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31_bak.jpg">《Elastic-Job-Lite 源码解析 —— 作业监听器》</a>详细分享。</li></ul><h2 id="4-6-执行普通触发的作业"><a href="#4-6-执行普通触发的作业" class="headerlink" title="4.6 执行普通触发的作业"></a>4.6 执行普通触发的作业</h2><p>这个小节的标题不太正确，其他<strong>作业来源</strong>也是走这样的逻辑。本小节执行作业会经历 4 个方法，方法<strong>顺序</strong>往下调用，我们逐个来看。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 执行多个作业的分片</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> shardingContexts 分片上下文集合</div><div class="line">* <span class="doctag">@param</span> executionSource 执行来源</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts, <span class="keyword">final</span> JobExecutionEvent.ExecutionSource executionSource)</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 执行多个作业的分片</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> shardingContexts 分片上下文集合</div><div class="line">* <span class="doctag">@param</span> executionSource 执行来源</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts, <span class="keyword">final</span> JobExecutionEvent.ExecutionSource executionSource)</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 执行单个作业的分片</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> shardingContexts 分片上下文集合</div><div class="line">* <span class="doctag">@param</span> item 分片序号</div><div class="line">* <span class="doctag">@param</span> startEvent 执行事件(开始)</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts, <span class="keyword">final</span> <span class="keyword">int</span> item, <span class="keyword">final</span> JobExecutionEvent startEvent)</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 执行单个作业的分片【子类实现】</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> shardingContext 分片上下文集合</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(ShardingContext shardingContext)</span></span>;</div></pre></td></tr></table></figure><p>ps：<strong>作业事件</strong>相关逻辑，先统一跳过，在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31_bak.jpg">《Elastic-Job-Lite 源码解析 —— 任务事件与追踪》</a>详细分享。</p><hr><p><strong>private void execute(shardingContexts, executionSource)</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts, <span class="keyword">final</span> JobExecutionEvent.ExecutionSource executionSource)</span> </span>&#123;</div><div class="line">   <span class="comment">// 无可执行的分片，发布作业状态追踪事件(State.TASK_FINISHED)</span></div><div class="line">   <span class="keyword">if</span> (shardingContexts.getShardingItemParameters().isEmpty()) &#123;</div><div class="line">       <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">           jobFacade.postJobStatusTraceEvent(shardingContexts.getTaskId(), State.TASK_FINISHED, String.format(<span class="string">"Sharding item for job '%s' is empty."</span>, jobName));</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 注册作业启动信息</span></div><div class="line">   jobFacade.registerJobBegin(shardingContexts);</div><div class="line">   <span class="comment">// 发布作业状态追踪事件(State.TASK_RUNNING)</span></div><div class="line">   String taskId = shardingContexts.getTaskId();</div><div class="line">   <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">       jobFacade.postJobStatusTraceEvent(taskId, State.TASK_RUNNING, <span class="string">""</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// TODO</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       process(shardingContexts, executionSource);</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       <span class="comment">// TODO 考虑增加作业失败的状态，并且考虑如何处理作业失败的整体回路</span></div><div class="line">       <span class="comment">// 注册作业完成信息</span></div><div class="line">       jobFacade.registerJobCompleted(shardingContexts);</div><div class="line">       <span class="comment">// 根据是否有异常，发布作业状态追踪事件(State.TASK_FINISHED / State.TASK_ERROR)</span></div><div class="line">       <span class="keyword">if</span> (itemErrorMessages.isEmpty()) &#123;</div><div class="line">           <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">               jobFacade.postJobStatusTraceEvent(taskId, State.TASK_FINISHED, <span class="string">""</span>);</div><div class="line">           &#125;</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">               jobFacade.postJobStatusTraceEvent(taskId, State.TASK_ERROR, itemErrorMessages.toString());</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>方法参数 <code>executionSource</code> 代表执行来源( ExecutionSource )，一共有三种：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ExecutionSource &#123;</div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 普通触发</div><div class="line">    */</div><div class="line">   NORMAL_TRIGGER,</div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 被错过触发</div><div class="line">    */</div><div class="line">   MISFIRE,</div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 失效转移触发</div><div class="line">    */</div><div class="line">   FAILOVER</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用 <code>LiteJobFacade#registerJobBegin(...)</code> 方法注册作业<strong>启动</strong>信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerJobBegin</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts)</span> </span>&#123;</div><div class="line">   executionService.registerJobBegin(shardingContexts);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ExecutionService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerJobBegin</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts)</span> </span>&#123;</div><div class="line">   JobRegistry.getInstance().setJobRunning(jobName, <span class="keyword">true</span>);</div><div class="line">   <span class="keyword">if</span> (!configService.load(<span class="keyword">true</span>).isMonitorExecution()) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> each : shardingContexts.getShardingItemParameters().keySet()) &#123;</div><div class="line">       jobNodeStorage.fillEphemeralJobNode(ShardingNode.getRunningNode(each), <span class="string">""</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>当作业配置设置<strong>监控作业运行时状态</strong>( <code>LiteJobConfiguration.monitorExecution = true</code> )，才记录作业运行状态。</li><li>调用 <code>JobNodeStorage#fillEphemeralJobNode(...)</code> 方法记录<strong>其执行的作业分片</strong>正在运行中。如何记录的，在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31_bak.jpg">《Elastic-Job-Lite 源码解析 —— 数据存储》</a>详细分享。</li></ul></li><li><p>调用 <code>LiteJobFacade#registerJobCompleted(...)</code> 方法注册作业<strong>完成</strong>信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerJobCompleted</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts)</span> </span>&#123;</div><div class="line">   executionService.registerJobCompleted(shardingContexts);</div><div class="line">   <span class="keyword">if</span> (configService.load(<span class="keyword">true</span>).isFailover()) &#123;</div><div class="line">       failoverService.updateFailoverComplete(shardingContexts.getShardingItemParameters().keySet());</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ExecutionService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 注册作业完成信息.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> shardingContexts 分片上下文</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerJobCompleted</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts)</span> </span>&#123;</div><div class="line">   JobRegistry.getInstance().setJobRunning(jobName, <span class="keyword">false</span>);</div><div class="line">   <span class="keyword">if</span> (!configService.load(<span class="keyword">true</span>).isMonitorExecution()) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> each : shardingContexts.getShardingItemParameters().keySet()) &#123;</div><div class="line">       jobNodeStorage.removeJobNodeIfExisted(ShardingNode.getRunningNode(each));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><pre><code>* 当作业配置设置**监控作业运行时状态**( `LiteJobConfiguration.monitorExecution = true` )，才记录作业运行状态。
* 调用 `JobNodeStorage#removeJobNodeIfExisted(...)` 方法**移除****其执行的作业分片**正在运行中的标记，表示该作业分片未在运行中。
* 调用 `FailoverService#updateFailoverComplete(...)` 方法更新执行完毕失效转移的分片项状态，在[《Elastic-Job-Lite 源码解析 —— 任务失效转移》](http://www.yunai.me/images/common/wechat_mp_2017_07_31_bak.jpg)详细分享。
</code></pre><hr><p><strong>private void process(shardingContexts, executionSource)</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts, <span class="keyword">final</span> JobExecutionEvent.ExecutionSource executionSource)</span> </span>&#123;</div><div class="line">   Collection&lt;Integer&gt; items = shardingContexts.getShardingItemParameters().keySet();</div><div class="line">   <span class="comment">// 单分片，直接执行</span></div><div class="line">   <span class="keyword">if</span> (<span class="number">1</span> == items.size()) &#123;</div><div class="line">       <span class="keyword">int</span> item = shardingContexts.getShardingItemParameters().keySet().iterator().next();</div><div class="line">       JobExecutionEvent jobExecutionEvent =  <span class="keyword">new</span> JobExecutionEvent(shardingContexts.getTaskId(), jobName, executionSource, item);</div><div class="line">       <span class="comment">// 执行一个作业</span></div><div class="line">       process(shardingContexts, item, jobExecutionEvent);</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 多分片，并行执行</span></div><div class="line">   <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(items.size());</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">final</span> <span class="keyword">int</span> each : items) &#123;</div><div class="line">       <span class="keyword">final</span> JobExecutionEvent jobExecutionEvent = <span class="keyword">new</span> JobExecutionEvent(shardingContexts.getTaskId(), jobName, executionSource, each);</div><div class="line">       <span class="keyword">if</span> (executorService.isShutdown()) &#123;</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line">       executorService.submit(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">           </div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                   <span class="comment">// 执行一个作业</span></div><div class="line">                   process(shardingContexts, each, jobExecutionEvent);</div><div class="line">               &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                   latch.countDown();</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 等待多分片全部完成</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       latch.await();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> InterruptedException ex) &#123;</div><div class="line">       Thread.currentThread().interrupt();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>单分片时，直接执行，无需使用线程池，效率更好。</li><li>多分片时，线程池<strong>并发</strong>执行，使用 CountDownLatch 实现等待任务全部完成。</li></ul><hr><p><strong>private void process(shardingContexts, item, startEvent)</strong><br><strong>protected abstract void process(shardingContext)</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts, <span class="keyword">final</span> <span class="keyword">int</span> item, <span class="keyword">final</span> JobExecutionEvent startEvent)</span> </span>&#123;</div><div class="line">   <span class="comment">// 发布执行事件(开始)</span></div><div class="line">   <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">       jobFacade.postJobExecutionEvent(startEvent);</div><div class="line">   &#125;</div><div class="line">   log.trace(<span class="string">"Job '&#123;&#125;' executing, item is: '&#123;&#125;'."</span>, jobName, item);</div><div class="line">   JobExecutionEvent completeEvent;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 执行单个作业</span></div><div class="line">       process(<span class="keyword">new</span> ShardingContext(shardingContexts, item));</div><div class="line">       <span class="comment">// 发布执行事件(成功)</span></div><div class="line">       completeEvent = startEvent.executionSuccess();</div><div class="line">       log.trace(<span class="string">"Job '&#123;&#125;' executed, item is: '&#123;&#125;'."</span>, jobName, item);</div><div class="line">       <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">           jobFacade.postJobExecutionEvent(completeEvent);</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// CHECKSTYLE:OFF</span></div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable cause) &#123;</div><div class="line">       <span class="comment">// CHECKSTYLE:ON</span></div><div class="line">       <span class="comment">// 发布执行事件(失败)</span></div><div class="line">       completeEvent = startEvent.executionFailure(cause);</div><div class="line">       jobFacade.postJobExecutionEvent(completeEvent);</div><div class="line">       <span class="comment">// 设置该分片执行异常信息</span></div><div class="line">       itemErrorMessages.put(item, ExceptionUtil.transform(cause));</div><div class="line">       <span class="comment">//</span></div><div class="line">       jobExceptionHandler.handleException(jobName, cause);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(ShardingContext shardingContext)</span></span>;</div></pre></td></tr></table></figure><ul><li>不同作业执行器实现类通过实现 <code>#process(shardingContext)</code> 抽象方法，实现对<strong>单个分片</strong>作业的处理。</li></ul><h3 id="4-6-1-简单作业执行器"><a href="#4-6-1-简单作业执行器" class="headerlink" title="4.6.1 简单作业执行器"></a>4.6.1 简单作业执行器</h3><p>SimpleJobExecutor，简单作业执行器</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleJobExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractElasticJobExecutor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 简单作业实现</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SimpleJob simpleJob;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext)</span> </span>&#123;</div><div class="line">        simpleJob.execute(shardingContext);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>SimpleJob#execute()</code> 方法对单个分片作业进行处理。</li></ul><h3 id="4-6-2-数据流作业执行器"><a href="#4-6-2-数据流作业执行器" class="headerlink" title="4.6.2 数据流作业执行器"></a>4.6.2 数据流作业执行器</h3><p>DataflowJobExecutor，数据流作业执行器。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DataflowJobExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractElasticJobExecutor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 数据流作业对象</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DataflowJob&lt;Object&gt; dataflowJob;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext)</span> </span>&#123;</div><div class="line">        DataflowJobConfiguration dataflowConfig = (DataflowJobConfiguration) getJobRootConfig().getTypeConfig();</div><div class="line">        <span class="keyword">if</span> (dataflowConfig.isStreamingProcess()) &#123; <span class="comment">// 流式处理数据</span></div><div class="line">            streamingExecute(shardingContext);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            oneOffExecute(shardingContext);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 流式处理</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> shardingContext 分片上下文</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">streamingExecute</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext)</span> </span>&#123;</div><div class="line">        List&lt;Object&gt; data = fetchData(shardingContext);</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != data &amp;&amp; !data.isEmpty()) &#123;</div><div class="line">            processData(shardingContext, data);</div><div class="line">            <span class="keyword">if</span> (!getJobFacade().isEligibleForJobRunning()) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            data = fetchData(shardingContext);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 一次处理</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> shardingContext 分片上下文</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">oneOffExecute</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext)</span> </span>&#123;</div><div class="line">        List&lt;Object&gt; data = fetchData(shardingContext);</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != data &amp;&amp; !data.isEmpty()) &#123;</div><div class="line">            processData(shardingContext, data);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>当作业配置设置流式处理数据( <code>DataflowJobConfiguration.streamingProcess = true</code> ) 时，调用 <code>#streamingExecute()</code> <strong>不断</strong>加载数据，<strong>不断</strong>处理数据，直到<strong>数据为空</strong> 或者 <strong>作业不适合继续运行</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEligibleForJobRunning</span><span class="params">()</span> </span>&#123;</div><div class="line">   LiteJobConfiguration liteJobConfig = configService.load(<span class="keyword">true</span>);</div><div class="line">   <span class="keyword">if</span> (liteJobConfig.getTypeConfig() <span class="keyword">instanceof</span> DataflowJobConfiguration) &#123;</div><div class="line">       <span class="keyword">return</span> !shardingService.isNeedSharding() <span class="comment">// 作业不需要重新分片</span></div><div class="line">               &amp;&amp; ((DataflowJobConfiguration) liteJobConfig.getTypeConfig()).isStreamingProcess();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> !shardingService.isNeedSharding(); <span class="comment">// 作业不需要重新分片</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>作业需要重新分片，所以不适合继续流式数据处理。</p><blockquote><p>如果采用流式作业处理方式，建议processData处理数据后更新其状态，避免fetchData再次抓取到，从而使得作业永不停止。 流式数据处理参照TbSchedule设计，适用于不间歇的数据处理。</p></blockquote></li></ul></li><li><p>当作业配置<strong>不</strong>设置流式处理数据( <code>DataflowJobConfiguration.streamingProcess = false</code> ) 时，调用 <code>#oneOffExecute()</code> <strong>一次</strong>加载数据，<strong>一次</strong>处理数据。</p></li><li><p>调用 <code>#fetchData()</code> 方法加载数据；调用 <code>#processData(...)</code> 方法处理数据：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DataflowJobExecutor.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 加载数据</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> shardingContext 分片上下文</div><div class="line">* <span class="doctag">@return</span> 数据</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> List&lt;Object&gt; <span class="title">fetchData</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> dataflowJob.fetchData(shardingContext);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 处理数据</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> shardingContext 分片上下文</div><div class="line">* <span class="doctag">@param</span> data 数据</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processData</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext, <span class="keyword">final</span> List&lt;Object&gt; data)</span> </span>&#123;</div><div class="line">   dataflowJob.processData(shardingContext, data);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h3 id="4-6-3-脚本作业执行器"><a href="#4-6-3-脚本作业执行器" class="headerlink" title="4.6.3 脚本作业执行器"></a>4.6.3 脚本作业执行器</h3><p>ScriptJobExecutor，脚本作业执行器。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ScriptJobExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractElasticJobExecutor</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> String scriptCommandLine = ((ScriptJobConfiguration) getJobRootConfig().getTypeConfig()).getScriptCommandLine();</div><div class="line">        <span class="keyword">if</span> (Strings.isNullOrEmpty(scriptCommandLine)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JobConfigurationException(<span class="string">"Cannot find script command line for job '%s', job is not executed."</span>, shardingContext.getJobName());</div><div class="line">        &#125;</div><div class="line">        executeScript(shardingContext, scriptCommandLine);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 执行脚本</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> shardingContext 分片上下文</div><div class="line">     * <span class="doctag">@param</span> scriptCommandLine 执行脚本路径</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeScript</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext, <span class="keyword">final</span> String scriptCommandLine)</span> </span>&#123;</div><div class="line">        CommandLine commandLine = CommandLine.parse(scriptCommandLine);</div><div class="line">        <span class="comment">// JSON 格式传递参数</span></div><div class="line">        commandLine.addArgument(GsonFactory.getGson().toJson(shardingContext), <span class="keyword">false</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">new</span> DefaultExecutor().execute(commandLine);</div><div class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IOException ex) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JobConfigurationException(<span class="string">"Execute script failure."</span>, ex);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p><code>scriptCommandLine</code> 传递的是<strong>脚本路径</strong>。使用 <a href="https://commons.apache.org/proper/commons-exec/" rel="external nofollow noopener noreferrer" target="_blank">Apache Commons Exec</a> 工具包实现脚本调用：</p><blockquote><p>Script类型作业意为脚本类型作业，支持shell，python，perl等所有类型脚本。只需通过控制台或代码配置scriptCommandLine即可，无需编码。执行脚本路径可包含参数，参数传递完毕后，作业框架会自动追加最后一个参数为作业运行时信息。</p></blockquote></li><li><p>脚本参数传递使用 JSON 格式。</p></li></ul><h2 id="4-7-执行被错过触发的作业"><a href="#4-7-执行被错过触发的作业" class="headerlink" title="4.7 执行被错过触发的作业"></a>4.7 执行被错过触发的作业</h2><p>当作业执行过久，导致到达下次执行时间未进行下一次触发，Elastic-Job-Lite 会设置作业分片为被错过( <code>misfired</code> )，下一次执行时，会多执行，补上错过的调度。</p><p><strong>标记作业被错过</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobScheduler.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> Scheduler <span class="title">createScheduler</span><span class="params">()</span> </span>&#123;</div><div class="line">   Scheduler result;</div><div class="line">   <span class="comment">// 省略部分代码</span></div><div class="line">   result.getListenerManager().addTriggerListener(schedulerFacade.newJobTriggerListener());</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> Properties <span class="title">getBaseQuartzProperties</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 省略部分代码</span></div><div class="line">   result.put(<span class="string">"org.quartz.jobStore.misfireThreshold"</span>, <span class="string">"1"</span>);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// JobScheduleController.class</span></div><div class="line"><span class="function"><span class="keyword">private</span> CronTrigger <span class="title">createTrigger</span><span class="params">(<span class="keyword">final</span> String cron)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> TriggerBuilder.newTrigger()</div><div class="line">           .withIdentity(triggerIdentity)</div><div class="line">           .withSchedule(CronScheduleBuilder.cronSchedule(cron)</div><div class="line">           .withMisfireHandlingInstructionDoNothing())</div><div class="line">           .build();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>org.quartz.jobStore.misfireThreshold</code> 设置超过 1 毫秒，作业即被视为错过。</li><li><code>#withMisfireHandlingInstructionDoNothing()</code> 设置 Quartz 系统不会立刻再执行任务，而是等到距离目前时间最近的预计时间执行。<strong>重新执行错过的作业交给 Elastic-Job-Lite 处理</strong>。</li><li><p>使用 TriggerListener 监听被错过的作业分片：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobTriggerListener.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobTriggerListener</span> <span class="keyword">extends</span> <span class="title">TriggerListenerSupport</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">triggerMisfired</span><span class="params">(<span class="keyword">final</span> Trigger trigger)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != trigger.getPreviousFireTime()) &#123;</div><div class="line">            executionService.setMisfire(shardingService.getLocalShardingItems());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ExecutionService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMisfire</span><span class="params">(<span class="keyword">final</span> Collection&lt;Integer&gt; items)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> each : items) &#123;</div><div class="line">       jobNodeStorage.createJobNodeIfNeeded(ShardingNode.getMisfireNode(each));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>#setMisfire(...)</code> 设置作业分片被错过执行。</li></ul></li></ul><p><strong>跳过存在运行中的被错过作业</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">misfireIfRunning</span><span class="params">(<span class="keyword">final</span> Collection&lt;Integer&gt; shardingItems)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> executionService.misfireIfHasRunningItems(shardingItems);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ExecutionService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">misfireIfHasRunningItems</span><span class="params">(<span class="keyword">final</span> Collection&lt;Integer&gt; items)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (!hasRunningItems(items)) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">   setMisfire(items);</div><div class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasRunningItems</span><span class="params">(<span class="keyword">final</span> Collection&lt;Integer&gt; items)</span> </span>&#123;</div><div class="line">   LiteJobConfiguration jobConfig = configService.load(<span class="keyword">true</span>);</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> == jobConfig || !jobConfig.isMonitorExecution()) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> each : items) &#123;</div><div class="line">       <span class="keyword">if</span> (jobNodeStorage.isJobNodeExisted(ShardingNode.getRunningNode(each))) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>当作业分片里存在<strong>任意一个分片正在运行</strong>中，设置分片项<strong>都</strong>被错过执行( <code>misfired</code> )，并不执行这些作业分片。如果不进行跳过，则可能导致<strong>同时</strong>运行某个作业分片。</li><li>该功能依赖作业配置<strong>监控作业运行时状态</strong>( <code>LiteJobConfiguration.monitorExecution = true</code> )。</li></ul><p><strong>执行被错过触发的作业</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// .... 省略部分代码</span></div><div class="line">   <span class="comment">// 执行 被跳过触发的作业</span></div><div class="line">   <span class="keyword">while</span> (jobFacade.isExecuteMisfired(shardingContexts.getShardingItemParameters().keySet())) &#123;</div><div class="line">       jobFacade.clearMisfire(shardingContexts.getShardingItemParameters().keySet());</div><div class="line">       execute(shardingContexts, JobExecutionEvent.ExecutionSource.MISFIRE);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// .... 省略部分代码</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExecuteMisfired</span><span class="params">(<span class="keyword">final</span> Collection&lt;Integer&gt; shardingItems)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> isEligibleForJobRunning() <span class="comment">// 合适继续运行</span></div><div class="line">           &amp;&amp; configService.load(<span class="keyword">true</span>).getTypeConfig().getCoreConfig().isMisfire() <span class="comment">// 作业配置开启作业被错过触发</span></div><div class="line">           &amp;&amp; !executionService.getMisfiredJobItems(shardingItems).isEmpty(); <span class="comment">// 所执行的作业分片存在被错过( misfired )</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearMisfire</span><span class="params">(<span class="keyword">final</span> Collection&lt;Integer&gt; shardingItems)</span> </span>&#123;</div><div class="line">   executionService.clearMisfire(shardingItems);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>清除作业分片被错过执行的标识，并进行作业执行。</li><li>TODO：为什么这里使用 <code>where()</code>，确认后补充。</li></ul><h2 id="4-8-执行作业失效转移"><a href="#4-8-执行作业失效转移" class="headerlink" title="4.8 执行作业失效转移"></a>4.8 执行作业失效转移</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failoverIfNecessary</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (configService.load(<span class="keyword">true</span>).isFailover()) &#123;</div><div class="line">       failoverService.failoverIfNecessary();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用作业失效转移服务( FailoverService )执行作业失效转移( <code>#failoverIfNecessary()</code> )，在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31_bak.jpg">《Elastic-Job-Lite 源码解析 —— 任务失效转移》</a>详细分享。</li></ul><h2 id="4-9-执行作业执行后的方法"><a href="#4-9-执行作业执行后的方法" class="headerlink" title="4.9 执行作业执行后的方法"></a>4.9 执行作业执行后的方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterJobExecuted</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (ElasticJobListener each : elasticJobListeners) &#123;</div><div class="line">       each.afterJobExecuted(shardingContexts);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用作业监听器执行作业<strong>执行后</strong>的方法，在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31_bak.jpg">《Elastic-Job-Lite 源码解析 —— 作业监听器》</a>详细分享。</li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1></div><footer class="article-footer clearfix"><div class="article-share" id="share"><div data-url="http://www.yunai.me/Elastic-Job/2017_09_23_Elastic-Job-Lite 源码解析 —— 作业执行/" data-title="芋艿V的博客" data-tsina="null" class="share clearfix"></div></div></footer></article><nav class="article-nav clearfix"><div class="prev"><a href="/Sharding-JDBC/transaction-tcc/" title="Sharding-JDBC 源码分析 —— 分布式事务（二）之事务补偿型"><strong>PREVIOUS:</strong><br><span>Sharding-JDBC 源码分析 —— 分布式事务（二）之事务补偿型</span></a></div><div class="next"><a href="/Sharding-JDBC/transaction-bed/" title="Sharding-JDBC 源码分析 —— 分布式事务（一）之最大努力型"><strong>NEXT:</strong><br><span>Sharding-JDBC 源码分析 —— 分布式事务（一）之最大努力型</span></a></div></nav></div></div><footer><div id="footer"><p class="copyright">© 2017 <a href="http://www.yunai.me" target="_blank" title="王文斌">王文斌</a> && <span style="display:inline" id="busuanzi_container_site_uv">总访客数 <span id="busuanzi_value_site_uv" font="微软雅黑"></span> 次</span> && <span style="display:inline" id="busuanzi_container_site_pv">总访问量 <span id="busuanzi_value_site_pv" font="微软雅黑"></span> 次</span> && Hosted by <a href="https://pages.coding.me" style="font-weight:700" rel="external nofollow noopener noreferrer" target="_blank">Coding Pages</a> && Powered by <a href="http://hexo.io" target="_blank" title="hexo" rel="external nofollow noopener noreferrer">hexo</a> && Theme by <a href="http://gengbiao.me" target="_blank" title="coney" rel="external nofollow noopener noreferrer">coney</a></p></div></footer><script src="/js/jquery-2.1.0.min.js"></script><script type="text/javascript">$(document).ready(function(){function e(){"number"==typeof window.innerWidth?n=window.innerWidth:document.documentElement&&document.documentElement.clientWidth&&(n=document.documentElement.clientWidth)}$(".navbar").click(function(){$("header nav").toggleClass("shownav")});var n=0,s=$("#main"),a=$("#asidepart"),o=$(".closeaside"),d=$(".openaside");$(window).resize(function(){e(),n>=1024?$("header nav").removeClass("shownav"):(s.removeClass("moveMain"),a.css("display","block").removeClass("fadeOut"),d.css("display","none"),$("#toc.toc-aside").css("display","none"))}),o.click(function(){a.addClass("fadeOut").css("display","none"),d.css("display","block").addClass("fadeIn"),s.addClass("moveMain")}),d.click(function(){d.css("display","none").removeClass("beforeFadeIn"),a.css("display","block").removeClass("fadeOut").addClass("fadeIn"),s.removeClass("moveMain")}),$(window).scroll(function(){d.css("top",Math.max(80,260-$(this).scrollTop()))})})</script><script type="text/javascript">$(document).ready(function(){var a=$(".article-content>iframe"),t=$(".article-content>embed"),n=$("#toc");$("article h2"),ah=$("article h2"),ta=$("#toc.toc-aside"),o=$(".openaside"),c=$(".closeaside"),a.length>0&&a.wrap('<div class="video-container" />'),t.length>0&&t.wrap('<div class="video-container" />'),0==ah.length?n.css("display","none"):(c.click(function(){ta.css("display","block").addClass("fadeIn")}),o.click(function(){ta.css("display","none")}),$(window).scroll(function(){ta.css("top",Math.max(140,320-$(this).scrollTop()))}))})</script><script type="text/javascript">$(document).ready(function(){var t=$(".share"),a=t.attr("data-url"),e=encodeURIComponent(a),r=['<a href="#" class="overlay" id="qrcode"></a>','<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url='+e+'"/></div>','<a href="#textlogo" class="article-back-to-top" title="Top"></a>','<a href="https://www.facebook.com/sharer.php?u='+e+'" class="article-share-facebook" target="_blank" title="Facebook"></a>','<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>','<a href="https://twitter.com/intent/tweet?url='+e+'" class="article-share-twitter" target="_blank" title="Twitter"></a>','<a href="http://service.weibo.com/share/share.php?title='+t.attr("data-title")+"&url="+e+"&ralateUid="+t.attr("data-tsina")+'&searchPic=true&style=number" class="article-share-weibo" target="_blank" title="Weibo"></a>','<span title="Share to"></span>'].join("");t.append(r),$(".article-share-qrcode").click(function(){var t=$("#qrcode-pic").attr("data-src");$("#qrcode-pic").attr("src",t),$("#qrcode-pic").load(function(){$(".qrcode strong").text(" ")})})})</script><link rel="stylesheet" href="/alert/css/alert.css"><script src="/alert/js/alert.js"></script><script src="/js/jquery.cookie.js"></script><script>$(document).ready(function(){function e(){var e=jqueryAlert({title:"👼每周六更新一篇源码解析，【扫一扫】关注公众号👼",width:"500",height:"580",modal:!0,content:n+'<p style="color: red">今日'+c+"已关注人数："+p+'</p><img width="400" src="http://www.yunai.me/images/common/wechat_mp_simple.png" /><p style="color: red">关注后，欢迎加入【源码圈】微信群交流</p><p style="color: red">一起看源码，读源码，提升技术！</p>',buttons:{"已关注，关闭窗口（公众号发送：【口令】屏蔽弹窗）":function(){e.close()}}});$.cookie(o,i+1,{expires:1,path:"/"})}if(!(location.href.indexOf("vip")>=0||location.href.indexOf("127.0.0.1")>=0)){var o="doubi",i=$.cookie(o);i?i=parseInt(i):($.cookie(o,0,{expires:1,path:"/"}),i=0),$.cookie(o,i,{expires:1,path:"/"});var t="default",r={juejin:"掘金",oschina:"开源中国",sjdbc:"Sharding-JDBC",jianshu:"简书",csdn:"CSDN",iteye:"iteye",cnblogs:"博客园"};for(var a in r)if(location.search.indexOf(a)>=0){t=a;break}"default"===t&&(t=$.cookie("from")||"default"),$.cookie("from",t,{expires:365,path:"/"});var n="",c="";if(t&&r[t]&&(n='<p style="color: red">欢迎来自【'+r[t]+"】的同学</p>",c="【"+r[t]+"】"),i<=3){var p=103+5*(new Date).getHours();setTimeout(e,1e4*(i+1))}}})</script></body>