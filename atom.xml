<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>芋道源码 —— 纯源码解析BLOG</title>
  
  <subtitle>愿半生编码，如一生老友！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.iocoder.cn/"/>
  <updated>2017-09-12T14:58:53.000Z</updated>
  <id>http://www.iocoder.cn/</id>
  
  <author>
    <name>王文斌</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TCC-Transaction 源码分析 —— TCC 实现</title>
    <link href="http://www.iocoder.cn/TCC-Transaction/build-debugging-environment/"/>
    <id>http://www.iocoder.cn/TCC-Transaction/build-debugging-environment/</id>
    <published>2018-02-07T16:00:00.000Z</published>
    <updated>2017-09-12T14:58:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文分享 <strong>TCC 实现</strong>。主要涉及如下三个 Maven 项目：</p><ul><li><code>tcc-transaction-core</code> ：tcc-transaction 底层实现。</li><li><code>tcc-transaction-api</code> ：tcc-transaction 使用 API。</li><li><code>tcc-transaction-spring</code> ：tcc-transaction Spring 支持。</li></ul><p>下面一起来简单理解下 <strong>TCC 型事务的概念</strong>。</p><blockquote><p>FROM <a href="https://support.hwclouds.com/devg-servicestage/zh-cn_topic_0056814426.html" rel="external nofollow noopener noreferrer" target="_blank">https://support.hwclouds.com/devg-servicestage/zh-cn_topic_0056814426.html</a><br><strong>TCC事务</strong><br>为了解决在事务运行过程中大颗粒度资源锁定的问题，业界提出一种新的事务模型，它是基于<strong>业务层面</strong>的事务定义。锁粒度完全由业务自己控制。它本质是一种补偿的思路。它把事务运行过程分成 Try、Confirm / Cancel 两个阶段。在每个阶段的逻辑由<strong>业务代码控制</strong>。这样就事务的锁粒度可以完全自由控制。业务可以在牺牲隔离性的情况下，获取更高的性能。</p></blockquote><ul><li>Try 阶段<ul><li>Try ：尝试执行业务 <ul><li>完成所有业务检查( 一致性 ) </li><li>预留必须业务资源( 准隔离性 )</li></ul></li></ul></li><li>Confirm / Cancel 阶段：<ul><li>Confirm ：确认执行业务<ul><li>真正执行业务</li><li>不做任务业务检查</li><li>Confirm 操作满足幂等性</li></ul></li><li>Cancel ：取消执行业务<ul><li>释放 Try 阶段预留的业务资源</li><li>Cancel 操作满足幂等性 </li></ul></li><li>Confirm 与 Cancel 互斥</li></ul></li></ul><p>整体流程如下图：</p><p><img src="../../../images/TCC-Transaction/2018_02_08/01.jpeg" alt=""></p><ul><li><p><strong>红框部分</strong>功能由 <code>tcc-transaction-core</code> 实现：</p><ul><li>启动业务活动</li><li>登记业务操作</li><li>提交 / 回滚业务活动</li></ul></li><li><p><strong>黄框部分</strong>功能由 <code>tcc-transaction-http-sample</code> 实现( 官方提供的示例项目 )：</p><ul><li>Try 操作</li><li>Confirm 操作</li><li>Cancel 操作 </li></ul></li></ul><p>// TODO TCC 与 2PC</p><p>参考资料：</p><ul><li><a href="https://www.zhihu.com/question/31813039" rel="external nofollow noopener noreferrer" target="_blank">《支付宝运营架构中柔性事务指的是什么？》</a></li><li><a href="http://kaimingwan.com/post/fen-bu-shi/fen-bu-shi-shi-wu-de-dian-xing-chu-li-fang-shi-2pc-tcc-yi-bu-que-bao-he-zui-da-nu-li-xing" rel="external nofollow noopener noreferrer" target="_blank">《分布式事务的典型处理方式:2PC、TCC、异步确保和最大努力型》</a></li></ul><blockquote><p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 TCC-Transaction 点赞！<a href="https://github.com/changmingxie/tcc-transaction" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p></blockquote><p>OK，开始我们的第一段 TCC 旅程吧。</p><p>ps：笔者假设你已经阅读过<a href="https://github.com/changmingxie/tcc-transaction/wiki/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%971.2.x" rel="external nofollow noopener noreferrer" target="_blank">《tcc-transaction 官方文档 —— 使用指南1.2.x》</a>。</p><p>ps2：<strong>未特殊说明的情况下，本文事务指的是 TCC事务</strong>。</p><p>ps3：本文采用<strong>“倒序”</strong>( 例如，Domain =&gt; Dao =&gt; Service =&gt; Controller )分享代码实现，建议阅读方式：简读 x 1 + 深读 x 1。采用<strong>“倒序”</strong>的方式，你可以比较整体的理解每一层的实现。</p><h1 id="2-事务与参与者"><a href="#2-事务与参与者" class="headerlink" title="2. 事务与参与者"></a>2. 事务与参与者</h1><p>在 TCC 里，<strong>一个</strong>事务( <code>org.mengyun.tcctransaction.Transaction</code> ) 可以有<strong>多个</strong>参与者( <code>org.mengyun.tcctransaction.Participant</code> )参与业务活动。类图关系如下( <a href="../../../images/TCC-Transaction/2018_02_08/02.png">打开大图</a> )：</p><p><img src="../../../images/TCC-Transaction/2018_02_08/02.png" alt=""></p><p><strong>Transaction 实现代码如下</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7291423944314337931L</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 事务编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> TransactionXid xid;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 事务状态</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> TransactionStatus status;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 事务类型</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> TransactionType transactionType;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 重试次数</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> retriedCount = <span class="number">0</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 创建时间</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Date createTime = <span class="keyword">new</span> Date();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 最后更新时间</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Date lastUpdateTime = <span class="keyword">new</span> Date();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 版本号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> version = <span class="number">1</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 参与者集合</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> List&lt;Participant&gt; participants = <span class="keyword">new</span> ArrayList&lt;Participant&gt;();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 附带属性映射</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; attachments = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;();</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 添加参与者</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> participant 参与者</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enlistParticipant</span><span class="params">(Participant participant)</span> </span>&#123;</div><div class="line">        participants.add(participant);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 提交 TCC 事务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Participant participant : participants) &#123;</div><div class="line">            participant.commit();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 回滚 TCC 事务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Participant participant : participants) &#123;</div><div class="line">            participant.rollback();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>xid，事务编号( TransactionXid )，用于唯一标识一个事务。使用 UUID 算法生成，<strong>保证唯一性</strong>。<code>org.mengyun.tcctransaction.api.TransactionXid</code> 实现 <a href="https://docs.oracle.com/javase/8/docs/api/javax/transaction/xa/Xid.html" rel="external nofollow noopener noreferrer" target="_blank"><code>javax.transaction.xa.Xid</code></a> 接口，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionXid</span> <span class="keyword">implements</span> <span class="title">Xid</span>, <span class="title">Serializable</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6817267250789142043L</span>;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * xid 格式标识符</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> formatId = <span class="number">1</span>;</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 全局事务编号</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] globalTransactionId;</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 分支事务编号</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] branchQualifier;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    ``` </div><div class="line">    * TODO 为什么要继承 Xid 接口？</div><div class="line">    * 一个**全局事务**包含的多个参与者，每个参与者都形成自己的**分支事务**，它们使用全局事务编号( `globalTransactionId` ) 进行关联。下文会看到这块具体的代码实现。TODO</div><div class="line">* status，事务状态( TransactionStatus )。`org.mengyun.tcctransaction.api.TransactionStatus` 实现代码如下：</div><div class="line"></div><div class="line">    ```Java</div><div class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> TransactionStatus &#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 尝试中状态</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        TRYING(<span class="number">1</span>),</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 确认中状态</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        CONFIRMING(<span class="number">2</span>),</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 取消中状态</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        CANCELLING(<span class="number">3</span>);</div><div class="line">    </div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> id;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li><li><p>transactionType，事务类型( TransactionType )。<code>org.mengyun.tcctransaction.common.TransactionType</code> 实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> TransactionType &#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 全局事务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    ROOT(<span class="number">1</span>),</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 分支事务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    BRANCH(<span class="number">2</span>);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> id;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>retriedCount，重试次数。在 TCC 过程中，可能参与者异常崩溃，这个时候会进行重试直到成功或超过最大次数。在<a href="http://www.iocoder.cn?todo">《TCC-Transaction 源码解析 —— 事务恢复》</a>详细解析。</p></li><li>version，版本号，用于乐观锁更新事务。下文会看到这块具体的代码实现。TODO</li><li>participants，事务参与者集合。</li><li>attachments，附带属性映射。在<a href="http://www.iocoder.cn?todo">《TCC-Transaction 源码解析 —— Dubbo 支持》</a>详细解析。</li><li>提供 <code>#enlistParticipant()</code> 方法，添加事务参与者。</li><li>提供 <code>#commit()</code> 方法，调用参与者们提交事务。</li><li>提供 <code>#rollback()</code> 方法，调用参与者回滚事务。</li></ul><p><strong>Participant 实现代码如下</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Participant</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4127729421281425247L</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 事务编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> TransactionXid xid;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 确认执行业务方法调用上下文</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> InvocationContext confirmInvocationContext;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 取消执行业务方法</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> InvocationContext cancelInvocationContext;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 执行器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Terminator terminator = <span class="keyword">new</span> Terminator();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 事务上下文编辑</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    Class&lt;? extends TransactionContextEditor&gt; transactionContextEditorClass;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 提交事务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</div><div class="line">        terminator.invoke(<span class="keyword">new</span> TransactionContext(xid, TransactionStatus.CONFIRMING.getId()), confirmInvocationContext, transactionContextEditorClass);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 回滚事务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span>&#123;</div><div class="line">        terminator.invoke(<span class="keyword">new</span> TransactionContext(xid, TransactionStatus.CANCELLING.getId()), cancelInvocationContext, transactionContextEditorClass);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>xid，<strong>分支</strong>事务编号。</li><li><p>confirmInvocationContext，确认执行业务方法调用上下文( InvocationContext )。<code>org.mengyun.tcctransaction.InvocationContext</code> 实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvocationContext</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7969140711432461165L</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 类</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Class targetClass;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 方法名</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String methodName;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 参数类型数组</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Class[] parameterTypes;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 参数数组</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Object[] args;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>InvocationContext，执行方法调用上下文，记录类、方法名、参数类型数组、参数数组。通过这些属性，可以执行提交 / 回滚事务。在 <code>org.mengyun.tcctransaction.Terminator</code> 会看到具体的代码实现。</li></ul></li><li><p>cancelInvocationContext，取消执行业务方法调用上下文( InvocationContext )。</p></li><li><p>terminator，执行器( Terminator )。<code>org.mengyun.tcctransaction.Terminator</code> 实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Terminator</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">164958655471605778L</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(TransactionContext transactionContext, InvocationContext invocationContext, Class&lt;? extends TransactionContextEditor&gt; transactionContextEditorClass)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(invocationContext.getMethodName())) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 获得 参与者对象</span></div><div class="line">                Object target = FactoryBuilder.factoryOf(invocationContext.getTargetClass()).getInstance();</div><div class="line">                <span class="comment">// 获得 方法</span></div><div class="line">                Method method = target.getClass().getMethod(invocationContext.getMethodName(), invocationContext.getParameterTypes());</div><div class="line">                <span class="comment">// 设置 事务上下文 到方法参数</span></div><div class="line">                FactoryBuilder.factoryOf(transactionContextEditorClass).getInstance().set(transactionContext, target, method, invocationContext.getArgs());</div><div class="line">                <span class="comment">// 执行方法</span></div><div class="line">                <span class="keyword">return</span> method.invoke(target, invocationContext.getArgs());</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SystemException(e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>TODO FactoryBuilder</li><li>TransactionContextEditor，在本文<a href="#">「4.1 Compensable」</a>详细解析。</li></ul></li><li>transactionContextEditorClass，TODO</li><li>提交 <code>#commit()</code> 方法，提交参与者自己的事务。</li><li>提交 <code>#rollback()</code> 方法，回滚参与者自己的事务。 </li></ul><h1 id="3-事务管理器"><a href="#3-事务管理器" class="headerlink" title="3. 事务管理器"></a>3. 事务管理器</h1><p><code>org.mengyun.tcctransaction.TransactionManager</code>，事务管理器，提供事务的获取、发起、提交、回滚，参与者的新增等等方法。</p><h2 id="3-1-发起根事务"><a href="#3-1-发起根事务" class="headerlink" title="3.1 发起根事务"></a>3.1 发起根事务</h2><p>提供 <code>begin()</code> 方法，发起根事务。该方法在<strong>调用方法类型为 MethodType.ROOT 并且 事务处于 Try 阶段</strong>被调用。TODO</p><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TransactionManager.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 发起根事务</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 事务</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> Transaction <span class="title">begin</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 创建 根事务</span></div><div class="line">   Transaction transaction = <span class="keyword">new</span> Transaction(TransactionType.ROOT);</div><div class="line">   <span class="comment">// 存储 事务</span></div><div class="line">   transactionRepository.create(transaction);</div><div class="line">   <span class="comment">// 注册 事务</span></div><div class="line">   registerTransaction(transaction);</div><div class="line">   <span class="keyword">return</span> transaction;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 Transaction 构造方法，创建<strong>根事务</strong>。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Transaction.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 创建指定类型的事务</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> transactionType 事务类型</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Transaction</span><span class="params">(TransactionType transactionType)</span> </span>&#123;</div><div class="line">   <span class="keyword">this</span>.xid = <span class="keyword">new</span> TransactionXid();</div><div class="line">   <span class="keyword">this</span>.status = TransactionStatus.TRYING; <span class="comment">// 尝试中状态</span></div><div class="line">   <span class="keyword">this</span>.transactionType = transactionType;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>目前该构造方法只有 <code>TransactionManager#begin()</code> 在调用，即只创建<strong>根事务</strong>。</li></ul></li><li>调用 <code>TransactionRepository#crete()</code> 方法，存储事务。TODO</li><li><p>调用 <code>#registerTransaction(...)</code> 方法，注册事务到当前线程事务队列。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TransactionManager.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 当前线程事务队列</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Deque&lt;Transaction&gt;&gt; CURRENT = <span class="keyword">new</span> ThreadLocal&lt;Deque&lt;Transaction&gt;&gt;();</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 注册事务到当前线程事务队列</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> transaction 事务</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerTransaction</span><span class="params">(Transaction transaction)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (CURRENT.get() == <span class="keyword">null</span>) &#123;</div><div class="line">       CURRENT.set(<span class="keyword">new</span> LinkedList&lt;Transaction&gt;());</div><div class="line">   &#125;</div><div class="line">   CURRENT.get().push(transaction); <span class="comment">// 添加到头部</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>可能有同学会比较好奇，为什么使用队列存储当前线程事务</strong>？TCC-Transaction 支持<strong>多个</strong>的事务<strong>独立存在</strong>，后创建的事务先提交，类似 Spring 的<code>org.springframework.transaction.annotation.Propagation.REQUIRES_NEW</code> 。在下文，很快我们就会看到 TCC-Transaction 自己的 <code>org.mengyun.tcctransaction.api.Propagation</code> 。</li></ul></li></ul><h2 id="3-2-传播发起分支事务"><a href="#3-2-传播发起分支事务" class="headerlink" title="3.2 传播发起分支事务"></a>3.2 传播发起分支事务</h2><p>调用 <code>#propagationNewBegin(...)</code> 方法，传播发起<strong>分支</strong>事务。该方法在<strong>调用方法类型为 MethodType.PROVIDER 并且 事务处于 Try 阶段</strong>被调用。TODO</p><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 传播发起分支事务</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> transactionContext 事务上下文</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 分支事务</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> Transaction <span class="title">propagationNewBegin</span><span class="params">(TransactionContext transactionContext)</span> </span>&#123;</div><div class="line">  <span class="comment">// 创建 分支事务</span></div><div class="line">  Transaction transaction = <span class="keyword">new</span> Transaction(transactionContext);</div><div class="line">  <span class="comment">// 存储 事务</span></div><div class="line">  transactionRepository.create(transaction);</div><div class="line">  <span class="comment">// 注册 事务</span></div><div class="line">  registerTransaction(transaction);</div><div class="line">  <span class="keyword">return</span> transaction;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 Transaction 构造方法，创建<strong>分支事务</strong>。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 创建分支事务</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> transactionContext 事务上下文</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Transaction</span><span class="params">(TransactionContext transactionContext)</span> </span>&#123;</div><div class="line">   <span class="keyword">this</span>.xid = transactionContext.getXid(); <span class="comment">// 事务上下文的 xid</span></div><div class="line">   <span class="keyword">this</span>.status = TransactionStatus.TRYING; <span class="comment">// 尝试中状态</span></div><div class="line">   <span class="keyword">this</span>.transactionType = TransactionType.BRANCH; <span class="comment">// 分支事务</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>分支</strong>事务使用传播的事务上下文的事务编号。</li></ul></li><li>调用 <code>TransactionRepository#crete()</code> 方法，存储事务。TODO 这里想想怎么说清楚。会在对应服务在存储一次transaction。</li><li>调用 <code>#registerTransaction(...)</code> 方法，注册事务到当前线程事务队列。</li></ul><h2 id="3-3-传播获取分支事务"><a href="#3-3-传播获取分支事务" class="headerlink" title="3.3 传播获取分支事务"></a>3.3 传播获取分支事务</h2><p>调用 <code>#propagationExistBegin(...)</code> 方法，传播发起<strong>分支</strong>事务。该方法在<strong>调用方法类型为 MethodType.PROVIDER 并且 事务处于 Confirm / Cancel 阶段</strong>被调用。TODO</p><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 传播获取分支事务</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> transactionContext 事务上下文</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 分支事务</span></div><div class="line"><span class="comment">* <span class="doctag">@throws</span> NoExistedTransactionException 当事务不存在时</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> Transaction <span class="title">propagationExistBegin</span><span class="params">(TransactionContext transactionContext)</span> <span class="keyword">throws</span> NoExistedTransactionException </span>&#123;</div><div class="line">   <span class="comment">// 查询 事务</span></div><div class="line">   Transaction transaction = transactionRepository.findByXid(transactionContext.getXid());</div><div class="line">   <span class="keyword">if</span> (transaction != <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="comment">// 设置 事务 状态</span></div><div class="line">       transaction.changeStatus(TransactionStatus.valueOf(transactionContext.getStatus()));</div><div class="line">       <span class="comment">// 注册 事务</span></div><div class="line">       registerTransaction(transaction);</div><div class="line">       <span class="keyword">return</span> transaction;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> NoExistedTransactionException();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>TransactionRepository#findByXid()</code> 方法，查询事务。</li><li>调用 <code>Transaction#changeStatus(...)</code> 方法，<strong>设置</strong>事务状态为 CONFIRMING 或 CANCELLING。</li><li>调用 <code>#registerTransaction(...)</code> 方法，注册事务到当前线程事务队列。</li><li>为什么此处是<strong>分支</strong>事务呢？结合 <code>#propagationNewBegin(...)</code> 思考下。 </li></ul><h2 id="3-4-提交事务"><a href="#3-4-提交事务" class="headerlink" title="3.4 提交事务"></a>3.4 提交事务</h2><p>调用 <code>#commit(...)</code> 方法，提交事务。该方法在<strong>事务处于 Confirm / Cancel 阶段</strong>被调用。</p><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 提交事务</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 获取 事务</span></div><div class="line">   Transaction transaction = getCurrentTransaction();</div><div class="line">   <span class="comment">// 设置 事务状态 为 CONFIRMING</span></div><div class="line">   transaction.changeStatus(TransactionStatus.CONFIRMING);</div><div class="line">   <span class="comment">// 更新 事务</span></div><div class="line">   transactionRepository.update(transaction);</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 提交 事务</span></div><div class="line">       transaction.commit();</div><div class="line">       <span class="comment">// 删除 事务</span></div><div class="line">       transactionRepository.delete(transaction);</div><div class="line">   &#125; <span class="keyword">catch</span> (Throwable commitException) &#123;</div><div class="line">       logger.error(<span class="string">"compensable transaction confirm failed."</span>, commitException);</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ConfirmingException(commitException);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>#getCurrentTransaction()</code> 方法， 获取事务。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Transaction <span class="title">getCurrentTransaction</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (isTransactionActive()) &#123;</div><div class="line">       <span class="keyword">return</span> CURRENT.get().peek(); <span class="comment">// 获得头部元素</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTransactionActive</span><span class="params">()</span> </span>&#123;</div><div class="line">   Deque&lt;Transaction&gt; transactions = CURRENT.get();</div><div class="line">   <span class="keyword">return</span> transactions != <span class="keyword">null</span> &amp;&amp; !transactions.isEmpty();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>为什么获得队列<strong>头部</strong>元素呢？该元素即是上文调用 <code>#registerTransaction(...)</code> 注册到队列头部。</li></ul></li><li>调用 <code>Transaction#changeStatus(...)</code> 方法， <strong>设置</strong>事务状态为 CONFIRMING。</li><li>调用 <code>TransactionRepository#update(...)</code> 方法， <strong>更新</strong>事务。</li><li>调用 <code>Transaction#commit(...)</code> 方法， <strong>提交</strong>事务。</li><li>调用 <code>TransactionRepository#delete(...)</code> 方法，<strong>删除</strong>事务。</li></ul><h2 id="3-5-回滚事务"><a href="#3-5-回滚事务" class="headerlink" title="3.5 回滚事务"></a>3.5 回滚事务</h2><p>调用 <code>#rollback(...)</code> 方法，取消事务，和 <code>#commit()</code> 方法基本类似。该方法在<strong>事务处于 Confirm / Cancel 阶段</strong>被调用。</p><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 回滚事务</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 获取 事务</span></div><div class="line">   Transaction transaction = getCurrentTransaction();</div><div class="line">   <span class="comment">// 设置 事务状态 为 CANCELLING</span></div><div class="line">   transaction.changeStatus(TransactionStatus.CANCELLING);</div><div class="line">   <span class="comment">// 更新 事务</span></div><div class="line">   transactionRepository.update(transaction);</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 提交 事务</span></div><div class="line">       transaction.rollback();</div><div class="line">       <span class="comment">// 删除 事务</span></div><div class="line">       transactionRepository.delete(transaction);</div><div class="line">   &#125; <span class="keyword">catch</span> (Throwable rollbackException) &#123;</div><div class="line">       logger.error(<span class="string">"compensable transaction rollback failed."</span>, rollbackException);</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> CancellingException(rollbackException);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>#getCurrentTransaction()</code> 方法，获取事务。</li><li>调用 <code>Transaction#changeStatus(...)</code> 方法， <strong>设置</strong>事务状态为 CANCELLING。</li><li>调用 <code>TransactionRepository#update(...)</code> 方法， <strong>更新</strong>事务。</li><li>调用 <code>Transaction#rollback(...)</code> 方法， <strong>回滚</strong>事务。</li><li>调用 <code>TransactionRepository#delete(...)</code> 方法，<strong>删除</strong>事务。</li></ul><h2 id="3-6-添加参与者到事务"><a href="#3-6-添加参与者到事务" class="headerlink" title="3.6 添加参与者到事务"></a>3.6 添加参与者到事务</h2><p>调用 <code>#enlistParticipant(...)</code> 方法，添加参与者到事务。该方法在<strong>事务处于 Try 阶段</strong>被调用。TODO</p><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 添加参与者到事务</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> participant 参与者</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enlistParticipant</span><span class="params">(Participant participant)</span> </span>&#123;</div><div class="line">   <span class="comment">// 获取 事务</span></div><div class="line">   Transaction transaction = <span class="keyword">this</span>.getCurrentTransaction();</div><div class="line">   <span class="comment">// 添加参与者</span></div><div class="line">   transaction.enlistParticipant(participant);</div><div class="line">   <span class="comment">// 更新 事务</span></div><div class="line">   transactionRepository.update(transaction);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>#getCurrentTransaction()</code> 方法，获取事务。</li><li>调用 <code>Transaction#enlistParticipant(...)</code> 方法， 添加参与者到事务。</li><li>调用 <code>TransactionRepository#update(...)</code> 方法， <strong>更新</strong>事务。</li></ul><h1 id="4-事务拦截器"><a href="#4-事务拦截器" class="headerlink" title="4. 事务拦截器"></a>4. 事务拦截器</h1><p>TCC-Transaction 基于 <code>org.mengyun.tcctransaction.api.@Compensable</code> <strong>注解</strong> + <code>org.aspectj.lang.annotation.@Aspect</code> <strong>AOP 切面</strong>实现业务方法的 TCC 事务声明<strong>拦截</strong>，同 Spring 的 <code>org.springframework.transaction.annotation.@Transactional</code> 的实现。</p><p>TCC-Transaction 有两个拦截器：</p><ul><li><code>org.mengyun.tcctransaction.interceptor.CompensableTransactionInterceptor</code>，可补偿事务拦截器。</li><li><code>org.mengyun.tcctransaction.interceptor.ResourceCoordinatorInterceptor</code>，资源协调者拦截器。</li></ul><p>在分享拦截器的实现之前，我们先一起看看 @Compensable 注解。</p><h2 id="4-1-Compensable"><a href="#4-1-Compensable" class="headerlink" title="4.1 Compensable"></a>4.1 Compensable</h2><p>@Compensable，标记可补偿的方法注解。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Compensable &#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 传播级别</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">Propagation <span class="title">propagation</span><span class="params">()</span> <span class="keyword">default</span> Propagation.REQUIRED</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 确认执行业务方法</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">String <span class="title">confirmMethod</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 取消执行业务方法</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">String <span class="title">cancelMethod</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 事务上下文编辑</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    Class&lt;? extends TransactionContextEditor&gt; transactionContextEditor() <span class="keyword">default</span> DefaultTransactionContextEditor.class;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>propagation，传播级别( Propagation )，默认 Propagation.REQUIRED。和 Spring 的 Propagation 除了缺少几个属性，基本一致。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Propagation &#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 支持当前事务，如果当前没有事务，就新建一个事务。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    REQUIRED(<span class="number">0</span>),</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 支持当前事务，如果当前没有事务，就以非事务方式执行。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    SUPPORTS(<span class="number">1</span>),</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 支持当前事务，如果当前没有事务，就抛出异常。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    MANDATORY(<span class="number">2</span>),</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 新建事务，如果当前存在事务，把当前事务挂起。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    REQUIRES_NEW(<span class="number">3</span>);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>confirmMethod，确认执行业务方法名。</p></li><li>cancelMethod，取消执行业务方法名。</li><li><p>TransactionContextEditor，事务上下文编辑器( TransactionContextEditor )，用于设置和获得事务上下文( TransactionContext )。<code>org.mengyun.tcctransaction.api.TransactionContextEditor</code> 接口代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionContextEditor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 从参数中获得事务上下文</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> target 对象</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> method 方法</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> args 参数</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 事务上下文</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">TransactionContext <span class="title">get</span><span class="params">(Object target, Method method, Object[] args)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 设置事务上下文到参数中</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> transactionContext 事务上下文</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> target 对象</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> method 方法</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> args 参数</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(TransactionContext transactionContext, Object target, Method method, Object[] args)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>DefaultTransactionContextEditor，<strong>默认</strong>事务上下文编辑器实现。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultTransactionContextEditor</span> <span class="keyword">implements</span> <span class="title">TransactionContextEditor</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> TransactionContext <span class="title">get</span><span class="params">(Object target, Method method, Object[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> position = getTransactionContextParamPosition(method.getParameterTypes());</div><div class="line">        <span class="keyword">if</span> (position &gt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> (TransactionContext) args[position];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(TransactionContext transactionContext, Object target, Method method, Object[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> position = getTransactionContextParamPosition(method.getParameterTypes());</div><div class="line">        <span class="keyword">if</span> (position &gt;= <span class="number">0</span>) &#123;</div><div class="line">            args[position] = transactionContext; <span class="comment">// 设置方法参数</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获得事务上下文在方法参数里的位置</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> parameterTypes 参数类型集合</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 位置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getTransactionContextParamPosition</span><span class="params">(Class&lt;?&gt;[] parameterTypes)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> position = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterTypes.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (parameterTypes[i].equals(org.mengyun.tcctransaction.api.TransactionContext.class)) &#123;</div><div class="line">                position = i;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> position;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>NullableTransactionContextEditor，无事务上下文编辑器实现。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NullableTransactionContextEditor</span> <span class="keyword">implements</span> <span class="title">TransactionContextEditor</span> </span>&#123;</div><div class="line">    </div><div class="line">     <span class="meta">@Override</span></div><div class="line">     <span class="function"><span class="keyword">public</span> TransactionContext <span class="title">get</span><span class="params">(Object target, Method method, Object[] args)</span> </span>&#123;</div><div class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">     &#125;</div><div class="line">    </div><div class="line">     <span class="meta">@Override</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(TransactionContext transactionContext, Object target, Method method, Object[] args)</span> </span>&#123;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></li></ul></li></ul><ul><li>DubboTransactionContextEditor，Dubbo 事务上下文编辑器实现，通过 Dubbo 隐式传参方式获得事务上下文，在<a href="http://www.iocoder.cn?todo">《TCC-Transaction 源码解析 —— Dubbo 支持》</a>详细解析。</li></ul></li></ul><h2 id="4-2-可补偿事务拦截器"><a href="#4-2-可补偿事务拦截器" class="headerlink" title="4.2 可补偿事务拦截器"></a>4.2 可补偿事务拦截器</h2><h2 id="4-3-资源协调者拦截器"><a href="#4-3-资源协调者拦截器" class="headerlink" title="4.3 资源协调者拦截器"></a>4.3 资源协调者拦截器</h2><h2 id="4-4"><a href="#4-4" class="headerlink" title="4.4"></a>4.4</h2><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h1&gt;&lt;p&gt;本文分享 &lt;strong&gt;TCC 实现&lt;/strong&gt;。主要涉及如下三个 Maven 项目：&lt;/p&gt;
&lt;ul&gt;
&lt;li
      
    
    </summary>
    
      <category term="TCC-Transaction" scheme="http://www.iocoder.cn/categories/TCC-Transaction/"/>
    
    
  </entry>
  
  <entry>
    <title>TCC-Transaction 源码分析 —— 调试环境搭建</title>
    <link href="http://www.iocoder.cn/TCC-Transaction/build-debugging-environment/"/>
    <id>http://www.iocoder.cn/TCC-Transaction/build-debugging-environment/</id>
    <published>2018-01-31T16:00:00.000Z</published>
    <updated>2017-09-09T05:41:29.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><ul><li><a href="#">1. 依赖工具</a></li><li><a href="#">2. 源码拉取</a></li><li><a href="#">3. 初始化数据库</a></li><li><a href="#">4. 启动 capital 项目</a></li><li><a href="#">5. 启动 redpacket 项目</a></li><li><a href="#">6. 启动 order 项目</a></li><li><a href="#">7. 交流</a></li></ul><h1 id="1-依赖工具"><a href="#1-依赖工具" class="headerlink" title="1. 依赖工具"></a>1. 依赖工具</h1><ul><li>Maven</li><li>Git</li><li>JDK</li><li>MySQL</li><li>IntelliJ IDEA</li></ul><h1 id="2-源码拉取"><a href="#2-源码拉取" class="headerlink" title="2. 源码拉取"></a>2. 源码拉取</h1><p>从官方仓库 <a href="https://github.com/changmingxie/tcc-transaction.git" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/changmingxie/tcc-transaction.git</a> <code>Fork</code> 出属于自己的仓库。为什么要 <code>Fork</code> ？既然开始阅读、调试源码，我们可能会写一些注释，有了自己的仓库，可以进行自由的提交。😈</p><p>使用 <code>IntelliJ IDEA</code> 从 <code>Fork</code> 出来的仓库拉取代码。拉取完成后，<code>Maven</code> 会下载依赖包，可能会花费一些时间，耐心等待下。</p><p>本文基于 <code>master-1.2.x</code> 分支。</p><h1 id="3-初始化数据库"><a href="#3-初始化数据库" class="headerlink" title="3. 初始化数据库"></a>3. 初始化数据库</h1><p>官方提供了两个 Demo 项目例子：</p><ul><li>tcc-transaction-dubbo-sample</li><li>tcc-transaction-http-sample</li></ul><p>考虑到不是所有所有同学都使用过 Dubbo 服务化框架，我们以 tcc-transaction-http-sample 项为例子。</p><p>打开 tcc-transaction-http-sample/src/main/dbscripts 目录，有四个 SQL 脚本文件：</p><ul><li><code>create_db_cap.sql</code> ：tcc-transaction-http-capital  项目数据库初始化脚本。</li><li><code>create_db_ord.sql</code> ：tcc-transaction-http-order 项目数据库初始化脚本。</li><li><code>create_db_red.sql</code> ：tcc-transaction-http-redpacket 项目数据库初始化脚本。</li><li><code>create_db_tcc.sql</code> ：tcc-transaction <strong>底层</strong>数据库初始化脚本。</li></ul><p>笔者使用 Navicat 进行数据库脚本执行。使用方式为：Navicat 菜单 Connection -&gt; Execute SQL File，选择脚本文件，逐个执行。</p><p>目前数据库脚本未使用 <code>USE</code> 语句选择对应数据库，每个脚本都需要进行添加。以 <code>create_db_cap.sql</code> 举例子：</p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="string">`tcc_cap`</span> <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8 */</span>;</div><div class="line"><span class="comment">-- 新增 USE</span></div><div class="line"><span class="keyword">USE</span> <span class="string">`tcc_cap`</span>;</div></pre></td></tr></table></figure><h1 id="4-启动-capital-项目"><a href="#4-启动-capital-项目" class="headerlink" title="4. 启动 capital 项目"></a>4. 启动 capital 项目</h1><ol><li>修改项目下 <code>jdbc.properties</code> 文件，<strong>填写成你的数据库地址</strong>。</li><li><p>使用 IDEA 配置 Tomcat 进行启动。这里要注意下：</p> <figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">// appcontext-service-provider.xml</div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"httpServer"</span></span></div><div class="line"><span class="tag">     <span class="attr">class</span>=<span class="string">"org.springframework.remoting.support.SimpleHttpServerFactoryBean"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"contexts"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">util:map</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"/remoting/CapitalTradeOrderService"</span> <span class="attr">value-ref</span>=<span class="string">"capitalTradeOrderServiceExporter"</span>/&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"/remoting/CapitalAccountService"</span> <span class="attr">value-ref</span>=<span class="string">"capitalAccountServiceExporter"</span>/&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">util:map</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"8081"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><ul><li>默认开启 8081 端口提供接口服务。所以配置 Tomcat 的端口不能再使用 8081，避免冲突。例如，笔者使用 18081。</li></ul></li><li><p>访问 <code>http://127.0.0.1:18081/</code>，看到 “hello tcc transacton http sample capital”，代表项目启动完成。<strong><code>18081</code> 为你填写的 Tomcat 端口</strong>。</p></li></ol><h1 id="5-启动-redpacket-项目"><a href="#5-启动-redpacket-项目" class="headerlink" title="5. 启动 redpacket 项目"></a>5. 启动 redpacket 项目</h1><p>同 tcc-transaction-http-capital 项目。</p><h1 id="6-启动-order-项目"><a href="#6-启动-order-项目" class="headerlink" title="6. 启动 order 项目"></a>6. 启动 order 项目</h1><ol><li>修改项目下 <code>jdbc.properties</code> 文件，<strong>填写成你的数据库地址</strong>。</li><li>使用 IDEA 配置 Tomcat 进行启动。</li><li>访问 <code>http://127.0.0.1:8080/</code>，看到 “sample 说明…”，代表项目启动完成。<strong><code>8080</code> 为你填写的 Tomcat 端口</strong>。</li><li>点击 [商品列表链接] -&gt; [购买] -&gt; [支付]，如果看到 “支付成功” 或者 “支付失败”，恭喜你🎉，你已经成功搭建完你的调试环境。愉快的开始玩耍把。</li></ol><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>调试环境搭建是阅读源码的第一步，如果你碰到无法搭建成功的情况，请给笔者公众号( <strong>芋道源码</strong> )留言。笔者会给你 1:1 的高级( <strong>搞基</strong> )支持。</p><p>另外这是一个系列文，本系列更新 TCC-Transaction ，下一个系列更新 ByteTCC 。嗨皮不？！</p><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_02_01/01.png" alt=""></p><p>道友，赶紧上车，分享一波朋友圈！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注&lt;strong&gt;微信公众号：【芋道源码】&lt;/strong&gt;
      
    
    </summary>
    
      <category term="TCC-Transaction" scheme="http://www.iocoder.cn/categories/TCC-Transaction/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Cloud 源码分析 —— 高可用</title>
    <link href="http://www.iocoder.cn/Elastic-Job/cloud-high-availability/"/>
    <id>http://www.iocoder.cn/Elastic-Job/cloud-high-availability/</id>
    <published>2018-01-14T16:00:00.000Z</published>
    <updated>2017-09-07T13:01:19.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p><ul><li><a href="#">1. 概述</a></li><li><a href="#">2. Scheduler 集群</a></li><li><a href="#">3. Scheduler 部署</a></li><li><a href="#">4. Scheduler 故障转移</a></li><li><a href="#">5. Scheduler 数据存储</a><ul><li><a href="#">5.1 RunningService</a></li><li><a href="#">5.2 ProducerManager</a></li><li><a href="#">5.3 TaskScheduler</a></li></ul></li><li><a href="#">6. Mesos Master 崩溃</a></li><li><a href="#">7. Mesos Slave 崩溃</a></li><li><a href="#">8. Scheduler 核对</a></li><li><a href="#">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Cloud 高可用</strong>。</p><p>一个高可用的 Elastic-Job-Cloud 组成如下图：</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2018_01_15/01.png" alt=""></p><ul><li>Mesos Master 集群</li><li>Mesos Slave 集群</li><li>Zookeeper 集群</li><li>Elastic-Job-Cloud-Scheduler 集群</li><li>Elastic-Job-Cloud-Executor 集群</li></ul><p><strong>本文重点分享 Elastic-Job-Cloud-Scheduler 如何实现高可用。</strong></p><p>Mesos Master / Mesos Slave / Zookeeper 高可用，同学们可以自行 Google 解决。Elastic-Job-Cloud-Executor 运行在 Mesos Slave 上，通过 Mesos Slave 集群多节点实现高可用。</p><blockquote><p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p></blockquote><h1 id="2-Scheduler-集群"><a href="#2-Scheduler-集群" class="headerlink" title="2. Scheduler 集群"></a>2. Scheduler 集群</h1><p>Elastic-Job-Cloud-Scheduler 通过至少两个节点实现集群。<strong>集群中通过主节点选举一个主节点，只有主节点提供服务，从实例处于”待命”状态。当主节点故障时，从节点会选举出新的主节点继续提供服务。</strong>实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Bootstrap</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="comment">// 初始化 注册中心</span></div><div class="line">        CoordinatorRegistryCenter regCenter = <span class="keyword">new</span> ZookeeperRegistryCenter(BootstrapEnvironment.getInstance().getZookeeperConfiguration());</div><div class="line">        regCenter.init();</div><div class="line">        <span class="comment">// 初始化 Zookeeper 选举服务</span></div><div class="line">        <span class="keyword">final</span> ZookeeperElectionService electionService = <span class="keyword">new</span> ZookeeperElectionService(</div><div class="line">                BootstrapEnvironment.getInstance().getFrameworkHostPort(), (CuratorFramework) regCenter.getRawClient(), HANode.ELECTION_NODE, <span class="keyword">new</span> SchedulerElectionCandidate(regCenter));</div><div class="line">        electionService.start();</div><div class="line">        <span class="comment">// 挂起 主进程</span></div><div class="line">        <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line">        latch.await();</div><div class="line">        <span class="comment">// Hook TODO 貌似位置不对？</span></div><div class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(<span class="string">"shutdown-hook"</span>) &#123;</div><div class="line">        </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                electionService.stop();</div><div class="line">                latch.countDown();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>Bootstrap，Elastic-Job-Cloud-Scheduler 启动器（仿佛在说废话）。</li><li>CoordinatorRegistryCenter，用于协调分布式服务的注册中心，在<a href="http://www.iocoder.cn/Elastic-Job/reg-center-zookeeper/?">《Elastic-Job-Lite 源码分析 —— 注册中心》</a>有详细解析。</li><li>ZookeeperElectionService，Zookeeper 选举服务，本小节的主角。</li></ul><p>调用 <code>ZookeeperElectionService#start()</code> 方法，初始化 Zookeeper 选举服务以实现 Elastic-Job-Cloud-Scheduler 主节点选举。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch leaderLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line">    </div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> LeaderSelector leaderSelector;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZookeeperElectionService</span><span class="params">(<span class="keyword">final</span> String identity, <span class="keyword">final</span> CuratorFramework client, <span class="keyword">final</span> String electionPath, <span class="keyword">final</span> ElectionCandidate electionCandidate)</span> </span>&#123;</div><div class="line">   <span class="comment">// 创建 LeaderSelector</span></div><div class="line">   leaderSelector = <span class="keyword">new</span> LeaderSelector(client, electionPath, <span class="keyword">new</span> LeaderSelectorListenerAdapter() &#123;</div><div class="line">       </div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeLeadership</span><span class="params">(<span class="keyword">final</span> CuratorFramework client)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">           <span class="comment">// ... 省略【暂时】无关代码</span></div><div class="line">       &#125;</div><div class="line">   &#125;);</div><div class="line">   <span class="comment">// 设置重复参与选举主节点</span></div><div class="line">   leaderSelector.autoRequeue();</div><div class="line">   <span class="comment">// 设置参与节点的编号</span></div><div class="line">   leaderSelector.setId(identity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 开始选举.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">   log.debug(<span class="string">"Elastic job: &#123;&#125; start to elect leadership"</span>, leaderSelector.getId());</div><div class="line">   leaderSelector.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>通过 <a href="https://curator.apache.org/apidocs/org/apache/curator/framework/recipes/leader/LeaderSelector.html" rel="external nofollow noopener noreferrer" target="_blank">Apache Curator LeaderSelector</a> 实现分布式多节点选举。</p><blockquote><p>FROM <a href="https://curator.apache.org/apidocs/org/apache/curator/framework/recipes/leader/LeaderSelector.html" rel="external nofollow noopener noreferrer" target="_blank">https://curator.apache.org/apidocs/org/apache/curator/framework/recipes/leader/LeaderSelector.html</a><br>Abstraction to select a “leader” amongst multiple contenders in a group of JMVs connected to a Zookeeper cluster. If a group of N thread/processes contends for leadership, one will be assigned leader until it releases leadership at which time another one from the group will be chosen.<br>Note that this class uses an underlying InterProcessMutex and as a result leader election is “fair” - each user will become leader in the order originally requested (from ZK’s point of view).</p></blockquote></li><li><p>调用 <code>LeaderSelector#autoRequeue()</code> 方法，设置重复参与选举主节点。默认情况下，自己选举成为主节点后，不再参与下次选举。设置重复参与选举主节点后，每次选举都会参与。在 Elastic-Job-Cloud-Scheduler 里，我们显然要重复参与选举。</p></li><li>调用 <code>LeaderSelector#setId()</code> 方法，设置参与节点的编号。在 Elastic-Job-Cloud-Scheduler 里暂时没有实际用途。编号算法为 <code>BootstrapEnvironment.getInstance().getFrameworkHostPort()</code>，即：<code>HOST:PORT</code>。</li><li>调用 <code>#start()</code> 方法，开始选举。<strong>当自己选举主节点成功</strong>，回调 <code>LeaderSelector#takeLeadership()</code> 方法。</li></ul><p>回调 <code>LeaderSelector#takeLeadership()</code> 方法，Elastic-Job-Cloud-Scheduler <strong>主节点开始领导状态</strong>。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ZookeeperElectionService.LeaderSelector 内部实现类</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeLeadership</span><span class="params">(<span class="keyword">final</span> CuratorFramework client)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    log.info(<span class="string">"Elastic job: &#123;&#125; has leadership"</span>, identity);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 开始领导状态</span></div><div class="line">        electionCandidate.startLeadership();</div><div class="line">        <span class="comment">// 挂起 进程</span></div><div class="line">        leaderLatch.await();</div><div class="line">        log.warn(<span class="string">"Elastic job: &#123;&#125; lost leadership."</span>, identity);</div><div class="line">        <span class="comment">// 终止领导状态</span></div><div class="line">        electionCandidate.stopLeadership();</div><div class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> JobSystemException exception) &#123;</div><div class="line">        <span class="comment">// 异常退出</span></div><div class="line">        log.error(<span class="string">"Elastic job: Starting error"</span>, exception);</div><div class="line">        System.exit(<span class="number">1</span>);  </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>SchedulerElectionCandidate#startLeadership()</code> 方法，开始领导状态。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SchedulerElectionCandidate.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulerElectionCandidate</span> <span class="keyword">implements</span> <span class="title">ElectionCandidate</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CoordinatorRegistryCenter regCenter;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> SchedulerService schedulerService;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SchedulerElectionCandidate</span><span class="params">(<span class="keyword">final</span> CoordinatorRegistryCenter regCenter)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.regCenter = regCenter;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startLeadership</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            schedulerService = <span class="keyword">new</span> SchedulerService(regCenter);</div><div class="line">            schedulerService.start();</div><div class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable throwable) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(throwable);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// SchedulerService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 以守护进程方式启动.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">   facadeService.start();</div><div class="line">   producerManager.startup();</div><div class="line">   statisticManager.startup();</div><div class="line">   cloudJobConfigurationListener.start();</div><div class="line">   taskLaunchScheduledService.startAsync();</div><div class="line">   restfulService.start();</div><div class="line">   schedulerDriver.start();</div><div class="line">   <span class="keyword">if</span> (env.getFrameworkConfiguration().isEnabledReconcile()) &#123;</div><div class="line">       reconcileService.startAsync();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>当 Elastic-Job-Cloud-Scheduler <strong>主节点</strong>调用 <code>SchedulerService#start()</code> 方法后，各种服务初始化完成，特别是和 Mesos Master 的连接，可以愉快的进行作业调度等等服务。</li><li>Elastic-Job-Cloud-Scheduler <strong>从节点</strong>，因为无法回调 <code>LeaderSelector#takeLeadership()</code> 方法，处于”待命”状态。当主节点故障时，从节点会选举出新的主节点，触发 <code>LeaderSelector#takeLeadership()</code> 方法回调，继续提供服务。</li></ul></li><li><p>调用 <code>CountLatch#await()</code> 方法，挂起<strong>主节点</strong> <code>LeaderSelector#takeLeadership()</code> 方法继续向下执行。为什么要进行挂起？如果调用完该方法，<strong>主节点</strong>就会让出<strong>主节点</strong>身份，这样会导致 Elastic-Job-Cloud-Scheduler 集群不断不断不断更新主节点，无法正常提供服务。</p></li><li><p>当 Elastic-Job-Cloud-Scheduler <strong>主节点</strong>关闭时，触发上文代码看到的 ShutdownHook ，关闭服务。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Bootstrap.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Bootstrap</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="comment">// ... 省略无关代码</span></div><div class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(<span class="string">"shutdown-hook"</span>) &#123;</div><div class="line">        </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="comment">// 停止选举</span></div><div class="line">                electionService.stop();</div><div class="line">                latch.countDown();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>ElectionService#stop()</code> 方法，停止选举，从而终止领导状态，关闭各种服务。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ZookeeperElectionService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</div><div class="line">    log.info(<span class="string">"Elastic job: stop leadership election"</span>);</div><div class="line">    <span class="comment">// 结束 #takeLeadership() 方法的进程挂起</span></div><div class="line">    leaderLatch.countDown();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 关闭 LeaderSelector</span></div><div class="line">        leaderSelector.close();</div><div class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ignored) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// SchedulerElectionCandidate.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopLeadership</span><span class="params">()</span> </span>&#123;</div><div class="line">    schedulerService.stop();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// SchedulerService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 停止运行.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</div><div class="line">    restfulService.stop();</div><div class="line">    taskLaunchScheduledService.stopAsync();</div><div class="line">    cloudJobConfigurationListener.stop();</div><div class="line">    statisticManager.shutdown();</div><div class="line">    producerManager.shutdown();</div><div class="line">    schedulerDriver.stop(<span class="keyword">true</span>);</div><div class="line">    facadeService.stop();</div><div class="line">    <span class="keyword">if</span> (env.getFrameworkConfiguration().isEnabledReconcile()) &#123;</div><div class="line">        reconcileService.stopAsync();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul></li><li><p>当发生 JobSystemException 异常时，即调用 <code>SchedulerElectionCandidate#startLeadership()</code> 方法发生异常( <code>SchedulerElectionCandidate#stopLeadership()</code> 实际不会抛出异常 )，调用 <code>System.exit(1)</code> 方法，Elastic-Job-Cloud-Scheduler 主节点<strong>异常崩溃</strong>。</p><ul><li>目前猜测<strong>可能</strong>有种情况会导致异常崩溃。（1）一个 Elastic-Job-Cloud-Scheduler 集群有两个节点 A / B，通过选举 A 成为主节点；（2）突然 Zookeeper 集群崩溃，恢复后，A 节点选举<strong>恰好</strong>又成为主节点，因为未调用 <code>SchedulerElectionCandidate#stopLeadership()</code> 关闭原来的各种服务，导致<strong>再次</strong>调用 <code>SchedulerElectionCandidate#startLeadership()</code> 会发生异常，例如说 RestfulService 服务，需要占用一个端口提供服务，重新初始化，会发生端口冲突抛出异常。笔者尝试模拟，通过一个 Elastic-Job-Cloud-Scheduler + Zookeeper 的情况，能够触发该情况，步骤如下：（1）Zookeeper 启动；（2）Elastic-Job-Cloud-Scheduler 启动，选举成为主节点，正常初始化；（3）重启 Zookeeper；（4）Elastic-Job-Cloud-Scheduler 再次选举成为主节点，因为 RestfulService 端口冲突异常初始化崩溃。<strong>如果真出现这种情况怎么办呢？</strong>在「3. Scheduler 部署」揭晓答案。</li></ul></li></ul><p>Elastic-Job-Lite 在主节点选举实现方式上略有不同，有兴趣的同学可以看下<a href="http://www.iocoder.cn/Elastic-Job/election/?self">《Elastic-Job-Lite 源码分析 —— 主节点选举》</a>的实现。</p><h1 id="3-Scheduler-部署"><a href="#3-Scheduler-部署" class="headerlink" title="3. Scheduler 部署"></a>3. Scheduler 部署</h1><p>比较容易想到的一种方式，选择多台主机部署 Elastic-Job-Cloud-Executor 多个节点。</p><p>But…… 我们要想下，Elastic-Job-Cloud-Executor 运行在 Mesos 之上，可以使用上 Mesos 的资源调度和部署服务。引入 Mesos 上著名的框架 <a href="https://mesosphere.github.io/marathon/" rel="external nofollow noopener noreferrer" target="_blank">Marathon</a>。它可以带来<strong>所有后台进程( 例如，Elastic-Job-Cloud-Executor )能够运行在任意机器上，Marathon 会在后台已有实例失败时，自动启动新实例</strong>的好处。是不是很赞 +1024 ？！</p><blockquote><p>FROM <a href="http://product.dangdang.com/24187450.html" rel="external nofollow noopener noreferrer" target="_blank">《Mesos 框架构建分布式应用》</a> P47<br>Mesos 集群里的常见方案是在 Marathon 上运行集群的 Mesos 框架。但是 Marathon 本身就是一种 Mesos 的框架！那么在 Marathon 上运行 Mesos 框架意味着什么呢？不用考虑如何将每种框架的调度器部署到特定的主机上并且处理这些主机的故障，Marathon 能够确保框架的调度器总是在集群里的某处运行着。这样大幅简化了在高可用配置里部署新框架的复杂度。</p></blockquote><p>嗯…… 当然，Marathon 我们也要做高可用。</p><p>😈 Marathon 原来中文是马拉松。哈哈哈，很适合的名字。</p><h1 id="4-Scheduler-故障转移"><a href="#4-Scheduler-故障转移" class="headerlink" title="4. Scheduler 故障转移"></a>4. Scheduler 故障转移</h1><p>当原有 Elastic-Job-Cloud-Scheduler <strong>主节点</strong>崩溃时，<strong>从节点</strong>重新进行主节点选举，完成故障转移。那么此时会有一个问题，新<strong>主节点</strong>如何接管已经在执行中的 Elastic-Job-Cloud-Executer 们呢？</p><p>第一种方案，关闭原有的所有 Elastic-Job-Cloud-Executor 们，然后重新调度启动。显然，这个方式太过暴力。如果有些作业任务运行时间较长，直接中断不是很友好。再比如，Elastic-Job-Cloud-Scheduler 节点需要进行升级，也关闭 Elastic-Job-Cloud-Executor，也不合理，和使用高可用性集群操作系统的初衷是背离的。<strong>该方案，不推荐</strong>。</p><p>第二种方案，重用<strong>原主节点</strong>的 Mesos <strong>FrameworkID</strong>。原理如下：</p><blockquote><p>FROM <a href="http://product.dangdang.com/24187450.html" rel="external nofollow noopener noreferrer" target="_blank">《Mesos 框架构建分布式应用》</a> P72<br>在 Mesos 里，调度器由其 FrameworkID、FrameworkInfo 里的可选值唯一确定。FrameworkID 必须由 Mesos 分配，从而确保对于每个框架来说该值是唯一确定的。现在，需要在分配 FrameworkID 时存储该值，这样未来的主实例才可以重用该值。   </p></blockquote><p>在 Elastic-Job-Cloud-Scheduler 使用注册中心( Zookeeper ) 的<strong>持久</strong>数据节点 <code>/${NAMESPACE}/ha/framework_id</code> 存储 FrameworkID，存储值为 <code>${FRAMEWORK_ID}</code>。使用 zkClient 查看如下：</p><blockquote><p>[zk: localhost:2181(CONNECTED) 1] get /elastic-job-cloud/ha/framework_id<br>d31e7faa-aa72-4d0a-8941-512984d5af49-0001</p></blockquote><p>调用 <code>SchedulerService#getSchedulerDriver()</code> 方法，初始化 Mesos Scheduler Driver 时，从 Zookeeper 获取是否已经存在 FrameworkID。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SchedulerService.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> SchedulerDriver <span class="title">getSchedulerDriver</span><span class="params">(<span class="keyword">final</span> TaskScheduler taskScheduler, <span class="keyword">final</span> JobEventBus jobEventBus, <span class="keyword">final</span> FrameworkIDService frameworkIDService)</span> </span>&#123;</div><div class="line">   <span class="comment">// 获取 FrameworkID</span></div><div class="line">   Optional&lt;String&gt; frameworkIDOptional = frameworkIDService.fetch();</div><div class="line">   Protos.FrameworkInfo.Builder builder = Protos.FrameworkInfo.newBuilder();</div><div class="line">   <span class="comment">// 如果存在，设置 FrameworkID</span></div><div class="line">   <span class="keyword">if</span> (frameworkIDOptional.isPresent()) &#123;</div><div class="line">       builder.setId(Protos.FrameworkID.newBuilder().setValue(frameworkIDOptional.get()).build());</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// ... 省略无关代码</span></div><div class="line">   Protos.FrameworkInfo frameworkInfo = builder.setUser(mesosConfig.getUser()).setName(frameworkName)</div><div class="line">                .setHostname(mesosConfig.getHostname())</div><div class="line">                .setFailoverTimeout(FRAMEWORK_FAILOVER_TIMEOUT_SECONDS)</div><div class="line">                .setWebuiUrl(WEB_UI_PROTOCOL + env.getFrameworkHostPort()).setCheckpoint(<span class="keyword">true</span>).build();</div><div class="line">   <span class="comment">// ... 省略无关代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>FrameworkIDService#fetch()</code> 方法，从注册中心获取 FrameworkID 。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Optional&lt;String&gt; <span class="title">fetch</span><span class="params">()</span> </span>&#123;</div><div class="line">   String frameworkId = regCenter.getDirectly(HANode.FRAMEWORK_ID_NODE);</div><div class="line">   <span class="keyword">return</span> Strings.isNullOrEmpty(frameworkId) ? Optional.&lt;String&gt;absent() : Optional.of(frameworkId);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用 <code>Protos.FrameworkInfo.Builder#setId(...)</code> 方法，当 FrameworkID 存在时，设置 FrameworkID。</p></li><li>调用 <code>Protos.FrameworkInfo.Builder#setFailoverTimeout(...)</code> 方法，设置 Scheduler 最大故障转移时间，即 FrameworkID 过期时间。Elastic-Job-Cloud-Scheduler 默认设置一周。</li></ul><p>当 Elastic-Job-Cloud-Scheduler 集群第一次初始化，上面的逻辑显然获取不到 FrameworkID，在向 Mesos Master 初始化成功后，回调 <code>SchedulerEngine#registered(...)</code> 方法进行保存，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SchedulerEngine.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulerEngine</span> <span class="keyword">implements</span> <span class="title">Scheduler</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registered</span><span class="params">(<span class="keyword">final</span> SchedulerDriver schedulerDriver, <span class="keyword">final</span> Protos.FrameworkID frameworkID, <span class="keyword">final</span> Protos.MasterInfo masterInfo)</span> </span>&#123;</div><div class="line">        log.info(<span class="string">"call registered"</span>);</div><div class="line">        <span class="comment">// 保存FrameworkID</span></div><div class="line">        frameworkIDService.save(frameworkID.getValue());</div><div class="line">        <span class="comment">// 过期 TaskScheduler Lease</span></div><div class="line">        taskScheduler.expireAllLeases();</div><div class="line">        <span class="comment">// 注册 Mesos Master 信息</span></div><div class="line">        MesosStateService.register(masterInfo.getHostname(), masterInfo.getPort());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// FrameworkIDService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">final</span> String id)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (!regCenter.isExisted(HANode.FRAMEWORK_ID_NODE)) &#123; <span class="comment">// 不存在才保存</span></div><div class="line">       regCenter.persist(HANode.FRAMEWORK_ID_NODE, id);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="5-Scheduler-数据存储"><a href="#5-Scheduler-数据存储" class="headerlink" title="5. Scheduler 数据存储"></a>5. Scheduler 数据存储</h1><p>新的 Elastic-Job-Cloud-Scheduler <strong>主节点</strong>在故障转移，不仅仅接管 Elastic-Job-Cloud-Executor，<strong>还需要接管数据存储</strong>。</p><p>Elastic-Job-Cloud-Executor 使用注册中心( Zookeeper )存储数据。数据存储分成两部分：</p><ul><li>config，云作业应用配置、云作业配置。</li><li>state，作业状态信息。</li></ul><p>整体如下图：</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2018_01_15/02.png" alt=""></p><p>Elastic-Job-Cloud-Scheduler <strong>各个服务</strong>根据数据存储启动初始化。下面来看看依赖数据存储进行初始化的服务代码实现。</p><h2 id="5-1-RunningService"><a href="#5-1-RunningService" class="headerlink" title="5.1 RunningService"></a>5.1 RunningService</h2><p>RunningService，任务运行时服务。调用 <code>RunningService#start()</code> 方法，启动任务运行队列。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunningService</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 运行中作业映射</span></div><div class="line"><span class="comment">     * key：作业名称</span></div><div class="line"><span class="comment">     * value：任务运行时上下文集合</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Set&lt;TaskContext&gt;&gt; RUNNING_TASKS = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(TASK_INITIAL_SIZE);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">        clear();</div><div class="line">        List&lt;String&gt; jobKeys = regCenter.getChildrenKeys(RunningNode.ROOT);</div><div class="line">        <span class="keyword">for</span> (String each : jobKeys) &#123;</div><div class="line">            <span class="comment">// 从运行中队列移除不存在配置的作业任务</span></div><div class="line">            <span class="keyword">if</span> (!configurationService.load(each).isPresent()) &#123;</div><div class="line">                remove(each);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 添加 运行中作业映射</span></div><div class="line">            RUNNING_TASKS.put(each, Sets.newCopyOnWriteArraySet(Lists.transform(regCenter.getChildrenKeys(RunningNode.getRunningJobNodePath(each)), <span class="keyword">new</span> Function&lt;String, TaskContext&gt;() &#123;</div><div class="line">                </div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> TaskContext <span class="title">apply</span><span class="params">(<span class="keyword">final</span> String input)</span> </span>&#123;</div><div class="line">                    <span class="keyword">return</span> TaskContext.from(regCenter.get(RunningNode.getRunningTaskNodePath(TaskContext.MetaInfo.from(input).toString())));</div><div class="line">                &#125;</div><div class="line">            &#125;)));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>因为运行中作业映射( <code>RUNNING_TASKS</code> )使用的频次很多，Elastic-Job-Cloud-Scheduler 缓存在内存中。每次初始化时，使用从数据存储<strong>运行中作业队列</strong>加载到内存。</li><li><p>这里我们在看下<strong>运行中作业队列</strong>的添加( <code>#add()</code> )方法，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">final</span> TaskContext taskContext)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (!configurationService.load(taskContext.getMetaInfo().getJobName()).isPresent()) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 添加到运行中的任务集合</span></div><div class="line">   getRunningTasks(taskContext.getMetaInfo().getJobName()).add(taskContext);</div><div class="line">   <span class="comment">// 判断是否为常驻任务</span></div><div class="line">   <span class="keyword">if</span> (!isDaemon(taskContext.getMetaInfo().getJobName())) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 添加到运行中队列</span></div><div class="line">   String runningTaskNodePath = RunningNode.getRunningTaskNodePath(taskContext.getMetaInfo().toString());</div><div class="line">   <span class="keyword">if</span> (!regCenter.isExisted(runningTaskNodePath)) &#123;</div><div class="line">       regCenter.persist(runningTaskNodePath, taskContext.getId());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>运行中作业队列只存储常驻作业的任务</strong>。所以<strong>瞬时</strong>作业，在故障转移时，可能存在相同作业相同分片任务<strong>同时</strong>调度执行。举个栗子🌰，Elastic-Job-Cloud-Scheduler 集群有两个节点 A( 主节点 ) / B( 从节点 )，（1）A 节点每 5 分钟调度一次瞬时作业任务 T ，T 每次执行消耗时间实际超过 5 分钟( 先不要考虑是否合理 )。（2）A 节点崩溃，B 节点成为主节点，5 分钟后调度 T 作业，因为<strong>运行中作业队列只存储常驻作业的任务</strong>，恢复后的 <code>RUNNING_TASKS</code> 不存在该作业任务，因此可以调度 T 作业，实际 T 作业正在 Elastic-Job-Cloud-Executor 执行中。</li></ul></li></ul><h2 id="5-2-ProducerManager"><a href="#5-2-ProducerManager" class="headerlink" title="5.2 ProducerManager"></a>5.2 ProducerManager</h2><p>ProducerManager，发布任务作业调度管理器。调用 <code>ProducerManager#startup()</code> 方法，启动作业调度器。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerManager</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startup</span><span class="params">()</span> </span>&#123;</div><div class="line">        log.info(<span class="string">"Start producer manager"</span>);</div><div class="line">        <span class="comment">// 发布瞬时作业任务的调度器</span></div><div class="line">        transientProducerScheduler.start();</div><div class="line">        <span class="comment">// 初始化调度作业</span></div><div class="line">        <span class="keyword">for</span> (CloudJobConfiguration each : configService.loadAll()) &#123;</div><div class="line">            schedule(each);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>ConfigService#loadAll()</code> 方法，从<strong>数据存储</strong>读取所有作业配置。</li><li>调用 <code>#schedule()</code> 方法，初始化调度作业。<ul><li><strong>瞬时</strong>作业，在 Elastic-Job-Cloud-Scheduler 计时调度，类似每 XX 秒 / 分 / 时 / 天之类的作业需要重新计时，这个请注意。</li><li><strong>常驻</strong>作业，在 Elastic-Job-Cloud-Executor 计时调度，暂无影响。</li><li>在<a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/?self">《Elastic-Job-Cloud 源码分析 —— 作业调度（一）》「3. Producer 发布任务」</a>有详细解析。</li></ul></li></ul><h2 id="5-3-TaskScheduler"><a href="#5-3-TaskScheduler" class="headerlink" title="5.3 TaskScheduler"></a>5.3 TaskScheduler</h2><p>TaskScheduler，Fenzo 作业调度器，根据 Mesos Offer 和作业任务的优化分配。因为其分配是依赖当前实际 Mesos Offer 和 作业任务运行的情况，猜测<strong>可能</strong>对优化分配有影响，但不影响正确性。笔者对 TaskScheduler 了解不是很深入，仅仅作为猜测。</p><p>在<a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/?self">《Elastic-Job-Cloud 源码分析 —— 作业调度（一）》「4.1」「4.2」「4.3」</a>有和 TaskScheduler 相关的内容解析。</p><h1 id="6-Mesos-Master-崩溃"><a href="#6-Mesos-Master-崩溃" class="headerlink" title="6. Mesos Master 崩溃"></a>6. Mesos Master 崩溃</h1><p>Mesos Master 集群，Mesos Master 主节点崩溃后，Mesos Master 集群重新选举后，Scheduler、Mesos Slave <strong>从 Zookeeper 获取到最新的 Mesos Master 主节点重新进行注册</strong>，不影响 Scheduler 、Mesos Slave 、任务执行。</p><p>调用 <code>SchedulerService#getSchedulerDriver(...)</code> 方法，设置 SchedulerDriver 从 Mesos Zookeeper Address 读取当前 Mesos Master 地址，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SchedulerService.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> SchedulerDriver <span class="title">getSchedulerDriver</span><span class="params">(<span class="keyword">final</span> TaskScheduler taskScheduler, <span class="keyword">final</span> JobEventBus jobEventBus, <span class="keyword">final</span> FrameworkIDService frameworkIDService)</span> </span>&#123;</div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line">    MesosConfiguration mesosConfig = env.getMesosConfiguration();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MesosSchedulerDriver(<span class="keyword">new</span> SchedulerEngine(taskScheduler, facadeService, jobEventBus, frameworkIDService, statisticManager), frameworkInfo, mesosConfig.getUrl() <span class="comment">// Mesos Master URL</span></div><div class="line">    );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// MesosSchedulerDriver.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MesosSchedulerDriver</span><span class="params">(Scheduler scheduler,</span></span></div><div class="line"><span class="function"><span class="params">                            FrameworkInfo framework,</span></span></div><div class="line"><span class="function"><span class="params">                            String master)</span> </span>&#123;</div><div class="line">    <span class="comment">// ... 省略无关代码     </span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>MesosSchedulerDriver 构造方法第三个参数 <code>master</code>，代表 Mesos 使用的 Zookeeper 地址，例如：<code>zk://127.0.0.1:2181/mesos</code>。生产环境请配置多 Zookeeper 节点，例如：<code>zk://host1:port1,host2:port2,.../path</code>。</li><li><p>使用 zkClient 查看如下：</p>  <figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 10] ls /mesos</div><div class="line">[log_replicas, json.info_0000000017]</div><div class="line">[zk: localhost:2181(CONNECTED) 11] get /mesos/json.info_0000000017</div><div class="line">&#123;"address":&#123;"hostname":"localhost","ip":"127.0.0.1","port":5050&#125;,"hostname":"localhost","id":"685fe32d-e30c-4df7-b891-3d96b06fee88","ip":16777343,"pid":"master@127.0.0.1:5050","port":5050,"version":"1.4.0"&#125;</div></pre></td></tr></table></figure></li></ul><p>Elastic-Job-Cloud-Scheduler 注册上、重新注册上、断开 Mesos Master 实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulerEngine</span> <span class="keyword">implements</span> <span class="title">Scheduler</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registered</span><span class="params">(<span class="keyword">final</span> SchedulerDriver schedulerDriver, <span class="keyword">final</span> Protos.FrameworkID frameworkID, <span class="keyword">final</span> Protos.MasterInfo masterInfo)</span> </span>&#123;</div><div class="line">        log.info(<span class="string">"call registered"</span>);</div><div class="line">        <span class="comment">// ... 省略无关代码</span></div><div class="line">        <span class="comment">// 注册 Mesos Master 信息</span></div><div class="line">        MesosStateService.register(masterInfo.getHostname(), masterInfo.getPort());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reregistered</span><span class="params">(<span class="keyword">final</span> SchedulerDriver schedulerDriver, <span class="keyword">final</span> Protos.MasterInfo masterInfo)</span> </span>&#123;</div><div class="line">        <span class="comment">// ... 省略无关代码</span></div><div class="line">        <span class="comment">// 注册 Mesos Master 信息</span></div><div class="line">        MesosStateService.register(masterInfo.getHostname(), masterInfo.getPort());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnected</span><span class="params">(<span class="keyword">final</span> SchedulerDriver schedulerDriver)</span> </span>&#123;</div><div class="line">        log.warn(<span class="string">"call disconnected"</span>);</div><div class="line">        MesosStateService.deregister();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>MesosStateService，Mesos状态服务，提供调用 Mesos Master API 服务，例如获取所有执行器。</li><li><p>调用 <code>MesosStateService#register(...)</code> 方法，注册 Mesos Master 信息，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MesosStateService</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String stateUrl;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> String hostName, <span class="keyword">final</span> <span class="keyword">int</span> port)</span> </span>&#123;</div><div class="line">        stateUrl = String.format(<span class="string">"http://%s:%d/state"</span>, hostName, port);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用 <code>MesosStateService#deregister(...)</code> 方法，注销 Mesos Master 信息，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deregister</span><span class="params">()</span> </span>&#123;</div><div class="line">    stateUrl = <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p><a href="http://product.dangdang.com/24187450.html" rel="external nofollow noopener noreferrer" target="_blank">《Mesos 框架构建分布式应用》P110 如何处理 master 的故障</a>，有兴趣的同学也可以<strong>仔细</strong>看看。</p><h1 id="7-Mesos-Slave-崩溃"><a href="#7-Mesos-Slave-崩溃" class="headerlink" title="7. Mesos Slave 崩溃"></a>7. Mesos Slave 崩溃</h1><p>在<a href="http://www.iocoder.cn/Elastic-Job/cloud-job-failover/?self">《Elastic-Job-Cloud 源码分析 —— 作业失效转移》</a>中，搜索关键字 <strong>“TASK_LOST”</strong>，有 Mesos Slave 崩溃后，对 Elastic-Job-Cloud-Scheduler 和 Elastic-Job-Cloud-Executor 的影响。</p><p><a href="http://product.dangdang.com/24187450.html" rel="external nofollow noopener noreferrer" target="_blank">《Mesos 框架构建分布式应用》P109 如何处理 slave 的故障</a>，有兴趣的同学也可以<strong>仔细</strong>看看。</p><h1 id="8-Scheduler-核对"><a href="#8-Scheduler-核对" class="headerlink" title="8. Scheduler 核对"></a>8. Scheduler 核对</h1><blockquote><p>FROM <a href="http://mesos.apache.org/documentation/latest/reconciliation/" rel="external nofollow noopener noreferrer" target="_blank">http://mesos.apache.org/documentation/latest/reconciliation/</a><br>Messages between framework schedulers and the Mesos master may be dropped due to failures and network partitions. This may cause a framework scheduler and the master to have <strong>different views of the current state of the cluster</strong>. For example, consider a launch task request sent by a framework. There are many ways that failures can prevent the task launch operation from succeeding, such as:</p><ul><li>Framework fails after persisting its intent to launch the task, but before the launch task message was sent.  </li><li>Master fails before receiving the message.  </li><li>Master fails after receiving the message but before sending it to the agent.  </li></ul></blockquote><p>通过<strong>核对</strong>特性解决这个问题。核对是协调器如何和 Mesos Master 一起检查调度器所认为的集群状态是否和 Mesos Master 所认为的集群状态完成匹配。</p><p>调用 <code>SchedulerDriver#reconcileTasks(...)</code> 方法，查询任务状态。代码接口如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SchedulerDriver</span> </span>&#123;</div><div class="line">    <span class="function">Status <span class="title">reconcileTasks</span><span class="params">(Collection&lt;TaskStatus&gt; statuses)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>只能</strong>查询<strong>非终止状态( non-terminal )</strong>的任务。核对的主要原因，确认任务是否还在运行，或者已经进入了中断状态。<ul><li>terminal：TASK_ERROR、TASK_FAILED、TASK_FINISHED、TASK_KILLED</li><li>non-terminal：TASK_DROPPED、TASK_GONE、TASK_GONE_BY_OPERATOR、TASK_KILLING、TASK_LOST、TASK_RUNNING、TASK_STAGING、TASK_STARTING、TASK_UNREACHABLE、TASK_UNKNOWN</li></ul></li><li>当 <code>statuses</code> 非空时，<strong>显示</strong>查询，通过回调 <code>Scheduler#statusUpdate(...)</code> 方法异步返回<strong>指定</strong>的任务的状态。</li><li>当 <code>statuses</code> 为空时，<strong>隐式</strong>查询，通过回调 <code>Scheduler#statusUpdate(...)</code> 方法异步返回<strong>全部</strong>的任务的状态。</li></ul><p>ReconcileService，核对 Mesos 与 Scheduler 之间的任务状态。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReconcileService</span> <span class="keyword">extends</span> <span class="title">AbstractScheduledService</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">runOneIteration</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            explicitReconcile();</div><div class="line">            implicitReconcile();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Scheduler <span class="title">scheduler</span><span class="params">()</span> </span>&#123;</div><div class="line">        FrameworkConfiguration configuration = BootstrapEnvironment.getInstance().getFrameworkConfiguration();</div><div class="line">        <span class="keyword">return</span> Scheduler.newFixedDelaySchedule(configuration.getReconcileIntervalMinutes(), configuration.getReconcileIntervalMinutes(), TimeUnit.MINUTES);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>通过配置 <code>FrameworkConfiguration#reconcileIntervalMinutes</code> 设置，每隔多少分钟执行一次核对。若配置时间大于 0 才开启任务状态核对功能。</li><li><p>调用 <code>#explicitReconcile()</code> 方法，查询运行中的任务。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">explicitReconcile</span><span class="params">()</span> </span>&#123;</div><div class="line">   lock.lock();</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 获取运行中的作业任务上下文集合</span></div><div class="line">       Set&lt;TaskContext&gt; runningTask = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">       <span class="keyword">for</span> (Set&lt;TaskContext&gt; each : facadeService.getAllRunningTasks().values()) &#123;</div><div class="line">           runningTask.addAll(each);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (runningTask.isEmpty()) &#123;</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line">       log.info(<span class="string">"Requesting &#123;&#125; tasks reconciliation with the Mesos master"</span>, runningTask.size());</div><div class="line">       <span class="comment">// 查询指定任务</span></div><div class="line">       schedulerDriver.reconcileTasks(Collections2.transform(runningTask, <span class="keyword">new</span> Function&lt;TaskContext, Protos.TaskStatus&gt;() &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="keyword">public</span> Protos.<span class="function">TaskStatus <span class="title">apply</span><span class="params">(<span class="keyword">final</span> TaskContext input)</span> </span>&#123;</div><div class="line">               <span class="keyword">return</span> Protos.TaskStatus.newBuilder()</div><div class="line">                       .setTaskId(Protos.TaskID.newBuilder().setValue(input.getId()).build())</div><div class="line">                       .setSlaveId(Protos.SlaveID.newBuilder().setValue(input.getSlaveId()).build())</div><div class="line">                       .setState(Protos.TaskState.TASK_RUNNING)</div><div class="line">                       .build();</div><div class="line">           &#125;</div><div class="line">       &#125;));</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       lock.unlock();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用 <code>#implicitReconcile()</code> 方法，查询所有任务。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">implicitReconcile</span><span class="params">()</span> </span>&#123;</div><div class="line">   lock.lock();</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 查询全部任务</span></div><div class="line">       schedulerDriver.reconcileTasks(Collections.&lt;Protos.TaskStatus&gt;emptyList());</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       lock.unlock();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>为什么这里要使用 ReentrantLock 锁呢？Elastic-Job-Cloud-Scheduler 提供 CloudOperationRestfulApi，支持使用 HTTP Restful API 主动触发 <code>#explicitReconcile()</code> 和 <code>#implicitReconcile()</code> 方法，<strong>通过锁避免并发核对</strong>。对 CloudOperationRestfulApi 有兴趣的同学，直接点击<a href="https://github.com/dangdangdotcom/elastic-job/blob/a52d4062bf1f1d729fa4dbf2d1225e0d97778cb9/elastic-job-cloud/elastic-job-cloud-scheduler/src/main/java/com/dangdang/ddframe/job/cloud/scheduler/restful/CloudOperationRestfulApi.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a>查看实现。</p></li></ul><p>TODO：为啥要先显再隐呢？</p><p>TODO：This reconciliation algorithm must be run after each (re-)registration.</p><p>其他 Scheduler 核对资料，有兴趣的同学可以看看：</p><ul><li><a href="http://product.dangdang.com/24187450.html" rel="external nofollow noopener noreferrer" target="_blank">《Mesos 框架构建分布式应用》P76 添加核对 、P111 故障转移期间的核对</a></li><li><a href="http://mesos.apache.org/documentation/latest/reconciliation/" rel="external nofollow noopener noreferrer" target="_blank">《Mesos 官方文档 —— reconciliation》</a></li></ul><p>Elastic-Job-Lite 也会存在作业节点 和 Zookeeper 数据不一致的情况，有兴趣的同学可以看下<a href="http://www.iocoder.cn/Elastic-Job/reconcile/?self">《Elastic-Job-Lite 源码分析 —— 自诊断修复》</a>的实现。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>给英文和我一样半斤八两的同学一本葵花宝典+辟邪剑谱：</p><ul><li><a href="https://mesos-cn.gitbooks.io/mesos-cn/content/" rel="external nofollow noopener noreferrer" target="_blank">《Mesos中文手册》</a>。</li><li><a href="http://www.jianshu.com/p/726e28ea488a" rel="external nofollow noopener noreferrer" target="_blank">《Mesos 容错、故障》</a></li></ul><p><img src="http://www.iocoder.cn/images/Elastic-Job/2018_01_15/03.png" alt=""></p><p>整个 Elastic-Job-Cloud 完结，撒花！</p><p>收获蛮多的，学习的第一套基于云原生( CloudNative )实现的中间件，期待有基于云原生的服务化中间件。</p><p>一开始因为 Elastic-Job-Cloud 基于 Mesos 实现，内心还是有点恐惧感，后面硬啃 + 搭配<a href="http://product.dangdang.com/24187450.html" rel="external nofollow noopener noreferrer" target="_blank">《Mesos 框架构建分布式应用》</a>，比预想的时间快了一半完成这个系列。在这里强烈推荐这本书。另外，等时间相对空，会研究下另外一个沪江开源的基于 Mesos 实现的分布式调度系统 <a href="https://github.com/HujiangTechnology/Juice" rel="external nofollow noopener noreferrer" target="_blank">Juice</a>。不是很确定会不会出源码解析的文章，尽量输出噶。</p><p>后面会继续更新源码解析系列，下一个系列应该是<a href="https://github.com/changmingxie/tcc-transaction" rel="external nofollow noopener noreferrer" target="_blank">《tcc-transaction 源码解析》</a>。在选择要研究的 tcc 中间件还是蛮纠结的，哈哈，这里听从 <a href="http://www.54tianzhisheng.cn/" rel="external nofollow noopener noreferrer" target="_blank">zhisheng</a> 的建议。如果不好，我保证会打死你的。</p><p>希望坚持不懈的分享源码解析会有更多的同行者阅读。确实，源码解析的受众略小。</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2018_01_15/04.png" alt=""></p><p>道友，赶紧上车，分享一波朋友圈！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. Scheduler 集群&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a hre
      
    
    </summary>
    
      <category term="Elastic-Job-Cloud" scheme="http://www.iocoder.cn/categories/Elastic-Job-Cloud/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Cloud 源码分析 —— 作业失效转移</title>
    <link href="http://www.iocoder.cn/Elastic-Job/cloud-job-failover/"/>
    <id>http://www.iocoder.cn/Elastic-Job/cloud-job-failover/</id>
    <published>2018-01-09T16:00:00.000Z</published>
    <updated>2017-09-07T08:34:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p><ul><li><a href="#">1. 概述</a></li><li><a href="#">2. 记录作业失效转移</a></li><li><a href="#">3. 提交失效转移作业</a></li><li><a href="#">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Cloud 作业失效转移</strong>。对应到 Elastic-Job-Lite 源码解析文章为<a href="http://www.iocoder.cn/Elastic-Job/job-failover/?self">《Elastic-Job-Lite 作业作业失效转移》</a>。</p><p>你需要对<a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/?self">《Elastic-Job-Cloud 源码分析 —— 作业调度（一）》</a>有一定的了解。</p><p>当作业任务在 Elastic-Job-Cloud-Executor 异常崩溃时，该任务在下次调度之前不会被重新执行。开启失效转移功能后，该作业任务会立即被 Elastic-Job-Cloud-Scheduler 重新调度，提交 Elastic-Job-Cloud-Executor <strong>立即</strong>执行。</p><p>在 Elastic-Job-Cloud 里，我们了解到作业分成<strong>瞬时</strong>作业和<strong>常驻</strong>作业。实际上面失效转移的定义暂时只适用于<strong>瞬时</strong>作业。对于<strong>常驻</strong>作业，作业任务异常崩溃后，无论你是否开启失效转移功能，Elastic-Job-Cloud-Scheduler 会立刻提交 Elastic-Job-Cloud-Executor <strong>重新调度</strong>执行。</p><p><strong>为什么此处使用的是“重新调度”，而不是“立即执行”呢</strong>？目前版本 Elasitc-Job-Cloud 暂时不支持<strong>常驻</strong>作业的失效转移，当作业任务异常崩溃，本次执行<strong>不会重新执行</strong>，但是为了作业任务后续能够调度执行，所以再次提交 Elastic-Job-Cloud-Scheduler。</p><blockquote><p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p></blockquote><p>OK，下面我们来看看作业失效转移的实现方式和作业任务异常崩溃的多重场景。</p><h1 id="2-记录作业失效转移"><a href="#2-记录作业失效转移" class="headerlink" title="2. 记录作业失效转移"></a>2. 记录作业失效转移</h1><p>当作业任务异常崩溃时，Elastic-Job-Cloud-Scheduler 通过 Mesos 任务状态变更接口( <code>#statusUpdate()</code> )实现对任务状态的监听处理，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulerEngine</span> <span class="keyword">implements</span> <span class="title">Scheduler</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">statusUpdate</span><span class="params">(<span class="keyword">final</span> SchedulerDriver schedulerDriver, <span class="keyword">final</span> Protos.TaskStatus taskStatus)</span> </span>&#123;</div><div class="line">        String taskId = taskStatus.getTaskId().getValue();</div><div class="line">        TaskContext taskContext = TaskContext.from(taskId);</div><div class="line">        String jobName = taskContext.getMetaInfo().getJobName();</div><div class="line">        log.trace(<span class="string">"call statusUpdate task state is: &#123;&#125;, task id is: &#123;&#125;"</span>, taskStatus.getState(), taskId);</div><div class="line">        jobEventBus.post(<span class="keyword">new</span> JobStatusTraceEvent(jobName, taskContext.getId(), taskContext.getSlaveId(), Source.CLOUD_SCHEDULER, </div><div class="line">                taskContext.getType(), String.valueOf(taskContext.getMetaInfo().getShardingItems()), State.valueOf(taskStatus.getState().name()), taskStatus.getMessage()));</div><div class="line">        <span class="keyword">switch</span> (taskStatus.getState()) &#123;</div><div class="line">            <span class="keyword">case</span> TASK_RUNNING:</div><div class="line">                <span class="comment">// ... 省略无关代码</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> TASK_FINISHED:</div><div class="line">                <span class="comment">// ... 省略无关代码</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> TASK_KILLED:</div><div class="line">                <span class="comment">// ... 省略无关代码</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> TASK_LOST:</div><div class="line">            <span class="keyword">case</span> TASK_DROPPED:</div><div class="line">            <span class="keyword">case</span> TASK_GONE:</div><div class="line">            <span class="keyword">case</span> TASK_GONE_BY_OPERATOR:</div><div class="line">            <span class="keyword">case</span> TASK_FAILED: <span class="comment">// 执行作业任务被错误终止</span></div><div class="line">            <span class="keyword">case</span> TASK_ERROR: <span class="comment">// 任务错误</span></div><div class="line">                log.warn(<span class="string">"task id is: &#123;&#125;, status is: &#123;&#125;, message is: &#123;&#125;, source is: &#123;&#125;"</span>, taskId, taskStatus.getState(), taskStatus.getMessage(), taskStatus.getSource());</div><div class="line">                <span class="comment">// 将任务从运行时队列删除</span></div><div class="line">                facadeService.removeRunning(taskContext);</div><div class="line">                <span class="comment">// 记录失效转移队列</span></div><div class="line">                facadeService.recordFailoverTask(taskContext);</div><div class="line">                <span class="comment">// 通知 TaskScheduler 任务不分配在对应主机上</span></div><div class="line">                unAssignTask(taskId);</div><div class="line">                <span class="comment">// 统计</span></div><div class="line">                statisticManager.taskRunFailed();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> TASK_UNKNOWN:</div><div class="line">            <span class="keyword">case</span> TASK_UNREACHABLE:</div><div class="line">                log.error(<span class="string">"task id is: &#123;&#125;, status is: &#123;&#125;, message is: &#123;&#125;, source is: &#123;&#125;"</span>, taskId, taskStatus.getState(), taskStatus.getMessage(), taskStatus.getSource());</div><div class="line">                statisticManager.taskRunFailed();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>一共有 6 种状态判定为作业任务崩溃，我们来一个一个看看：</p><ul><li><p>TASK_DROPPED / TASK_GONE / TASK_GONE_BY_OPERATOR</p><p>  这三个状态，笔者暂时不太了解，这里先引用一些资料，欢迎有了解的同学指教一下。    </p><blockquote><p>FROM <a href="http://mesos.apache.org/api/latest/java/org/apache/mesos/Protos.TaskState.html" rel="external nofollow noopener noreferrer" target="_blank">http://mesos.apache.org/api/latest/java/org/apache/mesos/Protos.TaskState.html</a><br><strong>TASK_DROPPED</strong>：The task failed to launch because of a transient error.<br><strong>TASK_GONE</strong>：The task is no longer running.<br><strong>TASK_GONE_BY_OPERATOR</strong>：The task was running on an agent that the master cannot contact; the operator has asserted that the agent has been shutdown, but this has not been directly confirmed by the master.  </p><p>FROM <a href="http://mesos.apache.org/blog/mesos-1-1-0-released/" rel="external nofollow noopener noreferrer" target="_blank">http://mesos.apache.org/blog/mesos-1-1-0-released/</a><br>[MESOS-5344] - Experimental support for partition-aware Mesos frameworks. In previous Mesos releases, when an agent is partitioned from the master and then reregisters with the cluster, all tasks running on the agent are terminated and the agent is shutdown. In Mesos 1.1, partitioned agents will no longer be shutdown when they reregister with the master. By default, tasks running on such agents will still be killed (for backward compatibility); however, frameworks can opt-in to the new PARTITION_AWARE capability. If they do this, their tasks will not be killed when a partition is healed. This allows frameworks to define their own policies for how to handle partitioned tasks. Enabling the PARTITION_AWARE capability also introduces a new set of task states: TASK_UNREACHABLE, TASK_DROPPED, TASK_GONE, TASK_GONE_BY_OPERATOR, and TASK_UNKNOWN. <strong>These new states are intended to eventually replace the TASK_LOST state</strong>.</p></blockquote></li><li><p>TASK_FAILED</p><p>  执行作业任务被<strong>错误</strong>终止。例如，执行器( Elastic-Job-Cloud-Executor )异常崩溃，或者被杀死。</p></li><li><p>TASK_ERROR</p><p>  任务启动尝试失败错误。例如，执行器( Elastic-Job-Cloud-Executor ) 接收到的任务的作业配置不正确。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line">    <span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 更新 Mesos 任务状态，运行中。</span></div><div class="line">    executorDriver.sendStatusUpdate(Protos.TaskStatus.newBuilder().setTaskId(taskInfo.getTaskId()).setState(Protos.TaskState.TASK_RUNNING).build());</div><div class="line">    <span class="comment">//</span></div><div class="line">    Map&lt;String, Object&gt; data = SerializationUtils.deserialize(taskInfo.getData().toByteArray());</div><div class="line">    ShardingContexts shardingContexts = (ShardingContexts) data.get(<span class="string">"shardingContext"</span>);</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    JobConfigurationContext jobConfig = <span class="keyword">new</span> JobConfigurationContext((Map&lt;String, String&gt;) data.get(<span class="string">"jobConfigContext"</span>));</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 获得 分布式作业</span></div><div class="line">        ElasticJob elasticJob = getElasticJobInstance(jobConfig);</div><div class="line">        <span class="comment">// 调度器提供内部服务的门面对象</span></div><div class="line">        <span class="keyword">final</span> CloudJobFacade jobFacade = <span class="keyword">new</span> CloudJobFacade(shardingContexts, jobConfig, jobEventBus);</div><div class="line">        <span class="comment">// 执行作业</span></div><div class="line">        <span class="keyword">if</span> (jobConfig.isTransient()) &#123;</div><div class="line">            <span class="comment">// 执行作业</span></div><div class="line">            JobExecutorFactory.getJobExecutor(elasticJob, jobFacade).execute();</div><div class="line">            <span class="comment">// 更新 Mesos 任务状态，已完成。</span></div><div class="line">            executorDriver.sendStatusUpdate(Protos.TaskStatus.newBuilder().setTaskId(taskInfo.getTaskId()).setState(Protos.TaskState.TASK_FINISHED).build());</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 初始化 常驻作业调度器</span></div><div class="line">            <span class="keyword">new</span> DaemonTaskScheduler(elasticJob, jobConfig, jobFacade, executorDriver, taskInfo.getTaskId()).init();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// CHECKSTYLE:OFF</span></div><div class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable ex) &#123;</div><div class="line">        <span class="comment">// CHECKSTYLE:ON</span></div><div class="line">        log.error(<span class="string">"Elastic-Job-Cloud-Executor error"</span>, ex);</div><div class="line">        <span class="comment">// 更新 Mesos 任务状态，错误。</span></div><div class="line">        executorDriver.sendStatusUpdate(Protos.TaskStatus.newBuilder().setTaskId(taskInfo.getTaskId()).setState(Protos.TaskState.TASK_ERROR).setMessage(ExceptionUtil.transform(ex)).build());</div><div class="line">        <span class="comment">// 停止自己</span></div><div class="line">        executorDriver.stop();</div><div class="line">        <span class="keyword">throw</span> ex;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>#getElasticJobInstance()</code> 方法，因为任务的作业配置不正确抛出<strong>异常</strong>。例如，任务类不存在；Spring 的 配置文件不存在；Spring 容器初始化出错；Spring Bean 对象初始化或获取出错；以及等等。</li><li><p><strong>瞬时</strong>作业，调用 <code>AbstractElasticJobExecutor#execute(...)</code> 方法，发生<strong>异常</strong>，并且<strong>异常被抛出</strong>。默认情况下，AbstractElasticJobExecutor 内部使用 DefaultJobExceptionHandler 处理发生的异常，<strong>不会抛出异常</strong>，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultJobExceptionHandler</span> <span class="keyword">implements</span> <span class="title">JobExceptionHandler</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleException</span><span class="params">(<span class="keyword">final</span> String jobName, <span class="keyword">final</span> Throwable cause)</span> </span>&#123;</div><div class="line">        log.error(String.format(<span class="string">"Job '%s' exception occur in job processing"</span>, jobName), cause);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li></li></ul></li><li><p><strong>常驻</strong>作业，调用 <code>DaemonTaskScheduler#(...)</code> 方法，初始化发生<strong>异常</strong>。</p></li><li>因为上述的种种异常，调用 <code>ExecutorDriver#sendStatusUpdate(...)</code>，更新 Mesos 任务状态为 TASK_ERROR。另外，调用 <code>ExecutorDriver#stop()</code> 方法，关闭自己。<strong>这意味着，一个执行器上如果存在一个作业任务发生 TASK_ERROR，其他作业任务即使是正常的，也会更新作业任务状态为 TASK_FAILED</strong>。这块千万要注意。TODO 这个需要确认下。</li></ul></li><li><p>TASK_LOST</p><p>  执行作业任务的 Elastic-Job-Cloud-Executor 所在的 Mesos Slave 与 Mesos Master 因为<strong>网络问题或 Mesos Slave 崩溃</strong>引起丢失连接，<strong>可能</strong>导致其上的所有作业任务状态变为 TASK_LOST。</p><p>  <strong>当 Slave 宕机后重启，导致 TASK_LOST 时，Mesos又是怎么来处理的呢？</strong></p><blockquote><p>FROM <a href="http://dockone.io/article/2513" rel="external nofollow noopener noreferrer" target="_blank">http://dockone.io/article/2513</a><br>在 Master 和 Slave 之间，一般都是由 Master 主动向每一个 Slave 发送Ping消息，如果在设定时间内（flag.slave_ping_timeout，默认15s）没有收到Slave 的回复，并且达到一定次数（flag.max_slave_ping_timeouts，默认次数为5），那么 Master 会操作以下几个步骤：  </p><ol><li>将该 Slave 从 Master 中删除，此时该 Slave 的资源将不会再分配给Scheduler。  </li><li>遍历该 Slave 上运行的所有任务，向对应的 Framework 发送任务的 Task_Lost 状态更新，同时把这些任务从Master中删除。  </li><li>遍历该 Slave 上的所有 Executor，并删除。  </li><li>触发 Rescind Offer，把这个 Slave 上已经分配给 Scheduler 的 Offer 撤销。  </li><li>把这个 Slave 从 Master 的 Replicated log 中删除（Mesos Master 依赖 Replicated log 中的部分持久化集群配置信息进行 failer over / recovery）。 </li></ol></blockquote><ul><li><p>必须 Slave 进行重启，因为对执行器的相关操作只能通过 Mesos Slave，即 <strong>Scheduler &lt;=&gt; Mesos Master &lt;=&gt; Mesos Slave &lt;=&gt; Executor</strong>。如果 Slave 一直不进行重启，执行器会一直运行，除非有另外的机制，<strong>通知</strong>到执行器。</p><p>But………………<br>笔者尝试如上流程，使用 <code>kill -9</code> 模拟 Mesos Slave 异常崩溃，等待 Mesos Master 发现 Mesos Slave 已经关闭，<strong>重启 Mesos Slave</strong>，结果执行器( Elastic-Job-Cloud-Executor )未关闭，调度器( Elastic-Job-Cloud-Scheduler )并未收到任务的 TASK_LOST。？？？什么情况？？？翻查如下文档：</p></li><li><p><a href="http://mesos.apache.org/documentation/latest/high-availability-framework-guide/" rel="external nofollow noopener noreferrer" target="_blank">《Mesos 官方文档 —— high-availability-framework-guide》</a>搜索标题 “Dealing with Partitioned or Failed Agents”。</p></li><li><p><a href="http://mesos.apache.org/documentation/latest/agent-recovery/" rel="external nofollow noopener noreferrer" target="_blank">《Mesos 官方文档 —— agent-recovery》</a>搜索关标题 “Agent Recovery”。</p><p>因为 Elastic-Job-Cloud-Scheduler 注册到 Mesos Master 时，开启了 <code>checkpoint</code> 和 <code>PARTITION_AWARE</code>。开启 <code>checkpoint</code> 后，Mesos Slave 会将记录<strong>检查点</strong>信息， Mesos Slave 重启后，会读取检查点检查信息，<strong>重新连接上( 不会关闭 )</strong>运行在它上面的执行器( Elastic-Job-Cloud-Scheduler )。开启 <code>PARTITION_AWARE</code> 后，TASK_LOST 会被区分成 TASK_UNREACHABLE, TASK_DROPPED, TASK_GONE, TASK_GONE_BY_OPERATOR, and TASK_UNKNOWN。表现如下：</p><ul><li><code>kill -9</code> 模拟 Mesos Slave 异常崩溃，等待 Mesos Master 发现 Mesos Slave 已经关闭</li><li>调度器( Elastic-Job-Cloud-Scheduler ) 接收直接由 Mesos Master 发送的该 Mesos Slave 上的每个任务 TASK_UNREACHABLE。</li><li>Mesos Slave 重启完成。</li><li>执行器( Elastic-Job-Cloud-Executor ) 重新注册到重启好的 Mesos Slave ，并继续运行任务。</li></ul></li></ul><p>如果 Elastic-Job-Cloud-Scheduler 注册到 Mesos Master 时，关闭了 <code>PARTITION_AWARE</code> 和 <code>checkpoint</code>，表现同 <strong>TASK_LOST</strong> 描述的过程。</p><p>开启 <code>checkpoint</code> 和 <code>PARTITION_AWARE</code> 实现代码如下：</p><pre><code><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SchedulerService.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> SchedulerDriver <span class="title">getSchedulerDriver</span><span class="params">(<span class="keyword">final</span> TaskScheduler taskScheduler, <span class="keyword">final</span> JobEventBus jobEventBus, <span class="keyword">final</span> FrameworkIDService frameworkIDService)</span> </span>&#123;</div><div class="line">      Protos.FrameworkInfo.Builder builder = Protos.FrameworkInfo.newBuilder();</div><div class="line">      <span class="comment">// PARTITION_AWARE</span></div><div class="line">      builder.addCapabilitiesBuilder().setType(Protos.FrameworkInfo.Capability.Type.PARTITION_AWARE);</div><div class="line">      Protos.FrameworkInfo frameworkInfo = builder.setUser(mesosConfig.getUser()).setName(frameworkName)</div><div class="line">          .setHostname(mesosConfig.getHostname()).setFailoverTimeout(FRAMEWORK_FAILOVER_TIMEOUT_SECONDS)</div><div class="line">          .setWebuiUrl(WEB_UI_PROTOCOL + env.getFrameworkHostPort())</div><div class="line">          .setCheckpoint(<span class="keyword">true</span>) <span class="comment">// checkpoint</span></div><div class="line">          .build();</div><div class="line">      <span class="comment">// ... 省略无关代码</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure></code></pre><p><strong>是不是开启了 <code>checkpoint</code>，Mesos Slave 重启不会关闭执行器？</strong></p><p> 答案当然是不是的。当 Mesos Slave 配置 <code>recover = cleanup</code> 或者 重启时间超过 <code>recovery_timeout</code> ( 默认，15 分钟 )时，重启完成后，Mesos Slave 关闭运行在它上面的执行器( Elastic-Job-Cloud-Executor )，调度器( Elastic-Job-Cloud-Scheduler ) 接收到的该 Mesos Slave 上的每个任务 TASK_FAILED。</p><ul><li>参考文档：<a href="http://mesos.apache.org/documentation/latest/agent-recovery/" rel="external nofollow noopener noreferrer" target="_blank">《Mesos 官方文档 —— agent-recovery》</a>搜索标题 “Agent Configuration”。</li></ul></li></ul><p><img src="http://www.iocoder.cn/images/Elastic-Job/2018_01_10/01.png" alt=""></p><hr><p>调用 <code>FacadeService#recordFailoverTask(...)</code> 方法，记录失效转移队列，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recordFailoverTask</span><span class="params">(<span class="keyword">final</span> TaskContext taskContext)</span> </span>&#123;</div><div class="line">   Optional&lt;CloudJobConfiguration&gt; jobConfigOptional = jobConfigService.load(taskContext.getMetaInfo().getJobName());</div><div class="line">   <span class="keyword">if</span> (!jobConfigOptional.isPresent()) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (isDisable(jobConfigOptional.get())) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   CloudJobConfiguration jobConfig = jobConfigOptional.get();</div><div class="line">   <span class="keyword">if</span> (jobConfig.getTypeConfig().getCoreConfig().isFailover() <span class="comment">// 开启失效转移</span></div><div class="line">           || CloudJobExecutionType.DAEMON == jobConfig.getJobExecutionType()) &#123; <span class="comment">// 常驻作业</span></div><div class="line">       failoverService.add(taskContext);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>对于<strong>瞬时</strong>作业，必须开启 <code>JobCoreConfiguration.failover = true</code>，才能失效转移，这个比较好理解。</li><li>对于<strong>常驻</strong>作业，暂时不支持失效转移。因为常驻作业是在执行器( Elastic-Job-Executor ) 进行调度执行，如果不添加到失效转移作业队列，重新提交到执行器( Elastic-Job-Executor )，后续就不能调度执行该作业了。</li><li>调用 <code>FailoverService#add(...)</code> 方法，将任务放入失效转移队列，实现代码如下：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// FailoverService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">final</span> TaskContext taskContext)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (regCenter.getNumChildren(FailoverNode.ROOT) &gt; env.getFrameworkConfiguration().getJobStateQueueSize()) &#123;</div><div class="line">       log.warn(<span class="string">"Cannot add job, caused by read state queue size is larger than &#123;&#125;."</span>, env.getFrameworkConfiguration().getJobStateQueueSize());</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   String failoverTaskNodePath = FailoverNode.getFailoverTaskNodePath(taskContext.getMetaInfo().toString());</div><div class="line">   <span class="keyword">if</span> (!regCenter.isExisted(failoverTaskNodePath) <span class="comment">// 判断不在失效转移队列</span></div><div class="line">           &amp;&amp; !runningService.isTaskRunning(taskContext.getMetaInfo())) &#123; <span class="comment">// 判断不在运行中</span></div><div class="line">       regCenter.persist(failoverTaskNodePath, taskContext.getId());</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// FailoverNode.java</span></div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FailoverNode</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ROOT = StateNode.ROOT + <span class="string">"/failover"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FAILOVER_JOB = ROOT + <span class="string">"/%s"</span>; <span class="comment">// %s=$&#123;JOB_NAME&#125;</span></div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FAILOVER_TASK = FAILOVER_JOB + <span class="string">"/%s"</span>; <span class="comment">// %s=$&#123;TASK_META_INFO&#125;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>FailoverService，失效转移队列服务。</li><li><p><strong>失效转移队列</strong>存储在注册中心( Zookeeper )的<strong>持久</strong>数据节点 <code>/${NAMESPACE}/state/failover/${JOB_NAME}/${TASK_META_INFO}</code>，存储值为任务编号。使用 zkClient 查看如下：</p>  <figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">    [zk: localhost:2181(CONNECTED) 2] ls /elastic-job-cloud/state/failover/test_job_simple</div><div class="line">[test_job_simple@-@0]</div><div class="line">[zk: localhost:2181(CONNECTED) 3] get /elastic-job-cloud/state/failover/test_job_simple/test_job_simple@-@0</div><div class="line">test_job_simple@-@0@-@READY@-@4da72be3-43d5-4f02-9d7e-45feb30b8fcb-S2@-@8f2a5bb5-2941-4ece-b192-0f936e60faa7</div></pre></td></tr></table></figure></li><li><p>在运维平台，我们可以看到失效转移队列：</p><p>  <img src="http://www.iocoder.cn/images/Elastic-Job/2018_01_10/02.png" alt=""> </p></li></ul><h1 id="3-提交失效转移作业"><a href="#3-提交失效转移作业" class="headerlink" title="3. 提交失效转移作业"></a>3. 提交失效转移作业</h1><p>在<a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/?self">《Elastic-Job-Cloud 源码分析 —— 作业调度（一）》「4.1 创建 Fenzo 任务请求」</a>里，调用 <code>FacadeService#getEligibleJobContext()</code> 方法，获取有资格运行的作业时。<code>FacadeService#getEligibleJobContext()</code> 不仅调用 <code>ReadyService#getAllEligibleJobContexts(...)</code> 方法，从<strong>待执行队列</strong>中获取所有有资格执行的作业上下文，也调用 <code>FailoverService#getAllEligibleJobContexts()</code> 方法，从<strong>失效转移队列</strong>中获取所有有资格执行的作业上下文。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// FailoverService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> Collection&lt;JobContext&gt; <span class="title">getAllEligibleJobContexts</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 不存在 失效转移队列</span></div><div class="line">   <span class="keyword">if</span> (!regCenter.isExisted(FailoverNode.ROOT)) &#123;</div><div class="line">       <span class="keyword">return</span> Collections.emptyList();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 获取 失效转移队列 的作业们</span></div><div class="line">   List&lt;String&gt; jobNames = regCenter.getChildrenKeys(FailoverNode.ROOT);</div><div class="line">   Collection&lt;JobContext&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(jobNames.size());</div><div class="line">   Set&lt;HashCode&gt; assignedTasks = <span class="keyword">new</span> HashSet&lt;&gt;(jobNames.size() * <span class="number">10</span>, <span class="number">1</span>);</div><div class="line">   <span class="keyword">for</span> (String each : jobNames) &#123;</div><div class="line">       <span class="comment">// 为空时，移除 失效转移队列 的作业</span></div><div class="line">       List&lt;String&gt; taskIdList = regCenter.getChildrenKeys(FailoverNode.getFailoverJobNodePath(each));</div><div class="line">       <span class="keyword">if</span> (taskIdList.isEmpty()) &#123;</div><div class="line">           regCenter.remove(FailoverNode.getFailoverJobNodePath(each));</div><div class="line">           <span class="keyword">continue</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 排除 作业配置 不存在的作业</span></div><div class="line">       Optional&lt;CloudJobConfiguration&gt; jobConfig = configService.load(each);</div><div class="line">       <span class="keyword">if</span> (!jobConfig.isPresent()) &#123;</div><div class="line">           regCenter.remove(FailoverNode.getFailoverJobNodePath(each));</div><div class="line">           <span class="keyword">continue</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 获得待执行的分片集合</span></div><div class="line">       List&lt;Integer&gt; assignedShardingItems = getAssignedShardingItems(each, taskIdList, assignedTasks);</div><div class="line">       <span class="comment">//</span></div><div class="line">       <span class="keyword">if</span> (!assignedShardingItems.isEmpty() &amp;&amp; jobConfig.isPresent()) &#123;</div><div class="line">           result.add(<span class="keyword">new</span> JobContext(jobConfig.get(), assignedShardingItems, ExecutionType.FAILOVER));    </div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">getAssignedShardingItems</span><span class="params">(<span class="keyword">final</span> String jobName, <span class="keyword">final</span> List&lt;String&gt; taskIdList, <span class="keyword">final</span> Set&lt;HashCode&gt; assignedTasks)</span> </span>&#123;</div><div class="line">   List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(taskIdList.size());</div><div class="line">   <span class="keyword">for</span> (String each : taskIdList) &#123;</div><div class="line">       TaskContext.MetaInfo metaInfo = TaskContext.MetaInfo.from(each);</div><div class="line">       <span class="keyword">if</span> (assignedTasks.add(Hashing.md5().newHasher().putString(jobName, Charsets.UTF_8).putInt(metaInfo.getShardingItems().get(<span class="number">0</span>)).hash()) <span class="comment">// 排重</span></div><div class="line">               &amp;&amp; !runningService.isTaskRunning(metaInfo)) &#123; <span class="comment">// 排除正在运行中</span></div><div class="line">           result.add(metaInfo.getShardingItems().get(<span class="number">0</span>));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><p>在<a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/?self">《Elastic-Job-Cloud 源码分析 —— 作业调度（一）》「4.4 创建 Mesos 任务信息」</a>里，调用 <code>LaunchingTasks#getIntegrityViolationJobs()</code> 方法，获得作业分片不完整的作业集合。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LaunchingTasks.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获得作业分片不完整的作业集合</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> vmAssignmentResults 主机分配任务结果集合</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 作业分片不完整的作业集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function">Collection&lt;String&gt; <span class="title">getIntegrityViolationJobs</span><span class="params">(<span class="keyword">final</span> Collection&lt;VMAssignmentResult&gt; vmAssignmentResults)</span> </span>&#123;</div><div class="line">   Map&lt;String, Integer&gt; assignedJobShardingTotalCountMap = getAssignedJobShardingTotalCountMap(vmAssignmentResults);</div><div class="line">   Collection&lt;String&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(assignedJobShardingTotalCountMap.size(), <span class="number">1</span>);</div><div class="line">   <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : assignedJobShardingTotalCountMap.entrySet()) &#123;</div><div class="line">       JobContext jobContext = eligibleJobContextsMap.get(entry.getKey());</div><div class="line">       <span class="keyword">if</span> (ExecutionType.FAILOVER != jobContext.getType() <span class="comment">// 不包括 FAILOVER 执行类型的作业</span></div><div class="line">               &amp;&amp; !entry.getValue().equals(jobContext.getJobConfig().getTypeConfig().getCoreConfig().getShardingTotalCount())) &#123;</div><div class="line">           log.warn(<span class="string">"Job &#123;&#125; is not assigned at this time, because resources not enough to run all sharding instances."</span>, entry.getKey());</div><div class="line">           result.add(entry.getKey());</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>一个作业可能存在部分分片需要失效转移，不需要考虑完整性。</li></ul><hr><p>在<a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/?self">《Elastic-Job-Cloud 源码分析 —— 作业调度（一）》「4.7 从队列中删除已运行的作业」</a>里，调用 <code>FailoverService#remove(...)</code> 方法，从失效转移队列中删除相关任务。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">final</span> Collection&lt;TaskContext.MetaInfo&gt; metaInfoList)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (TaskContext.MetaInfo each : metaInfoList) &#123;</div><div class="line">       regCenter.remove(FailoverNode.getFailoverTaskNodePath(each.toString()));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>原本以为会是一篇水更，后面研究 TASK_LOST，发现收获大大的，干货妥妥的。</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2018_01_10/03.png" alt=""></p><p>道友，赶紧上车，分享一波朋友圈！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. 记录作业失效转移&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="Elastic-Job-Cloud" scheme="http://www.iocoder.cn/categories/Elastic-Job-Cloud/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Cloud 源码分析 —— 本地运行模式</title>
    <link href="http://www.iocoder.cn/Elastic-Job/cloud-local-executor/"/>
    <id>http://www.iocoder.cn/Elastic-Job/cloud-local-executor/</id>
    <published>2018-01-02T16:00:00.000Z</published>
    <updated>2017-09-06T10:53:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p><ul><li><a href="#">1. 概述</a></li><li><a href="#">2. 配置</a></li><li><a href="#">3. 运行</a></li><li><a href="#">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Cloud 本地运行模式</strong>，对应<a href="http://elasticjob.io/docs/elastic-job-cloud/02-guide/local-executor/" rel="external nofollow noopener noreferrer" target="_blank">《官方文档 —— 本地运行模式》</a>。</p><p><strong>有什么用呢</strong>？引用官方解答：</p><blockquote><p>在开发 Elastic-Job-Cloud 作业时，开发人员可以脱离 Mesos 环境，在本地运行和调试作业。可以利用本地运行模式充分的调试业务功能以及单元测试，完成之后再部署至 Mesos 集群。<br>本地运行作业无需安装 Mesos 环境。</p></blockquote><p>😈 是不是很赞 + 1024？！</p><p>本文涉及到主体类的类图如下( <a href="http://www.iocoder.cn/images/Elastic-Job/2018_01_03/01.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2018_01_03/01.png" alt=""></p><blockquote><p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p></blockquote><h1 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h1><p>LocalCloudJobConfiguration，本地云作业配置，在<a href="http://www.iocoder.cn/Elastic-Job/cloud-local-executor/?self">《Elastic-Job-Cloud 源码分析 —— 作业配置》「3.2 本地云作业配置」</a>有详细解析。</p><p>创建本地云作业配置示例代码如下（来自官方）：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LocalCloudJobConfiguration config = <span class="keyword">new</span> LocalCloudJobConfiguration(</div><div class="line">    <span class="keyword">new</span> SimpleJobConfiguration(</div><div class="line">    <span class="comment">// 配置作业类型和作业基本信息</span></div><div class="line">    JobCoreConfiguration.newBuilder(<span class="string">"FooJob"</span>, <span class="string">"*/2 * * * * ?"</span>, <span class="number">3</span>) </div><div class="line">        .shardingItemParameters(<span class="string">"0=Beijing,1=Shanghai,2=Guangzhou"</span>)</div><div class="line">        .jobParameter(<span class="string">"dbName=dangdang"</span>).build(), <span class="string">"com.dangdang.foo.FooJob"</span>),</div><div class="line">        <span class="comment">// 配置当前运行的作业是第几个分片 </span></div><div class="line">        <span class="number">1</span>,  </div><div class="line">        <span class="comment">// 配置Spring相关参数。如果不配置，代表不使用 Spring 配置。</span></div><div class="line">        <span class="string">"testSimpleJob"</span> , <span class="string">"applicationContext.xml"</span>);</div></pre></td></tr></table></figure><h1 id="3-运行"><a href="#3-运行" class="headerlink" title="3. 运行"></a>3. 运行</h1><p>LocalTaskExecutor，本地作业执行器。</p><p>创建本地作业执行器示例代码如下（来自官方）：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">new</span> LocalTaskExecutor(localJobConfig).execute();</div></pre></td></tr></table></figure><p>可以看到，调用 <code>LocalTaskExecutor#execute()</code> 方法，执行作业逻辑，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LocalTaskExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">   AbstractElasticJobExecutor jobExecutor;</div><div class="line">   CloudJobFacade jobFacade = <span class="keyword">new</span> CloudJobFacade(getShardingContexts(), getJobConfigurationContext(), <span class="keyword">new</span> JobEventBus());</div><div class="line">   <span class="comment">// 创建执行器</span></div><div class="line">   <span class="keyword">switch</span> (localCloudJobConfiguration.getTypeConfig().getJobType()) &#123;</div><div class="line">       <span class="keyword">case</span> SIMPLE:</div><div class="line">           jobExecutor = <span class="keyword">new</span> SimpleJobExecutor(getJobInstance(SimpleJob.class), jobFacade);</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       <span class="keyword">case</span> DATAFLOW:</div><div class="line">           jobExecutor = <span class="keyword">new</span> DataflowJobExecutor(getJobInstance(DataflowJob.class), jobFacade);</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       <span class="keyword">case</span> SCRIPT:</div><div class="line">           jobExecutor = <span class="keyword">new</span> ScriptJobExecutor(jobFacade);</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       <span class="keyword">default</span>:</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(localCloudJobConfiguration.getTypeConfig().getJobType().name());</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 执行作业</span></div><div class="line">   jobExecutor.execute();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>#getShardingContexts()</code> 方法，创建分片上下文集合( ShardingContexts )，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> ShardingContexts <span class="title">getShardingContexts</span><span class="params">()</span> </span>&#123;</div><div class="line">   JobCoreConfiguration coreConfig = localCloudJobConfiguration.getTypeConfig().getCoreConfig();</div><div class="line">   Map&lt;Integer, String&gt; shardingItemMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">1</span>, <span class="number">1</span>);</div><div class="line">   shardingItemMap.put(localCloudJobConfiguration.getShardingItem(),</div><div class="line">           <span class="keyword">new</span> ShardingItemParameters(coreConfig.getShardingItemParameters()).getMap().get(localCloudJobConfiguration.getShardingItem()));</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ShardingContexts(</div><div class="line">           <span class="comment">// taskId 👇</span></div><div class="line">           Joiner.on(<span class="string">"@-@"</span>).join(localCloudJobConfiguration.getJobName(), localCloudJobConfiguration.getShardingItem(), <span class="string">"READY"</span>, <span class="string">"foo_slave_id"</span>, <span class="string">"foo_uuid"</span>),</div><div class="line">           localCloudJobConfiguration.getJobName(), coreConfig.getShardingTotalCount(), coreConfig.getJobParameter(), shardingItemMap);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用 <code>#getJobConfigurationContext()</code> 方法，创建内部的作业配置上下文( JobConfigurationContext )，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> JobConfigurationContext <span class="title">getJobConfigurationContext</span><span class="params">()</span> </span>&#123;</div><div class="line">   Map&lt;String, String&gt; jobConfigurationMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">   jobConfigurationMap.put(<span class="string">"jobClass"</span>, localCloudJobConfiguration.getTypeConfig().getJobClass());</div><div class="line">   jobConfigurationMap.put(<span class="string">"jobType"</span>, localCloudJobConfiguration.getTypeConfig().getJobType().name());</div><div class="line">   jobConfigurationMap.put(<span class="string">"jobName"</span>, localCloudJobConfiguration.getJobName());</div><div class="line">   jobConfigurationMap.put(<span class="string">"beanName"</span>, localCloudJobConfiguration.getBeanName());</div><div class="line">   jobConfigurationMap.put(<span class="string">"applicationContext"</span>, localCloudJobConfiguration.getApplicationContext());</div><div class="line">   <span class="keyword">if</span> (JobType.DATAFLOW == localCloudJobConfiguration.getTypeConfig().getJobType()) &#123; <span class="comment">// 数据流作业</span></div><div class="line">       jobConfigurationMap.put(<span class="string">"streamingProcess"</span>, Boolean.toString(((DataflowJobConfiguration) localCloudJobConfiguration.getTypeConfig()).isStreamingProcess()));</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (JobType.SCRIPT == localCloudJobConfiguration.getTypeConfig().getJobType()) &#123; <span class="comment">// 脚本作业</span></div><div class="line">       jobConfigurationMap.put(<span class="string">"scriptCommandLine"</span>, ((ScriptJobConfiguration) localCloudJobConfiguration.getTypeConfig()).getScriptCommandLine());</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> JobConfigurationContext(jobConfigurationMap);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用 <code>#getJobInstance(...)</code> 方法， 获得分布式作业( ElasticJob )实现实例，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> &lt;T extends ElasticJob&gt; <span class="function">T <span class="title">getJobInstance</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; clazz)</span> </span>&#123;</div><div class="line">   Object result;</div><div class="line">   <span class="keyword">if</span> (Strings.isNullOrEmpty(localCloudJobConfiguration.getApplicationContext())) &#123; <span class="comment">// 直接创建 ElasticJob</span></div><div class="line">       String jobClass = localCloudJobConfiguration.getTypeConfig().getJobClass();</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           result = Class.forName(jobClass).newInstance();</div><div class="line">       &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> ReflectiveOperationException ex) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(<span class="string">"Elastic-Job: Class '%s' initialize failure, the error message is '%s'."</span>, jobClass, ex.getMessage());</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">// Spring 环境获得 ElasticJob</span></div><div class="line">       result = <span class="keyword">new</span> ClassPathXmlApplicationContext(localCloudJobConfiguration.getApplicationContext()).getBean(localCloudJobConfiguration.getBeanName());</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> clazz.cast(result);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用 <code>AbstractElasticJobExecutor#execute()</code> 方法，执行作业逻辑。 Elastic-Job-Lite 和 Elastic-Job-Cloud 作业执行基本一致，在<a href="http://www.iocoder.cn/Elastic-Job/job-execute/?self">《Elastic-Job-Lite 源码分析 —— 作业执行》</a>有详细解析。</p></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>芋道君：可能有点水更，和大家实际开发太相关，想想还是更新下。<br>旁白君：哎哟哟，哎哟喂。</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2018_01_03/02.png" alt=""></p><p>道友，赶紧上车，分享一波朋友圈！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. 配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;3. 运
      
    
    </summary>
    
      <category term="Elastic-Job-Cloud" scheme="http://www.iocoder.cn/categories/Elastic-Job-Cloud/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Cloud 源码分析 —— 作业调度（二）</title>
    <link href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-second/"/>
    <id>http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-second/</id>
    <published>2017-12-27T16:00:00.000Z</published>
    <updated>2017-09-07T15:59:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p><ul><li><a href="#">1. 概述</a></li><li><a href="#">2. 云作业操作</a><ul><li><a href="#">2.1 注册云作业配置</a></li><li><a href="#">2.2 禁用云作业</a></li><li><a href="#">2.3 启动云作业</a></li><li><a href="#">2.4 更新云作业配置</a></li><li><a href="#">2.5 注销云作业</a></li><li><a href="#">2.6 触发一次云作业</a></li></ul></li><li><a href="#">3. 云作业应用操作</a><ul><li><a href="#">3.1 注册云作业应用</a></li><li><a href="#">3.2 更新云作业应用配置</a></li><li><a href="#">3.3 禁用云作业应用</a></li><li><a href="#">3.4 启用云作业应用</a></li><li><a href="#">3.5 注销云作业应用</a></li></ul></li><li><a href="#">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Cloud 云作业应用配置和云作业配置变更对作业调度的影响</strong>，作为<a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/?self">《Elastic-Job-Cloud 源码分析 —— 作业调度（一）》</a>的补充内容。所以需要你对<strong>作业调度</strong>已经有一定了解的基础上。</p><p>🙂 如果你做作业调度有任何想交流，欢迎加我的公众号( 芋道源码 ) 或 微信( wangwenbin-server ) 交流。</p><blockquote><p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p></blockquote><h1 id="2-云作业操作"><a href="#2-云作业操作" class="headerlink" title="2. 云作业操作"></a>2. 云作业操作</h1><p>我们可以使用<strong>运维平台</strong>或 Restful API 对云作业进行操作。前者是对后者的界面包装，如下图所示：</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_28/01.png" alt=""></p><h2 id="2-1-注册云作业配置"><a href="#2-1-注册云作业配置" class="headerlink" title="2.1 注册云作业配置"></a>2.1 注册云作业配置</h2><p><a href="http://www.iocoder.cn/Elastic-Job/cloud-job-config/?self">《Elastic-Job-Cloud 源码分析 —— 作业配置》「3.1.1 操作云作业配置」</a>有详细解析。</p><h2 id="2-2-禁用云作业"><a href="#2-2-禁用云作业" class="headerlink" title="2.2 禁用云作业"></a>2.2 禁用云作业</h2><p>调用 <code>CloudJobRestfulApi#disable(...)</code> 方法，禁用云作业，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@POST</span></div><div class="line"><span class="meta">@Path</span>(<span class="string">"/&#123;jobName&#125;/disable"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disable</span><span class="params">(@PathParam(<span class="string">"jobName"</span>)</span> <span class="keyword">final</span> String jobName) </span>&#123;</div><div class="line">   <span class="keyword">if</span> (configService.load(jobName).isPresent()) &#123;</div><div class="line">       <span class="comment">// 将作业放入禁用队列</span></div><div class="line">       facadeService.disableJob(jobName);</div><div class="line">       <span class="comment">// 停止调度作业</span></div><div class="line">       producerManager.unschedule(jobName);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>FacadeService#disableJob(...)</code> 方法，将作业放入<strong>禁用作业队列</strong>。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// FacadeService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disableJob</span><span class="params">(<span class="keyword">final</span> String jobName)</span> </span>&#123;</div><div class="line">   disableJobService.add(jobName);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// DisableJobService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">final</span> String jobName)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (regCenter.getNumChildren(DisableJobNode.ROOT) &gt; env.getFrameworkConfiguration().getJobStateQueueSize()) &#123;</div><div class="line">       log.warn(<span class="string">"Cannot add disable job, caused by read state queue size is larger than &#123;&#125;."</span>, env.getFrameworkConfiguration().getJobStateQueueSize());</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 将作业放入禁用队列</span></div><div class="line">   String disableJobNodePath = DisableJobNode.getDisableJobNodePath(jobName);</div><div class="line">   <span class="keyword">if</span> (!regCenter.isExisted(disableJobNodePath)) &#123;</div><div class="line">       regCenter.persist(disableJobNodePath, jobName);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// DisableJobNode.java</span></div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DisableJobNode</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ROOT = StateNode.ROOT + <span class="string">"/disable/job"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DISABLE_JOB = ROOT + <span class="string">"/%s"</span>; <span class="comment">// %s = $&#123;JOB_NAME&#125;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>DisableJobService，禁用作业队列服务。</li><li><p>禁用作业队列存储在注册中心( Zookeeper )的<strong>持久</strong>数据节点 <code>/${NAMESPACE}/state/disable/job/${JOB_NAME}</code>，存储值为作业名称。使用 zkClient 查看如下： </p>  <figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">    [zk: localhost:2181(CONNECTED) 6] ls /elastic-job-cloud/state/disable/job</div><div class="line">[test_job_simple]</div></pre></td></tr></table></figure></li></ul></li><li><p>调用 <code>ProducerManager#unschedule(...)</code> 方法，停止调度作业。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unschedule</span><span class="params">(<span class="keyword">final</span> String jobName)</span> </span>&#123;</div><div class="line">   <span class="comment">// 杀死作业对应的 Mesos 任务们</span></div><div class="line">   <span class="keyword">for</span> (TaskContext each : runningService.getRunningTasks(jobName)) &#123;</div><div class="line">       schedulerDriver.killTask(Protos.TaskID.newBuilder().setValue(each.getId()).build());</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 将作业从运行时队列删除</span></div><div class="line">   runningService.remove(jobName);</div><div class="line">   <span class="comment">// 将作业从待运行队列删除</span></div><div class="line">   readyService.remove(Lists.newArrayList(jobName));</div><div class="line">   <span class="comment">// 停止作业调度</span></div><div class="line">   Optional&lt;CloudJobConfiguration&gt; jobConfig = configService.load(jobName);</div><div class="line">   <span class="keyword">if</span> (jobConfig.isPresent()) &#123;</div><div class="line">       transientProducerScheduler.deregister(jobConfig.get());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>SchedulerDriver#killTask(...)</code> 方法，杀死作业对应的 Mesos 任务们，适用<strong>常驻作业</strong>。Elastic-Job-Cloud-Scheduler 会接收到 Mesos 杀死任务的请求，调用 <code>TaskExecutor#killTask(...)</code> 方法，停止任务调度。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TaskExecutor.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killTask</span><span class="params">(<span class="keyword">final</span> ExecutorDriver executorDriver, <span class="keyword">final</span> Protos.TaskID taskID)</span> </span>&#123;</div><div class="line">        <span class="comment">// 更新 Mesos 任务状态，已杀死。</span></div><div class="line">        executorDriver.sendStatusUpdate(Protos.TaskStatus.newBuilder().setTaskId(taskID).setState(Protos.TaskState.TASK_KILLED).build());</div><div class="line">        <span class="comment">// 关闭该 Mesos 任务的调度</span></div><div class="line">        DaemonTaskScheduler.shutdown(taskID);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// DaemonTaskScheduler.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 停止任务调度.</span></div><div class="line"><span class="comment">* </span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> taskID 任务主键</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">final</span> Protos.TaskID taskID)</span> </span>&#123;</div><div class="line">   <span class="comment">// 移除任务的 Quartz Scheduler</span></div><div class="line">   Scheduler scheduler = RUNNING_SCHEDULERS.remove(taskID.getValue());</div><div class="line">   <span class="comment">// 关闭任务的 Quartz Scheduler</span></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != scheduler) &#123;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           scheduler.shutdown();</div><div class="line">       &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SchedulerException ex) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(ex);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li></li></ul></li><li><p>调用 <code>RunningService#remove(...)</code> 方法，将作业从<strong>运行时队列</strong>删除。</p></li><li>调用 <code>ReadyService#remove(...)</code> 方法，将作业从<strong>待运行队列</strong>删除。</li><li><p>调用 <code>TransientProducerScheduler#deregister(...)</code> 方法，停止作业调度，适用<strong>瞬时作业</strong>。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deregister</span><span class="params">(<span class="keyword">final</span> CloudJobConfiguration jobConfig)</span> </span>&#123;</div><div class="line">    <span class="comment">// 移除作业</span></div><div class="line">    repository.remove(jobConfig.getJobName());</div><div class="line">    <span class="comment">// 若 cron 不再对应有作业调度，移除 Quartz Scheduler 对 cron 对应的 Quartz Job</span></div><div class="line">    String cron = jobConfig.getTypeConfig().getCoreConfig().getCron();</div><div class="line">    <span class="keyword">if</span> (!repository.containsKey(buildJobKey(cron))) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            scheduler.unscheduleJob(TriggerKey.triggerKey(cron));</div><div class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SchedulerException ex) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(ex);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul></li></ul><h2 id="2-3-启动云作业"><a href="#2-3-启动云作业" class="headerlink" title="2.3 启动云作业"></a>2.3 启动云作业</h2><p>调用 <code>CloudJobRestfulApi#enable(...)</code> 方法，启用云作业，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@DELETE</span></div><div class="line"><span class="meta">@Path</span>(<span class="string">"/&#123;jobName&#125;/disable"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enable</span><span class="params">(@PathParam(<span class="string">"jobName"</span>)</span> <span class="keyword">final</span> String jobName) <span class="keyword">throws</span> JSONException </span>&#123;</div><div class="line">   Optional&lt;CloudJobConfiguration&gt; configOptional = configService.load(jobName);</div><div class="line">   <span class="keyword">if</span> (configOptional.isPresent()) &#123;</div><div class="line">       <span class="comment">// 将作业移出禁用队列</span></div><div class="line">       facadeService.enableJob(jobName);</div><div class="line">       <span class="comment">// 重新调度作业</span></div><div class="line">       producerManager.reschedule(jobName);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>FacadeService#enableJob(...)</code> 方法，将作业移出<strong>禁用作业队列</strong>。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// FacadeService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enableJob</span><span class="params">(<span class="keyword">final</span> String jobName)</span> </span>&#123;</div><div class="line">   disableJobService.remove(jobName);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// DisableJobService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">final</span> String jobName)</span> </span>&#123;</div><div class="line">   regCenter.remove(DisableJobNode.getDisableJobNodePath(jobName));</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用 <code>ProducerManager#reschedule(...)</code> 方法，将作业重新调度。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reschedule</span><span class="params">(<span class="keyword">final</span> String jobName)</span> </span>&#123;</div><div class="line">   <span class="comment">// 停止调度作业</span></div><div class="line">   unschedule(jobName);</div><div class="line">   <span class="comment">// 调度作业</span></div><div class="line">   Optional&lt;CloudJobConfiguration&gt; jobConfig = configService.load(jobName);</div><div class="line">   <span class="keyword">if</span> (jobConfig.isPresent()) &#123;</div><div class="line">       schedule(jobConfig.get());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>#unschedule(...)</code> 方法，停止调度作业。</li><li>调用 <code>#schedule(...)</code> 方法，调度作业，在<a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/?self">《Elastic-Job-Cloud 源码分析 —— 作业调度（一）》</a>有详细解析。</li></ul></li></ul><h2 id="2-4-更新云作业配置"><a href="#2-4-更新云作业配置" class="headerlink" title="2.4 更新云作业配置"></a>2.4 更新云作业配置</h2><p>调用 <code>CloudJobRestfulApi#update(...)</code> 方法，更新云作业配置，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// CloudJobRestfulApi.java</span></div><div class="line"><span class="meta">@PUT</span></div><div class="line"><span class="meta">@Path</span>(<span class="string">"/update"</span>)</div><div class="line"><span class="meta">@Consumes</span>(MediaType.APPLICATION_JSON)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">final</span> CloudJobConfiguration jobConfig)</span> </span>&#123;</div><div class="line">   producerManager.update(jobConfig);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ProducerManager.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">final</span> CloudJobConfiguration jobConfig)</span> </span>&#123;</div><div class="line">   Optional&lt;CloudJobConfiguration&gt; jobConfigFromZk = configService.load(jobConfig.getJobName());</div><div class="line">   <span class="keyword">if</span> (!jobConfigFromZk.isPresent()) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> JobConfigurationException(<span class="string">"Cannot found job '%s', please register first."</span>, jobConfig.getJobName());</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 修改云作业配置</span></div><div class="line">   configService.update(jobConfig);</div><div class="line">   <span class="comment">// 重新调度作业</span></div><div class="line">   reschedule(jobConfig.getJobName());</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>ConfigService#update(jobConfig)</code> 方法，修改云作业配置。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">final</span> CloudJobConfiguration jobConfig)</span> </span>&#123;</div><div class="line">   regCenter.update(CloudJobConfigurationNode.getRootNodePath(jobConfig.getJobName()), CloudJobConfigurationGsonFactory.toJson(jobConfig));</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用 <code>#reschedule(...)</code> 方法，重新调度作业。</p></li></ul><p>存储在注册中心( Zookeeper )的 云作业配置被更新时，云作业配置变更监听( CloudJobConfigurationListener )会监听到，并执行更新相应逻辑，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CloudJobConfigurationListener</span> <span class="keyword">implements</span> <span class="title">TreeCacheListener</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(<span class="keyword">final</span> CuratorFramework client, <span class="keyword">final</span> TreeCacheEvent event)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        String path = <span class="keyword">null</span> == event.getData() ? <span class="string">""</span> : event.getData().getPath();</div><div class="line">        <span class="keyword">if</span> (isJobConfigNode(event, path, Type.NODE_ADDED)) &#123;</div><div class="line">            <span class="comment">// .... 省略无关代码</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isJobConfigNode(event, path, Type.NODE_UPDATED)) &#123;</div><div class="line">            CloudJobConfiguration jobConfig = getJobConfig(event);</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == jobConfig) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 从待执行队列中删除相关作业</span></div><div class="line">            <span class="keyword">if</span> (CloudJobExecutionType.DAEMON == jobConfig.getJobExecutionType()) &#123;</div><div class="line">                readyService.remove(Collections.singletonList(jobConfig.getJobName()));</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 设置禁用错过重执行</span></div><div class="line">            <span class="keyword">if</span> (!jobConfig.getTypeConfig().getCoreConfig().isMisfire()) &#123;</div><div class="line">                readyService.setMisfireDisabled(jobConfig.getJobName());</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 重新调度作业</span></div><div class="line">            producerManager.reschedule(jobConfig.getJobName());</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isJobConfigNode(event, path, Type.NODE_REMOVED)) &#123;</div><div class="line">            <span class="comment">// .... 省略无关代码</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>CloudJobConfigurationListener 实现 TreeCacheListener 实现对 Zookeeper 数据变更的监听。对 TreeCacheListener 感兴趣的同学，可以查看 <a href="https://curator.apache.org/" rel="external nofollow noopener noreferrer" target="_blank">Apache Curator</a> 相关知识。</li><li>调用 <code>ReadyService#remove(...)</code> 方法，将作业从<strong>待运行队列</strong>删除。TODO，为啥要删除？</li><li><p>调用 <code>ReadyService#setMisfireDisabled(...)</code> 方法，设置禁用错过重执行。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMisfireDisabled</span><span class="params">(<span class="keyword">final</span> String jobName)</span> </span>&#123;</div><div class="line">   Optional&lt;CloudJobConfiguration&gt; cloudJobConfig = configService.load(jobName);</div><div class="line">   <span class="keyword">if</span> (cloudJobConfig.isPresent() &amp;&amp; <span class="keyword">null</span> != regCenter.getDirectly(ReadyNode.getReadyJobNodePath(jobName))) &#123;</div><div class="line">       regCenter.persist(ReadyNode.getReadyJobNodePath(jobName), <span class="string">"1"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>瞬时作业</strong>开启 <code>misfire</code> 功能时，当任务执行过久触发 <code>misifre</code> 会不断累积待执行次数。如果关闭 <code>misfire</code> 功能，需要将多次执行次数归 <code>&quot;1&quot;</code>。</li></ul></li><li><p>调用 <code>ProducerManager#reschedule(...)</code> 方法，重新调度作业。TODO，为啥要重复调用这个方法？</p></li></ul><h2 id="2-5-注销云作业"><a href="#2-5-注销云作业" class="headerlink" title="2.5 注销云作业"></a>2.5 注销云作业</h2><p>调用 <code>CloudJobRestfulApi#deregister(...)</code> 方法，注销云作业，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// CloudJobRestfulApi.java</span></div><div class="line"><span class="meta">@DELETE</span></div><div class="line"><span class="meta">@Path</span>(<span class="string">"/deregister"</span>)</div><div class="line"><span class="meta">@Consumes</span>(MediaType.APPLICATION_JSON)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deregister</span><span class="params">(<span class="keyword">final</span> String jobName)</span> </span>&#123;</div><div class="line">   producerManager.deregister(jobName);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ProducerManager.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deregister</span><span class="params">(<span class="keyword">final</span> String jobName)</span> </span>&#123;</div><div class="line">   Optional&lt;CloudJobConfiguration&gt; jobConfig = configService.load(jobName);</div><div class="line">   <span class="keyword">if</span> (jobConfig.isPresent()) &#123;</div><div class="line">       <span class="comment">//  从作业禁用队列中删除作业</span></div><div class="line">       disableJobService.remove(jobName);</div><div class="line">       <span class="comment">// 删除云作业</span></div><div class="line">       configService.remove(jobName);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 停止调度作业</span></div><div class="line">   unschedule(jobName);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>DisableJobService#remove(...)</code> 方法，从<strong>作业禁用队列</strong>中删除作业，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">final</span> String jobName)</span> </span>&#123;</div><div class="line">   regCenter.remove(DisableJobNode.getDisableJobNodePath(jobName));</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><ul><li><p>调用 <code>CloudJobConfigurationService#remove(...)</code> 方法，删除云作业配置。 </p></li><li><p>调用 <code>#reschedule(...)</code> 方法，重新调度作业。</p></li></ul><p>存储在注册中心( Zookeeper )的 云作业配置被删除时，<strong>云作业配置变更监听器</strong>( CloudJobConfigurationListener )会监听到，并执行删除相应逻辑，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CloudJobConfigurationListener</span> <span class="keyword">implements</span> <span class="title">TreeCacheListener</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CoordinatorRegistryCenter regCenter;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ProducerManager producerManager;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReadyService readyService;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CloudJobConfigurationListener</span><span class="params">(<span class="keyword">final</span> CoordinatorRegistryCenter regCenter, <span class="keyword">final</span> ProducerManager producerManager)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.regCenter = regCenter;</div><div class="line">        readyService = <span class="keyword">new</span> ReadyService(regCenter);</div><div class="line">        <span class="keyword">this</span>.producerManager = producerManager;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(<span class="keyword">final</span> CuratorFramework client, <span class="keyword">final</span> TreeCacheEvent event)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        String path = <span class="keyword">null</span> == event.getData() ? <span class="string">""</span> : event.getData().getPath();</div><div class="line">        <span class="keyword">if</span> (isJobConfigNode(event, path, Type.NODE_ADDED)) &#123;</div><div class="line">            <span class="comment">// ... 省略无关代码</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isJobConfigNode(event, path, Type.NODE_UPDATED)) &#123;</div><div class="line">            <span class="comment">// ... 省略无关代码</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isJobConfigNode(event, path, Type.NODE_REMOVED)) &#123;</div><div class="line">            String jobName = path.substring(CloudJobConfigurationNode.ROOT.length() + <span class="number">1</span>, path.length());</div><div class="line">            producerManager.unschedule(jobName);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>#reschedule(...)</code> 方法，重新调度作业。</li></ul><h2 id="2-6-触发一次云作业"><a href="#2-6-触发一次云作业" class="headerlink" title="2.6 触发一次云作业"></a>2.6 触发一次云作业</h2><p>调用 <code>CloudJobRestfulApi#trigger(...)</code> 方法，触发一次云作业，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@POST</span></div><div class="line"><span class="meta">@Path</span>(<span class="string">"/trigger"</span>)</div><div class="line"><span class="meta">@Consumes</span>(MediaType.APPLICATION_JSON)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trigger</span><span class="params">(<span class="keyword">final</span> String jobName)</span> </span>&#123;</div><div class="line">   <span class="comment">// 常驻作业不允许触发一次作业</span></div><div class="line">   Optional&lt;CloudJobConfiguration&gt; config = configService.load(jobName);</div><div class="line">   <span class="keyword">if</span> (config.isPresent() &amp;&amp; CloudJobExecutionType.DAEMON == config.get().getJobExecutionType()) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(<span class="string">"Daemon job '%s' cannot support trigger."</span>, jobName);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 将瞬时作业放入待执行队列</span></div><div class="line">   facadeService.addTransient(jobName);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>目前<strong>常驻</strong>作业<strong>不支持</strong>触发一次云作业。如果想实现该功能，需要 Elastic-Job-Cloud-Scheduler 通过 Mesos 发送自定义消息，通知 Elastic-Job-Cloud-Executor 触发该作业对应的任务们。</li><li>调用 <code>FacadeService#addTransient(...)</code> 方法，将瞬时作业放入<strong>待执行队列</strong>。当且仅当云作业配置 <code>JobCoreConfiguration.misfire = true</code> 时，该作业在<strong>待执行队列</strong>的执行次数不断累积加一。在<a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/?self">《Elastic-Job-Cloud 源码分析 —— 作业调度（一）》「3.2.3 ProducerJob」</a>有详细解析。</li></ul><h1 id="3-云作业应用操作"><a href="#3-云作业应用操作" class="headerlink" title="3. 云作业应用操作"></a>3. 云作业应用操作</h1><p>我们可以使用<strong>运维平台</strong>或 Restful API 对云作业应用进行操作。前者是对后者的界面包装，如下图所示：</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_28/02.png" alt=""></p><h2 id="3-1-注册云作业应用"><a href="#3-1-注册云作业应用" class="headerlink" title="3.1 注册云作业应用"></a>3.1 注册云作业应用</h2><p><a href="http://www.iocoder.cn/Elastic-Job/cloud-job-config/?self">《Elastic-Job-Cloud 源码分析 —— 作业配置》「2.2 操作云作业App配置」</a>有详细解析。</p><h2 id="3-2-更新云作业应用配置"><a href="#3-2-更新云作业应用配置" class="headerlink" title="3.2 更新云作业应用配置"></a>3.2 更新云作业应用配置</h2><p>调用 <code>CloudAppRestfulApi#update(...)</code> 方法，更新云作业应用配置，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// CloudAppRestfulApi.java</span></div><div class="line"><span class="meta">@PUT</span></div><div class="line"><span class="meta">@Consumes</span>(MediaType.APPLICATION_JSON)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">final</span> CloudAppConfiguration appConfig)</span> </span>&#123;</div><div class="line">   appConfigService.update(appConfig);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// CloudAppConfigurationService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">final</span> CloudAppConfiguration appConfig)</span> </span>&#123;</div><div class="line">   regCenter.update(CloudAppConfigurationNode.getRootNodePath(appConfig.getAppName()), CloudAppConfigurationGsonFactory.toJson(appConfig));</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3-3-禁用云作业应用"><a href="#3-3-禁用云作业应用" class="headerlink" title="3.3 禁用云作业应用"></a>3.3 禁用云作业应用</h2><p>调用 <code>CloudAppRestfulApi#disable(...)</code> 方法，禁用云作业应用，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@POST</span></div><div class="line"><span class="meta">@Path</span>(<span class="string">"/&#123;appName&#125;/disable"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disable</span><span class="params">(@PathParam(<span class="string">"appName"</span>)</span> <span class="keyword">final</span> String appName) </span>&#123;</div><div class="line">   <span class="keyword">if</span> (appConfigService.load(appName).isPresent()) &#123;</div><div class="line">       <span class="comment">// 将应用放入禁用队列</span></div><div class="line">       disableAppService.add(appName);</div><div class="line">       <span class="comment">// 停止应用对应所有作业的调度</span></div><div class="line">       <span class="keyword">for</span> (CloudJobConfiguration each : jobConfigService.loadAll()) &#123;</div><div class="line">           <span class="keyword">if</span> (appName.equals(each.getAppName())) &#123;</div><div class="line">               producerManager.unschedule(each.getJobName());</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>DisableAppService#add(...)</code> 方法，将应用放入<strong>禁用应用队列</strong>，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DisableAppService.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DisableAppService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">final</span> String appName)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (regCenter.getNumChildren(DisableAppNode.ROOT) &gt; env.getFrameworkConfiguration().getJobStateQueueSize()) &#123;</div><div class="line">            log.warn(<span class="string">"Cannot add disable app, caused by read state queue size is larger than &#123;&#125;."</span>, env.getFrameworkConfiguration().getJobStateQueueSize());</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        String disableAppNodePath = DisableAppNode.getDisableAppNodePath(appName);</div><div class="line">        <span class="keyword">if</span> (!regCenter.isExisted(disableAppNodePath)) &#123;</div><div class="line">            regCenter.persist(disableAppNodePath, appName);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// DisableAppNode.java</span></div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DisableAppNode</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ROOT = StateNode.ROOT + <span class="string">"/disable/app"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DISABLE_APP = ROOT + <span class="string">"/%s"</span>; <span class="comment">// %s = $&#123;APP_NAME&#125;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>DisableAppService，禁用应用队列服务。</li><li><p>禁用应用队列存储在注册中心( Zookeeper )的<strong>持久</strong>数据节点 <code>/${NAMESPACE}/state/disable/app/${APP_NAME}</code>，存储值为应用名。使用 zkClient 查看如下： </p>  <figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">    [zk: localhost:2181(CONNECTED) 6] ls /elastic-job-cloud/state/disable/app</div><div class="line">[example_app]</div></pre></td></tr></table></figure></li></ul></li><li><p>遍历应用对应所有作业，调用 <code>ProducerManager#unschedule(...)</code> 方法，停止作业调度。</p></li></ul><h2 id="3-4-启用云作业应用"><a href="#3-4-启用云作业应用" class="headerlink" title="3.4 启用云作业应用"></a>3.4 启用云作业应用</h2><p>调用 <code>CloudAppRestfulApi#enable(...)</code> 方法，启用云作业应用，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// CloudAppRestfulApi.java</span></div><div class="line"><span class="meta">@DELETE</span></div><div class="line"><span class="meta">@Path</span>(<span class="string">"/&#123;appName&#125;/disable"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enable</span><span class="params">(@PathParam(<span class="string">"appName"</span>)</span> <span class="keyword">final</span> String appName) <span class="keyword">throws</span> JSONException </span>&#123;</div><div class="line">   <span class="keyword">if</span> (appConfigService.load(appName).isPresent()) &#123;</div><div class="line">       <span class="comment">// 从禁用应用队列中删除应用</span></div><div class="line">       disableAppService.remove(appName);</div><div class="line">       <span class="comment">// 重新开启应用对应所有作业的调度</span></div><div class="line">       <span class="keyword">for</span> (CloudJobConfiguration each : jobConfigService.loadAll()) &#123;</div><div class="line">           <span class="keyword">if</span> (appName.equals(each.getAppName())) &#123;</div><div class="line">               producerManager.reschedule(each.getJobName());</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// DisableAppService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">final</span> String appName)</span> </span>&#123;</div><div class="line">   regCenter.remove(DisableAppNode.getDisableAppNodePath(appName));</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3-5-注销云作业应用"><a href="#3-5-注销云作业应用" class="headerlink" title="3.5 注销云作业应用"></a>3.5 注销云作业应用</h2><p>调用 <code>CloudAppRestfulApi#deregister(...)</code> 方法，注销云作业应用，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@DELETE</span></div><div class="line"><span class="meta">@Path</span>(<span class="string">"/&#123;appName&#125;"</span>)</div><div class="line"><span class="meta">@Consumes</span>(MediaType.APPLICATION_JSON)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deregister</span><span class="params">(@PathParam(<span class="string">"appName"</span>)</span> <span class="keyword">final</span> String appName) </span>&#123;</div><div class="line">   <span class="keyword">if</span> (appConfigService.load(appName).isPresent()) &#123;</div><div class="line">       <span class="comment">// 移除应用和应用对应所有作业的配置</span></div><div class="line">       removeAppAndJobConfigurations(appName);</div><div class="line">       <span class="comment">// 停止应用对应的执行器( Elastic-Job-Cloud-Scheduler )</span></div><div class="line">       stopExecutors(appName);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>#removeAppAndJobConfigurations(...)</code> 方法，移除应用和应用对应所有作业的配置，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeAppAndJobConfigurations</span><span class="params">(<span class="keyword">final</span> String appName)</span> </span>&#123;</div><div class="line">   <span class="comment">// 注销(移除)应用对应所有作业的配置</span></div><div class="line">   <span class="keyword">for</span> (CloudJobConfiguration each : jobConfigService.loadAll()) &#123;</div><div class="line">       <span class="keyword">if</span> (appName.equals(each.getAppName())) &#123;</div><div class="line">           producerManager.deregister(each.getJobName());</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 从禁用应用队列中删除应用</span></div><div class="line">   disableAppService.remove(appName);</div><div class="line">   <span class="comment">// 删除云作业App配置</span></div><div class="line">   appConfigService.remove(appName);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用 <code>#stopExecutors(...)</code> 方法，停止应用对应的执行器( Elastic-Job-Cloud-Scheduler )，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// CloudAppRestfulApi.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stopExecutors</span><span class="params">(<span class="keyword">final</span> String appName)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       Collection&lt;ExecutorStateInfo&gt; executorBriefInfo = mesosStateService.executors(appName);</div><div class="line">       <span class="keyword">for</span> (ExecutorStateInfo each : executorBriefInfo) &#123;</div><div class="line">           producerManager.sendFrameworkMessage(ExecutorID.newBuilder().setValue(each.getId()).build(),</div><div class="line">                   SlaveID.newBuilder().setValue(each.getSlaveId()).build(), <span class="string">"STOP"</span>.getBytes());</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> JSONException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ProducerManager.java </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendFrameworkMessage</span><span class="params">(<span class="keyword">final</span> ExecutorID executorId, <span class="keyword">final</span> SlaveID slaveId, <span class="keyword">final</span> <span class="keyword">byte</span>[] data)</span> </span>&#123;</div><div class="line">    schedulerDriver.sendFrameworkMessage(executorId, slaveId, data);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>SchedulerDriver#sendFrameworkMessage(...)</code> 方法，通过 Mesos 向云作业应用对应的执行器们( Elastic-Job-Cloud-Executor ) 发送消息为 <code>&quot;STOP&quot;</code> 从而关闭执行器。Elastic-Job-Cloud-Executor 会接收到 Mesos 消息，调用 <code>TaskExecutor#frameworkMessage(...)</code> 方法，关闭自己。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">frameworkMessage</span><span class="params">(<span class="keyword">final</span> ExecutorDriver executorDriver, <span class="keyword">final</span> <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != bytes &amp;&amp; <span class="string">"STOP"</span>.equals(<span class="keyword">new</span> String(bytes))) &#123;</div><div class="line">        log.error(<span class="string">"call frameworkMessage executor stopped."</span>);</div><div class="line">        executorDriver.stop();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>Elastic-Job-Cloud 作业调度两篇内容到此就结束啦。后续我们会更新大家关心的<a href="http://www.iocoder.cn/Elastic-Job/cloud-high-availability/?self">《Elastic-Job-Cloud 源码分析 —— 高可用》</a>是如何实现的噢。</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_28/03.png" alt=""></p><p>道友，赶紧上车，分享一波朋友圈！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. 云作业操作&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2.
      
    
    </summary>
    
      <category term="Elastic-Job-Cloud" scheme="http://www.iocoder.cn/categories/Elastic-Job-Cloud/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Cloud 源码分析 —— 作业调度（一）</title>
    <link href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/"/>
    <id>http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/</id>
    <published>2017-12-20T16:00:00.000Z</published>
    <updated>2017-09-07T15:54:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p><ul><li><a href="#">1. 概述</a></li><li><a href="#">2. 作业执行类型</a></li><li><a href="#">3. Producer 发布任务</a><ul><li><a href="#">3.1 常驻作业</a></li><li><a href="#">3.2 瞬时作业</a><ul><li><a href="#">3.2.1 TransientProducerScheduler</a></li><li><a href="#">3.2.2 注册瞬时作业</a></li><li><a href="#">3.2.3 ProducerJob</a></li></ul></li><li><a href="#">3.3 小结</a></li></ul></li><li><a href="#">4. TaskLaunchScheduledService 提交任务</a><ul><li><a href="#">4.1 创建 Fenzo 任务请求</a></li><li><a href="#">4.2 AppConstraintEvaluator</a></li><li><a href="#">4.3 将任务请求分配到 Mesos Offer</a></li><li><a href="#">4.4 创建 Mesos 任务信息</a><ul><li><a href="#">4.4.1 创建单个 Mesos 任务信息</a></li></ul></li><li><a href="#">4.5 将任务运行时上下文放入运行时队列</a></li><li><a href="#">4.6 从队列中删除已运行的作业</a></li><li><a href="#">4.7 提交任务给 Mesos</a></li></ul></li><li><a href="#">5. TaskExecutor 执行任务</a><ul><li><a href="#">5.1 TaskThread</a></li><li><a href="#">5.2 DaemonTaskScheduler</a></li></ul></li><li><a href="#">6. SchedulerEngine 处理任务的状态变更</a></li><li><a href="#">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Cloud 调度主流程</strong>。对应到 Elastic-Job-Lite 源码解析文章如下：</p><ul><li><a href="http://www.iocoder.cn/Elastic-Job/job-init/?self">《Elastic-Job-Lite 源码分析 —— 作业初始化》</a></li><li><a href="http://www.iocoder.cn/Elastic-Job/job-execute/?self">《Elastic-Job-Lite 源码分析 —— 作业执行》</a></li><li><a href="http://www.iocoder.cn/Elastic-Job/job-sharding/">《Elastic-Job-Lite 源码分析 —— 作业分片》</a></li></ul><p>如果你阅读过以下文章，有助于对本文的理解：</p><ul><li><a href="http://www.infoq.com/cn/news/2016/09/Mesos-Elastic-Job-Cloud" rel="external nofollow noopener noreferrer" target="_blank">《基于Mesos的当当作业云Elastic Job Cloud》</a></li><li><a href="https://segmentfault.com/a/1190000007723430" rel="external nofollow noopener noreferrer" target="_blank">《由浅入深 | 如何优雅地写一个Mesos Framework》</a></li></ul><p>😈 另外，笔者假设你已经对 <strong><a href="http://www.iocoder.cn/categories/Elastic-Job/?self">《Elastic-Job-Lite 源码分析系列》</a></strong> 有一定的了解。</p><p>本文涉及到主体类的类图如下( <a href="http://www.iocoder.cn/images/Elastic-Job/2017_12_21/01.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_21/01.png" alt=""></p><blockquote><p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p></blockquote><p>Elastic-Job-Cloud 基于 Mesos 实现分布式作业调度，或者说 Elastic-Job-Cloud 是 Mesos 上的 框架( Framework )。</p><p>一个 Mesos 框架由两部分组成：</p><ul><li>控制器部分，称为调度器( Scheduler )。</li><li>工作单元部分，称为执行器( Executor )。</li></ul><p>Elastic-Job-Cloud 由两个项目组成：</p><ul><li>Elastic-Job-Cloud-Scheduler，实现调度器，实现类为 <code>com.dangdang.ddframe.job.cloud.scheduler.mesos.SchedulerEngine</code>。</li><li>Elastic-Job-Cloud-Executor，实现执行器，实现类为 <code>com.dangdang.ddframe.job.cloud.executor.TaskExecutor</code>。</li></ul><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_21/11.png" alt=""></p><p>本文略微<strong>“啰嗦”</strong>，请保持<strong>耐心</strong>。搭配<a href="http://product.dangdang.com/24187450.html" rel="external nofollow noopener noreferrer" target="_blank">《用Mesos框架构建分布式应用》</a>一起阅读，理解难度降低 99%。OK，开始我们的 Cloud 之旅。</p><h1 id="2-作业执行类型"><a href="#2-作业执行类型" class="headerlink" title="2. 作业执行类型"></a>2. 作业执行类型</h1><p>在 Elastic-Job-Cloud，作业执行分成两种类型：</p><ul><li>常驻作业</li></ul><blockquote><p>常驻作业是作业一旦启动，无论运行与否均占用系统资源；<br>常驻作业适合初始化时间长、触发间隔短、实时性要求高的作业，要求资源配备充足。</p></blockquote><ul><li>瞬时作业</li></ul><blockquote><p>瞬时作业是在作业启动时占用资源，运行完成后释放资源。<br>瞬时作业适合初始化时间短、触发间隔长、允许延迟的作业，一般用于资源不太充分，或作业要求的资源多，适合资源错峰使用的场景。</p></blockquote><p>Elastic-Job-Cloud 不同于 Elastic-Job-Lite 去中心化执行调度，转变为 <strong>Mesos Framework 的中心节点调度</strong>。这里不太理解，没关系，下文看到具体代码就能明白了。</p><p>常驻作业、瞬时作业在调度中会略有不同，大体<strong>粗略</strong>流程如下：</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_21/02.png" alt=""></p><p>下面，我们针对每个过程一节一节解析。</p><h1 id="3-Producer-发布任务"><a href="#3-Producer-发布任务" class="headerlink" title="3. Producer 发布任务"></a>3. Producer 发布任务</h1><p>在上文<a href="http://www.iocoder.cn/Elastic-Job/cloud-job-config/?self">《Elastic-Job-Cloud 源码分析 —— 作业配置》的「3.1.1 操作云作业配置」</a>可以看到添加云作业配置后，Elastic-Job-Cloud-Scheduler 会执行<strong>作业调度</strong>，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ProducerManager.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 调度作业.</span></div><div class="line"><span class="comment">* </span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> jobConfig 作业配置</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(<span class="keyword">final</span> CloudJobConfiguration jobConfig)</span> </span>&#123;</div><div class="line">   <span class="comment">// 应用 或 作业 被禁用，不调度</span></div><div class="line">   <span class="keyword">if</span> (disableAppService.isDisabled(jobConfig.getAppName()) || disableJobService.isDisabled(jobConfig.getJobName())) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (CloudJobExecutionType.TRANSIENT == jobConfig.getJobExecutionType()) &#123; <span class="comment">// 瞬时作业</span></div><div class="line">       transientProducerScheduler.register(jobConfig);</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (CloudJobExecutionType.DAEMON == jobConfig.getJobExecutionType()) &#123; <span class="comment">// 常驻作业</span></div><div class="line">       readyService.addDaemon(jobConfig.getJobName());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>瞬时作业和常驻作业在调度上会有一定的不同。</li></ul><h2 id="3-1-常驻作业"><a href="#3-1-常驻作业" class="headerlink" title="3.1 常驻作业"></a>3.1 常驻作业</h2><p>常驻作业在调度时，直接添加到待执行作业队列。What？岂不是马上就运行了！No No No，答案在「5. TaskExecutor 执行任务」，这里先打住。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ReadyService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 将常驻作业放入待执行队列.</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> jobName 作业名称</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDaemon</span><span class="params">(<span class="keyword">final</span> String jobName)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (regCenter.getNumChildren(ReadyNode.ROOT) &gt; env.getFrameworkConfiguration().getJobStateQueueSize()) &#123;</div><div class="line">       log.warn(<span class="string">"Cannot add daemon job, caused by read state queue size is larger than &#123;&#125;."</span>, env.getFrameworkConfiguration().getJobStateQueueSize());</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   Optional&lt;CloudJobConfiguration&gt; cloudJobConfig = configService.load(jobName);</div><div class="line">   <span class="keyword">if</span> (!cloudJobConfig.isPresent() || CloudJobExecutionType.DAEMON != cloudJobConfig.get().getJobExecutionType() || runningService.isJobRunning(jobName)) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 添加到待执行队列</span></div><div class="line">   regCenter.persist(ReadyNode.getReadyJobNodePath(jobName), <span class="string">"1"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ReadyNode.java</span></div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadyNode</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ROOT = StateNode.ROOT + <span class="string">"/ready"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String READY_JOB = ROOT + <span class="string">"/%s"</span>; <span class="comment">// %s = $&#123;JOB_NAME&#125;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>ReadyService，待执行作业队列服务，提供对待执行作业队列的各种操作方法。</li><li><p><strong>待执行作业队列</strong>存储在注册中心( Zookeeper )的<strong>持久</strong>数据节点 <code>/${NAMESPACE}/state/ready/${JOB_NAME}</code>，存储值为待执行次数。例如此处，待执行次数为 <code>1</code>。使用 zkClient 查看如下：</p>  <figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 4] ls /elastic-job-cloud/state/ready</div><div class="line">[test_job_simple]</div><div class="line">[zk: localhost:2181(CONNECTED) 5] get /elastic-job-cloud/state/ready/test_job_simple</div><div class="line">1</div></pre></td></tr></table></figure></li><li><p>在运维平台，我们可以看到待执行作业队列：</p><p>  <img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_21/10.png" alt="">    </p></li><li><p>从官方的 RoadMap 来看，<strong>待执行作业队列</strong>未来会使用 Redis 存储以提高性能。</p><blockquote><p>FROM <a href="http://elasticjob.io/docs/elastic-job-cloud/03-design/roadmap/" rel="external nofollow noopener noreferrer" target="_blank">http://elasticjob.io/docs/elastic-job-cloud/03-design/roadmap/</a><br>Redis Based Queue Improvement</p></blockquote></li></ul><h2 id="3-2-瞬时作业"><a href="#3-2-瞬时作业" class="headerlink" title="3.2 瞬时作业"></a>3.2 瞬时作业</h2><p>瞬时作业在调度时，使用<strong>发布瞬时作业任务的调度器</strong>( TransientProducerScheduler )调度作业。当瞬时作业到达作业执行时间，添加到待执行作业队列。</p><h3 id="3-2-1-TransientProducerScheduler"><a href="#3-2-1-TransientProducerScheduler" class="headerlink" title="3.2.1 TransientProducerScheduler"></a>3.2.1 TransientProducerScheduler</h3><p>TransientProducerScheduler，发布瞬时作业任务的调度器，基于 Quartz 实现对瞬时作业的调度。初始化代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TransientProducerScheduler.java</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">   scheduler = getScheduler();</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       scheduler.start();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SchedulerException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> Scheduler <span class="title">getScheduler</span><span class="params">()</span> </span>&#123;</div><div class="line">   StdSchedulerFactory factory = <span class="keyword">new</span> StdSchedulerFactory();</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       factory.initialize(getQuartzProperties());</div><div class="line">       <span class="keyword">return</span> factory.getScheduler();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SchedulerException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> Properties <span class="title">getQuartzProperties</span><span class="params">()</span> </span>&#123;</div><div class="line">   Properties result = <span class="keyword">new</span> Properties();</div><div class="line">   result.put(<span class="string">"org.quartz.threadPool.class"</span>, SimpleThreadPool.class.getName());</div><div class="line">   result.put(<span class="string">"org.quartz.threadPool.threadCount"</span>, Integer.toString(Runtime.getRuntime().availableProcessors() * <span class="number">2</span>)); <span class="comment">// 线程池数量</span></div><div class="line">   result.put(<span class="string">"org.quartz.scheduler.instanceName"</span>, <span class="string">"ELASTIC_JOB_CLOUD_TRANSIENT_PRODUCER"</span>);</div><div class="line">   result.put(<span class="string">"org.quartz.plugin.shutdownhook.class"</span>, ShutdownHookPlugin.class.getName());</div><div class="line">   result.put(<span class="string">"org.quartz.plugin.shutdownhook.cleanShutdown"</span>, Boolean.TRUE.toString());</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-2-2-注册瞬时作业"><a href="#3-2-2-注册瞬时作业" class="headerlink" title="3.2.2 注册瞬时作业"></a>3.2.2 注册瞬时作业</h3><p>调用 <code>TransientProducerScheduler#register(...)</code> 方法，注册瞬时作业。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TransientProducerScheduler.java</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> TransientProducerRepository repository;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> CloudJobConfiguration jobConfig)</span> </span>&#123;</div><div class="line">   String cron = jobConfig.getTypeConfig().getCoreConfig().getCron();</div><div class="line">   <span class="comment">// 添加 cron 作业集合</span></div><div class="line">   JobKey jobKey = buildJobKey(cron);</div><div class="line">   repository.put(jobKey, jobConfig.getJobName());</div><div class="line">   <span class="comment">// 调度 作业</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">if</span> (!scheduler.checkExists(jobKey)) &#123;</div><div class="line">           scheduler.scheduleJob(buildJobDetail(jobKey), buildTrigger(jobKey.getName()));</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SchedulerException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>#buildJobKey(...)</code> 方法，创建 Quartz JobKey。你会发现很有意思的使用的是 <code>cron</code> 参数作为主键。Why？在看下 <code>!scheduler.checkExists(jobKey)</code> 处，相同 JobKey( <code>cron</code> ) 的作业不重复注册到 Quartz Scheduler。Why？此处是一个优化，相同 <code>cron</code> 使用同一个 Quartz Job，Elastic-Job-Cloud-Scheduler 可能会注册大量的瞬时作业，如果一个瞬时作业创建一个 Quartz Job 太过浪费，特别是 <code>cron</code> 每分钟、每5分钟、每小时、每天已经覆盖了大量的瞬时作业的情况。因此，相同 <code>cron</code> 使用同一个 Quartz Job。</li><li><p>调用 <code>TransientProducerRepository#put(...)</code> 以 Quartz JobKey 为主键聚合作业。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransientProducerRepository</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * cron 作业集合</span></div><div class="line"><span class="comment">     * key：作业Key</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;JobKey, List&lt;String&gt;&gt; cronTasks = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>, <span class="number">1</span>);</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">final</span> JobKey jobKey, <span class="keyword">final</span> String jobName)</span> </span>&#123;</div><div class="line">        remove(jobName);</div><div class="line">        List&lt;String&gt; taskList = cronTasks.get(jobKey);</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == taskList) &#123;</div><div class="line">            taskList = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</div><div class="line">            taskList.add(jobName);</div><div class="line">            cronTasks.put(jobKey, taskList);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!taskList.contains(jobName)) &#123;</div><div class="line">            taskList.add(jobName);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用 <code>#buildJobDetail(...)</code> 创建 Quartz Job 信息。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> JobDetail <span class="title">buildJobDetail</span><span class="params">(<span class="keyword">final</span> JobKey jobKey)</span> </span>&#123;</div><div class="line">    JobDetail result = JobBuilder.newJob(ProducerJob.class) <span class="comment">// ProducerJob.java</span></div><div class="line">            .withIdentity(jobKey).build();</div><div class="line">    result.getJobDataMap().put(<span class="string">"repository"</span>, repository);</div><div class="line">    result.getJobDataMap().put(<span class="string">"readyService"</span>, readyService);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>JobBuilder#newJob(...)</code> 的参数是 ProducerJob，下文会讲解到。</li></ul></li><li><p>调用 <code>#buildTrigger(...)</code> 创建 Quartz Trigger。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Trigger <span class="title">buildTrigger</span><span class="params">(<span class="keyword">final</span> String cron)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> TriggerBuilder.newTrigger()</div><div class="line">           .withIdentity(cron)</div><div class="line">           .withSchedule(CronScheduleBuilder.cronSchedule(cron) <span class="comment">// cron</span></div><div class="line">           .withMisfireHandlingInstructionDoNothing())</div><div class="line">           .build();</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h3 id="3-2-3-ProducerJob"><a href="#3-2-3-ProducerJob" class="headerlink" title="3.2.3 ProducerJob"></a>3.2.3 ProducerJob</h3><p>ProducerJob，当 Quartz Job 到达 <code>cron</code> 执行时间( 即作业执行时间)，将相应的瞬时作业添加到待执行作业队列。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</div><div class="line">        </div><div class="line">   <span class="keyword">private</span> TransientProducerRepository repository;</div><div class="line">   </div><div class="line">   <span class="keyword">private</span> ReadyService readyService;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</div><div class="line">       List&lt;String&gt; jobNames = repository.get(context.getJobDetail().getKey());</div><div class="line">       <span class="keyword">for</span> (String each : jobNames) &#123;</div><div class="line">           readyService.addTransient(each);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>TransientProducerRepository#get(...)</code> 方法，获得该 Job 对应的作业集合。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransientProducerRepository</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * cron 作业集合</span></div><div class="line"><span class="comment">     * key：作业Key</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;JobKey, List&lt;String&gt;&gt; cronTasks = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>, <span class="number">1</span>);</div><div class="line">    </div><div class="line">    <span class="function">List&lt;String&gt; <span class="title">get</span><span class="params">(<span class="keyword">final</span> JobKey jobKey)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; result = cronTasks.get(jobKey);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span> == result ? Collections.&lt;String&gt;emptyList() : result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用 <code>ReadyService#addTransient(...)</code> 方法，添加瞬时作业到待执行作业队列。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 将瞬时作业放入待执行队列.</span></div><div class="line"><span class="comment">* </span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> jobName 作业名称</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTransient</span><span class="params">(<span class="keyword">final</span> String jobName)</span> </span>&#123;</div><div class="line">   <span class="comment">//</span></div><div class="line">   <span class="keyword">if</span> (regCenter.getNumChildren(ReadyNode.ROOT) &gt; env.getFrameworkConfiguration().getJobStateQueueSize()) &#123;</div><div class="line">       log.warn(<span class="string">"Cannot add transient job, caused by read state queue size is larger than &#123;&#125;."</span>, env.getFrameworkConfiguration().getJobStateQueueSize());</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">//</span></div><div class="line">   Optional&lt;CloudJobConfiguration&gt; cloudJobConfig = configService.load(jobName);</div><div class="line">   <span class="keyword">if</span> (!cloudJobConfig.isPresent() || CloudJobExecutionType.TRANSIENT != cloudJobConfig.get().getJobExecutionType()) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// </span></div><div class="line">   String readyJobNode = ReadyNode.getReadyJobNodePath(jobName);</div><div class="line">   String times = regCenter.getDirectly(readyJobNode);</div><div class="line">   <span class="keyword">if</span> (cloudJobConfig.get().getTypeConfig().getCoreConfig().isMisfire()) &#123;</div><div class="line">       regCenter.persist(readyJobNode, Integer.toString(<span class="keyword">null</span> == times ? <span class="number">1</span> : Integer.parseInt(times) + <span class="number">1</span>));</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       regCenter.persist(ReadyNode.getReadyJobNodePath(jobName), <span class="string">"1"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>添加瞬时作业到待执行作业队列</strong> 和 <strong>添加常驻作业到待执行作业队列</strong>基本是一致的。</li><li>当作业配置允许 <code>misfire</code>，则不断累积作业可执行次数。</li></ul></li></ul><h2 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h2><p>无论是常驻作业还是瞬时作业，都会加入到<strong>待执行作业队列</strong>。目前我们看到瞬时作业的每次调度是 TransientProducerScheduler 负责。那么常驻作业的每次调度呢？「5. TaskExecutor 执行任务」会看到它的调度，这是 Elastic-Job-Cloud 设计巧妙有趣的地方。</p><h1 id="4-TaskLaunchScheduledService-提交任务"><a href="#4-TaskLaunchScheduledService-提交任务" class="headerlink" title="4. TaskLaunchScheduledService 提交任务"></a>4. TaskLaunchScheduledService 提交任务</h1><p>TaskLaunchScheduledService，任务提交调度服务。它继承 Guava AbstractScheduledService 实现定时将待执行作业队列的作业提交到 Mesos 进行调度执行。实现<strong>定时</strong>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskLaunchScheduledService</span> <span class="keyword">extends</span> <span class="title">AbstractScheduledService</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">serviceName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"task-launch-processor"</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Scheduler <span class="title">scheduler</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Scheduler.newFixedDelaySchedule(<span class="number">2</span>, <span class="number">10</span>, TimeUnit.SECONDS);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">runOneIteration</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">// .... 省略代码</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略部分方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>每 10 秒执行提交任务( <code>#runOneIteration()</code> )。对 Guava AbstractScheduledService 不了解的同学，可以阅读完本文后 Google 下。因为是通过每 10 秒轮询的方式提交任务，所以<strong>瞬时作业</strong>的执行时间不是非常严格，存在略有延迟，这个实际在使用需要注意的。那<strong>常驻作业</strong>呢，看完本文，你就会知道答案。</li></ul><p><code>#runOneIteration()</code> 方法相对比较复杂，我们一块一块拆解，<strong>耐心</strong>理解。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">runOneIteration</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       System.out.println(<span class="string">"runOneIteration:"</span> + <span class="keyword">new</span> Date());</div><div class="line">       <span class="comment">// 创建 Fenzo 任务请求</span></div><div class="line">       LaunchingTasks launchingTasks = <span class="keyword">new</span> LaunchingTasks(facadeService.getEligibleJobContext());</div><div class="line">       List&lt;TaskRequest&gt; taskRequests = launchingTasks.getPendingTasks();</div><div class="line">       <span class="comment">// 获取所有正在运行的云作业App https://github.com/Netflix/Fenzo/wiki/Constraints</span></div><div class="line">       <span class="keyword">if</span> (!taskRequests.isEmpty()) &#123;</div><div class="line">           AppConstraintEvaluator.getInstance().loadAppRunningState();</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 将任务请求分配到 Mesos Offer</span></div><div class="line">       Collection&lt;VMAssignmentResult&gt; vmAssignmentResults = taskScheduler.scheduleOnce(taskRequests, LeasesQueue.getInstance().drainTo()).getResultMap().values();</div><div class="line">       <span class="comment">// 创建 Mesos 任务请求</span></div><div class="line">       List&lt;TaskContext&gt; taskContextsList = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">// 任务运行时上下文集合</span></div><div class="line">       Map&lt;List&lt;Protos.OfferID&gt;, List&lt;Protos.TaskInfo&gt;&gt; offerIdTaskInfoMap = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// Mesos 任务信息集合</span></div><div class="line">       <span class="keyword">for</span> (VMAssignmentResult each: vmAssignmentResults) &#123;</div><div class="line">           List&lt;VirtualMachineLease&gt; leasesUsed = each.getLeasesUsed();</div><div class="line">           List&lt;Protos.TaskInfo&gt; taskInfoList = <span class="keyword">new</span> ArrayList&lt;&gt;(each.getTasksAssigned().size() * <span class="number">10</span>);</div><div class="line">           taskInfoList.addAll(getTaskInfoList(</div><div class="line">                   launchingTasks.getIntegrityViolationJobs(vmAssignmentResults), <span class="comment">// 获得作业分片不完整的作业集合</span></div><div class="line">                   each, leasesUsed.get(<span class="number">0</span>).hostname(), leasesUsed.get(<span class="number">0</span>).getOffer()));</div><div class="line">           <span class="keyword">for</span> (Protos.TaskInfo taskInfo : taskInfoList) &#123;</div><div class="line">               taskContextsList.add(TaskContext.from(taskInfo.getTaskId().getValue()));</div><div class="line">           &#125;</div><div class="line">           offerIdTaskInfoMap.put(getOfferIDs(leasesUsed), <span class="comment">// 获得 Offer ID 集合</span></div><div class="line">                   taskInfoList);</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 遍历任务运行时上下文</span></div><div class="line">       <span class="keyword">for</span> (TaskContext each : taskContextsList) &#123;</div><div class="line">           <span class="comment">// 将任务运行时上下文放入运行时队列</span></div><div class="line">           facadeService.addRunning(each);</div><div class="line">           <span class="comment">// 发布作业状态追踪事件(State.TASK_STAGING)</span></div><div class="line">           jobEventBus.post(createJobStatusTraceEvent(each));</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 从队列中删除已运行的作业</span></div><div class="line">       facadeService.removeLaunchTasksFromQueue(taskContextsList);</div><div class="line">       <span class="comment">// 提交任务给 Mesos</span></div><div class="line">       <span class="keyword">for</span> (Entry&lt;List&lt;OfferID&gt;, List&lt;TaskInfo&gt;&gt; each : offerIdTaskInfoMap.entrySet()) &#123;</div><div class="line">           schedulerDriver.launchTasks(each.getKey(), each.getValue());</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</div><div class="line">       log.error(<span class="string">"Launch task error"</span>, throwable);</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       <span class="comment">// 清理 AppConstraintEvaluator 所有正在运行的云作业App</span></div><div class="line">       AppConstraintEvaluator.getInstance().clearAppRunningState();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="4-1-创建-Fenzo-任务请求"><a href="#4-1-创建-Fenzo-任务请求" class="headerlink" title="4.1 创建 Fenzo 任务请求"></a>4.1 创建 Fenzo 任务请求</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// #runOneIteration()</span></div><div class="line">LaunchingTasks launchingTasks = <span class="keyword">new</span> LaunchingTasks(facadeService.getEligibleJobContext());</div><div class="line">List&lt;TaskRequest&gt; taskRequests = launchingTasks.getPendingTasks();</div></pre></td></tr></table></figure><ul><li><p>调用 <code>FacadeService#getEligibleJobContext()</code> 方法，获取有资格运行的作业。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// FacadeService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获取有资格运行的作业.</span></div><div class="line"><span class="comment">* </span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 作业上下文集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> Collection&lt;JobContext&gt; <span class="title">getEligibleJobContext</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 从失效转移队列中获取所有有资格执行的作业上下文</span></div><div class="line">   Collection&lt;JobContext&gt; failoverJobContexts = failoverService.getAllEligibleJobContexts();</div><div class="line">   <span class="comment">// 从待执行队列中获取所有有资格执行的作业上下文</span></div><div class="line">   Collection&lt;JobContext&gt; readyJobContexts = readyService.getAllEligibleJobContexts(failoverJobContexts);</div><div class="line">   <span class="comment">// 合并</span></div><div class="line">   Collection&lt;JobContext&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(failoverJobContexts.size() + readyJobContexts.size());</div><div class="line">   result.addAll(failoverJobContexts);</div><div class="line">   result.addAll(readyJobContexts);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>FailoverService#getAllEligibleJobContexts()</code> 方法，从<strong>失效转移队列</strong>中获取所有有资格执行的作业上下文。<strong>TaskLaunchScheduledService 提交的任务还可能来自失效转移队列</strong>。本文暂时不解析失效转移队列相关实现，避免增加复杂度影响大家的理解，在<a href="http://www.iocoder.cn/Elastic-Job/cloud-job-failover/?self">《Elastic-Job-Cloud 源码分析 —— 作业失效转移》</a>详细解析。</li><li><p>调用 <code>ReadyService#getAllEligibleJobContexts(...)</code> 方法，从<strong>待执行队列</strong>中获取所有有资格执行的作业上下文。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ReadyService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 从待执行队列中获取所有有资格执行的作业上下文.</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> ineligibleJobContexts 无资格执行的作业上下文</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 有资格执行的作业上下文集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> Collection&lt;JobContext&gt; <span class="title">getAllEligibleJobContexts</span><span class="params">(<span class="keyword">final</span> Collection&lt;JobContext&gt; ineligibleJobContexts)</span> </span>&#123;</div><div class="line">   <span class="comment">// 不存在 待执行队列</span></div><div class="line">   <span class="keyword">if</span> (!regCenter.isExisted(ReadyNode.ROOT)) &#123;</div><div class="line">       <span class="keyword">return</span> Collections.emptyList();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 无资格执行的作业上下文 转换成 无资格执行的作业集合</span></div><div class="line">   Collection&lt;String&gt; ineligibleJobNames = Collections2.transform(ineligibleJobContexts, <span class="keyword">new</span> Function&lt;JobContext, String&gt;() &#123;</div><div class="line">       </div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(<span class="keyword">final</span> JobContext input)</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> input.getJobConfig().getJobName();</div><div class="line">       &#125;</div><div class="line">   &#125;);</div><div class="line">   <span class="comment">// 获取 待执行队列 有资格执行的作业上下文</span></div><div class="line">   List&lt;String&gt; jobNames = regCenter.getChildrenKeys(ReadyNode.ROOT);</div><div class="line">   List&lt;JobContext&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(jobNames.size());</div><div class="line">   <span class="keyword">for</span> (String each : jobNames) &#123;</div><div class="line">       <span class="keyword">if</span> (ineligibleJobNames.contains(each)) &#123;</div><div class="line">           <span class="keyword">continue</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 排除 作业配置 不存在的作业</span></div><div class="line">       Optional&lt;CloudJobConfiguration&gt; jobConfig = configService.load(each);</div><div class="line">       <span class="keyword">if</span> (!jobConfig.isPresent()) &#123;</div><div class="line">           regCenter.remove(ReadyNode.getReadyJobNodePath(each));</div><div class="line">           <span class="keyword">continue</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (!runningService.isJobRunning(each)) &#123; <span class="comment">// 排除 运行中 的作业</span></div><div class="line">           result.add(JobContext.from(jobConfig.get(), ExecutionType.READY));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li></li></ul></li><li><p>JobContext，作业运行上下文。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobContext.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobContext</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CloudJobConfiguration jobConfig;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Integer&gt; assignedShardingItems;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutionType type;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 通过作业配置创建作业运行上下文.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> jobConfig 作业配置</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> type 执行类型</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 作业运行上下文</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JobContext <span class="title">from</span><span class="params">(<span class="keyword">final</span> CloudJobConfiguration jobConfig, <span class="keyword">final</span> ExecutionType type)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> shardingTotalCount = jobConfig.getTypeConfig().getCoreConfig().getShardingTotalCount();</div><div class="line">        <span class="comment">// 分片项</span></div><div class="line">        List&lt;Integer&gt; shardingItems = <span class="keyword">new</span> ArrayList&lt;&gt;(shardingTotalCount);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shardingTotalCount; i++) &#123;</div><div class="line">            shardingItems.add(i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JobContext(jobConfig, shardingItems, type);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>LaunchingTasks，分配任务行为包。创建 LaunchingTasks 代码如下：</p> <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LaunchingTasks</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 作业上下文集合</span></div><div class="line"><span class="comment">     * key：作业名</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, JobContext&gt; eligibleJobContextsMap;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LaunchingTasks</span><span class="params">(<span class="keyword">final</span> Collection&lt;JobContext&gt; eligibleJobContexts)</span> </span>&#123;</div><div class="line">        eligibleJobContextsMap = <span class="keyword">new</span> HashMap&lt;&gt;(eligibleJobContexts.size(), <span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span> (JobContext each : eligibleJobContexts) &#123;</div><div class="line">            eligibleJobContextsMap.put(each.getJobConfig().getJobName(), each);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用 <code>LaunchingTasks#getPendingTasks()</code> 方法，获得待执行任务集合。<strong>这里要注意，每个作业如果有多个分片，则会生成多个待执行任务，即此处完成了作业分片</strong>。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LaunchingTasks.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获得待执行任务</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 待执行任务</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function">List&lt;TaskRequest&gt; <span class="title">getPendingTasks</span><span class="params">()</span> </span>&#123;</div><div class="line">   List&lt;TaskRequest&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(eligibleJobContextsMap.size() * <span class="number">10</span>);</div><div class="line">   <span class="keyword">for</span> (JobContext each : eligibleJobContextsMap.values()) &#123;</div><div class="line">       result.addAll(createTaskRequests(each));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 创建待执行任务集合</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> jobContext 作业运行上下文</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 待执行任务集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> Collection&lt;TaskRequest&gt; <span class="title">createTaskRequests</span><span class="params">(<span class="keyword">final</span> JobContext jobContext)</span> </span>&#123;</div><div class="line">   Collection&lt;TaskRequest&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(jobContext.getAssignedShardingItems().size());</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> each : jobContext.getAssignedShardingItems()) &#123;</div><div class="line">       result.add(<span class="keyword">new</span> JobTaskRequest(<span class="keyword">new</span> TaskContext(jobContext.getJobConfig().getJobName(), Collections.singletonList(each), jobContext.getType()), jobContext.getJobConfig()));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// TaskContext.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskContext</span> </span>&#123;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 任务编号</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">private</span> String id;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 任务元信息</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> MetaInfo metaInfo;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 执行类型</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ExecutionType type;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * Mesos Slave 编号</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">private</span> String slaveId;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 是否闲置</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="meta">@Setter</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> idle;</div><div class="line">   </div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MetaInfo</span> </span>&#123;</div><div class="line"></div><div class="line">       <span class="comment">/**</span></div><div class="line"><span class="comment">        * 作业名</span></div><div class="line"><span class="comment">        */</span></div><div class="line">       <span class="keyword">private</span> <span class="keyword">final</span> String jobName;</div><div class="line">       <span class="comment">/**</span></div><div class="line"><span class="comment">        * 作业分片项</span></div><div class="line"><span class="comment">        */</span></div><div class="line">       <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Integer&gt; shardingItems;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="comment">// ... 省略部分方法</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// JobTaskRequest.JAVA</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobTaskRequest</span> <span class="keyword">implements</span> <span class="title">TaskRequest</span> </span>&#123;</div><div class="line">    </div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> TaskContext taskContext;</div><div class="line">       </div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> CloudJobConfiguration jobConfig;</div><div class="line">       </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">return</span> taskContext.getId();</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getCPUs</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> jobConfig.getCpuCount();</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getMemory</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">return</span> jobConfig.getMemoryMB();</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="comment">// ... 省略部分方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>#createTaskRequests(...)</code> 方法，<strong>将单个作业按照其作业分片总数拆分成一个或多个待执行任务集合</strong>。</li><li>TaskContext，任务运行时上下文。</li><li>JobTaskRequest，作业任务请求对象。       </li></ul></li><li>因为对象有点多，我们来贴一个 <code>LaunchingTasks#getPendingTasks()</code> 方法的返回结果。<br>  <img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_21/03.png" alt=""></li></ul><p><strong>友情提示，代码可能比较多，请耐心观看。</strong></p><h2 id="4-2-AppConstraintEvaluator"><a href="#4-2-AppConstraintEvaluator" class="headerlink" title="4.2 AppConstraintEvaluator"></a>4.2 AppConstraintEvaluator</h2><p>在说 AppConstraintEvaluator 之前，我们先一起了<strong>简单</strong>解下 <a href="https://github.com/Netflix/Fenzo/wiki" rel="external nofollow noopener noreferrer" target="_blank">Netflix Fenzo</a>。</p><blockquote><p>FROM <a href="http://dockone.io/article/636" rel="external nofollow noopener noreferrer" target="_blank">http://dockone.io/article/636</a><br>Fenzo是一个在Mesos框架上应用的通用任务调度器。它可以让你通过实现各种优化策略的插件，来优化任务调度，同时这也有利于集群的自动缩放。</p></blockquote><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_21/05.png" alt=""></p><p>Elastic-Job-Cloud-Scheduler 基于 Fenzo 实现对 Mesos 的弹性资源分配。</p><p>例如，AppConstraintEvaluator，App 目标 Mesos Slave 适配度限制器，选择 Slave 时需要考虑其上是否运行有 App 的 Executor，如果没有运行 Executor 需要将其资源消耗考虑进适配计算算法中。它是 <a href="https://github.com/Netflix/Fenzo/blob/5de0e0861def4a655be35a9624e67318a6c0afac/fenzo-core/src/main/java/com/netflix/fenzo/ConstraintEvaluator.java" rel="external nofollow noopener noreferrer" target="_blank">Fenzo ConstraintEvaluator 接口</a> 在 Elastic-Job-Cloud-Scheduler 的自定义任务约束实现。通过这个任务约束，在下文调用 <code>TaskScheduler#scheduleOnce(...)</code> 方法调度任务所需资源时，会将 AppConstraintEvaluator 考虑进去。</p><p>那么作业任务请求( JobTaskRequest ) 是怎么关联上 AppConstraintEvaluator 的呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobTaskRequest.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobTaskRequest</span> <span class="keyword">implements</span> <span class="title">TaskRequest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> List&lt;? extends ConstraintEvaluator&gt; getHardConstraints() &#123;</div><div class="line">        <span class="keyword">return</span> Collections.singletonList(AppConstraintEvaluator.getInstance());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><a href="https://github.com/Netflix/Fenzo/blob/20d71b5c3213063fc938cd2841dc7569601d1d99/fenzo-core/src/main/java/com/netflix/fenzo/TaskRequest.java" rel="external nofollow noopener noreferrer" target="_blank">Fenzo TaskRequest 接口</a> 是 Fenzo 的任务请求接口，通过实现 <code>#getHardConstraints()</code> 方法，关联上 TaskRequest 和 ConstraintEvaluator。</li></ul><p>关联上之后，任务匹配 Mesos Slave 资源时，调用 <code>ConstraintEvaluator#evaluate(...)</code> 实现方法判断是否符合约束：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConstraintEvaluator</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isSuccessful;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String failureReason;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Inspects a target to decide whether or not it meets the constraints appropriate to a particular task.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> taskRequest a description of the task to be assigned</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> targetVM a description of the host that is a potential match for the task</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> taskTrackerState the current status of tasks and task assignments in the system at large</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> a successful Result if the target meets the constraints enforced by this constraint evaluator, or</span></div><div class="line"><span class="comment">     *         an unsuccessful Result otherwise</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">evaluate</span><span class="params">(TaskRequest taskRequest, VirtualMachineCurrentState targetVM,</span></span></div><div class="line"><span class="function"><span class="params">                           TaskTrackerState taskTrackerState)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>OK，简单了解结束，有兴趣了解更多的同学，请点击<a href="https://github.com/Netflix/Fenzo/wiki/Constraints" rel="external nofollow noopener noreferrer" target="_blank">《Fenzo Wiki —— Constraints》</a>。下面来看看 Elastic-Job-Cloud-Scheduler 自定义实现的任务约束 AppConstraintEvaluator。</p><hr><p>调用 <code>AppConstraintEvaluator#loadAppRunningState()</code> 方法，加载当前运行中的<strong>云作业App</strong>，为 <code>AppConstraintEvaluator#evaluate(...)</code> 方法提供该数据。代码实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AppConstraintEvaluator.java</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; runningApps = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">loadAppRunningState</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">for</span> (MesosStateService.ExecutorStateInfo each : facadeService.loadExecutorInfo()) &#123;</div><div class="line">           runningApps.add(each.getId());</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> JSONException | UniformInterfaceException | ClientHandlerException e) &#123;</div><div class="line">       clearAppRunningState();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>FacadeService#loadExecutorInfo()</code> 方法，从 Mesos 获取所有正在运行的 Mesos 执行器( Executor )的信息。执行器和云作业App有啥关系？<strong>每个云作业App 即是一个 Elastic-Job-Cloud-Executor 实例。</strong>。<code>FacadeService#loadExecutorInfo()</code> 方法这里就不展开了，有兴趣的同学自己看下，主要是对 Mesos 的 API操作，我们来看下 <code>runningApps</code> 的结果：</p><p>  <img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_21/04.png" alt=""></p></li></ul><hr><p>调用 <code>TaskScheduler#scheduleOnce(...)</code> 方法调度提交任务所需资源时，会调用 <code>ConstraintEvaluator#loadAppRunningState()</code> 检查分配的资源是否符合任务的约束条件。<code>AppConstraintEvaluator#loadAppRunningState()</code> 实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AppConstraintEvaluator.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">evaluate</span><span class="params">(<span class="keyword">final</span> TaskRequest taskRequest, <span class="keyword">final</span> VirtualMachineCurrentState targetVM, <span class="keyword">final</span> TaskTrackerState taskTrackerState)</span> </span>&#123;</div><div class="line">   <span class="keyword">double</span> assigningCpus = <span class="number">0.0</span>d;</div><div class="line">   <span class="keyword">double</span> assigningMemoryMB = <span class="number">0.0</span>d;</div><div class="line">   <span class="keyword">final</span> String slaveId = targetVM.getAllCurrentOffers().iterator().next().getSlaveId().getValue();</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 判断当前分配的 Mesos Slave 是否运行着该作业任务请求对应的云作业App</span></div><div class="line">       <span class="keyword">if</span> (isAppRunningOnSlave(taskRequest.getId(), slaveId)) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">true</span>, <span class="string">""</span>);</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 判断当前分配的 Mesos Slave 启动云作业App 是否超过资源限制</span></div><div class="line">       Set&lt;String&gt; calculatedApps = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">// 已计算作业App集合</span></div><div class="line">       List&lt;TaskRequest&gt; taskRequests = <span class="keyword">new</span> ArrayList&lt;&gt;(targetVM.getTasksCurrentlyAssigned().size() + <span class="number">1</span>);</div><div class="line">       taskRequests.add(taskRequest);</div><div class="line">       <span class="keyword">for</span> (TaskAssignmentResult each : targetVM.getTasksCurrentlyAssigned()) &#123; <span class="comment">// 当前已经分配作业请求</span></div><div class="line">           taskRequests.add(each.getRequest());</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">for</span> (TaskRequest each : taskRequests) &#123;</div><div class="line">           assigningCpus += each.getCPUs();</div><div class="line">           assigningMemoryMB += each.getMemory();</div><div class="line">           <span class="keyword">if</span> (isAppRunningOnSlave(each.getId(), slaveId)) &#123; <span class="comment">// 作业App已经启动</span></div><div class="line">               <span class="keyword">continue</span>;</div><div class="line">           &#125;</div><div class="line">           CloudAppConfiguration assigningAppConfig = getAppConfiguration(each.getId());</div><div class="line">           <span class="keyword">if</span> (!calculatedApps.add(assigningAppConfig.getAppName())) &#123; <span class="comment">// 是否已经计算该App</span></div><div class="line">               <span class="keyword">continue</span>;</div><div class="line">           &#125;</div><div class="line">           assigningCpus += assigningAppConfig.getCpuCount();</div><div class="line">           assigningMemoryMB += assigningAppConfig.getMemoryMB();</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> LackConfigException ex) &#123;</div><div class="line">       log.warn(<span class="string">"Lack config, disable &#123;&#125;"</span>, getName(), ex);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">true</span>, <span class="string">""</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (assigningCpus &gt; targetVM.getCurrAvailableResources().cpuCores()) &#123; <span class="comment">// cpu</span></div><div class="line">       log.debug(<span class="string">"Failure &#123;&#125; &#123;&#125; cpus:&#123;&#125;/&#123;&#125;"</span>, taskRequest.getId(), slaveId, assigningCpus, targetVM.getCurrAvailableResources().cpuCores());</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">false</span>, String.format(<span class="string">"cpu:%s/%s"</span>, assigningCpus, targetVM.getCurrAvailableResources().cpuCores()));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (assigningMemoryMB &gt; targetVM.getCurrAvailableResources().memoryMB()) &#123; <span class="comment">// memory</span></div><div class="line">       log.debug(<span class="string">"Failure &#123;&#125; &#123;&#125; mem:&#123;&#125;/&#123;&#125;"</span>, taskRequest.getId(), slaveId, assigningMemoryMB, targetVM.getCurrAvailableResources().memoryMB());</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">false</span>, String.format(<span class="string">"mem:%s/%s"</span>, assigningMemoryMB, targetVM.getCurrAvailableResources().memoryMB()));</div><div class="line">   &#125;</div><div class="line">   log.debug(<span class="string">"Success &#123;&#125; &#123;&#125; cpus:&#123;&#125;/&#123;&#125; mem:&#123;&#125;/&#123;&#125;"</span>, taskRequest.getId(), slaveId, assigningCpus, targetVM.getCurrAvailableResources()</div><div class="line">           .cpuCores(), assigningMemoryMB, targetVM.getCurrAvailableResources().memoryMB());</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">true</span>, String.format(<span class="string">"cpus:%s/%s mem:%s/%s"</span>, assigningCpus, targetVM.getCurrAvailableResources()</div><div class="line">           .cpuCores(), assigningMemoryMB, targetVM.getCurrAvailableResources().memoryMB()));</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>#isAppRunningOnSlave()</code> 方法，判断当前分配的 Mesos Slave 是否运行着该作业任务请求对应的云作业App。若云作业App未运行，则该作业任务请求提交给 Mesos 后，该 Mesos Slave 会启动该云作业 App，App 本身会占用一定的 <code>CloudAppConfiguration#cpu</code> 和 <code>CloudAppConfiguration#memory</code>，计算时需要统计，避免超过当前 Mesos Slave 剩余 <code>cpu</code> 和 <code>memory</code>。</li><li>当计算符合约束时，返回 <code>Result(true, ...)</code>；否则，返回 <code>Result(false, ...)</code>。</li><li>TODO 异常为啥返回true。</li></ul><h2 id="4-3-将任务请求分配到-Mesos-Offer"><a href="#4-3-将任务请求分配到-Mesos-Offer" class="headerlink" title="4.3 将任务请求分配到 Mesos Offer"></a>4.3 将任务请求分配到 Mesos Offer</h2><p>我们先<strong>简单</strong>了解下 Elastic-Job-Cloud-Scheduler 实现的 Mesos Scheduler 类 <code>com.dangdang.ddframe.job.cloud.scheduler.mesos.SchedulerEngine</code>。调度器的主要职责之一：<strong>在接受到的 Offer 上启动任务</strong>。SchedulerEngine 接收到资源 Offer，先存储到资源预占队列( LeasesQueue )，等到作业被调度需要启动任务时进行使用。存储到资源预占队列实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulerEngine</span> <span class="keyword">implements</span> <span class="title">Scheduler</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resourceOffers</span><span class="params">(<span class="keyword">final</span> SchedulerDriver schedulerDriver, <span class="keyword">final</span> List&lt;Protos.Offer&gt; offers)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Protos.Offer offer: offers) &#123;</div><div class="line">            log.trace(<span class="string">"Adding offer &#123;&#125; from host &#123;&#125;"</span>, offer.getId(), offer.getHostname());</div><div class="line">            LeasesQueue.getInstance().offer(offer);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>org.apache.mesos.Scheduler</code>，Mesos 调度器<strong>接口</strong>，实现该接口成为自定义 Mesos 调度器。</li><li><p>实现 <code>#resourceOffers(...)</code> 方法，有新的资源 Offer 时，会进行调用。在 SchedulerEngine 会调用 <code>#offer(...)</code> 方法，存储 Offer 到资源预占队列，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LeasesQueue</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 单例</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> LeasesQueue INSTANCE = <span class="keyword">new</span> LeasesQueue();</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;VirtualMachineLease&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获取实例.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 单例对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LeasesQueue <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> INSTANCE;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 添加资源至队列预占.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> offer 资源</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(<span class="keyword">final</span> Protos.Offer offer)</span> </span>&#123;</div><div class="line">        queue.offer(<span class="keyword">new</span> VMLeaseObject(offer));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ... 省略 #drainTo() 方法，下文解析。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>VMLeaseObject，<a href="#">Netflix Fenzo</a> 对 Mesos Offer 的抽象包装，点击<a href="https://github.com/Netflix/Fenzo/blob/faa8a4dd411fff1792c9d788d1288a11e3635ba7/fenzo-core/src/main/java/com/netflix/fenzo/plugins/VMLeaseObject.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a>查看实现代码，马上会看到它的用途。</li></ul></li></ul><p>另外，可能有同学对 Mesos Offer 理解比较生涩，Offer 定义如下：</p><blockquote><p>FROM <a href="https://segmentfault.com/a/1190000007723430" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000007723430</a><br>Offer是Mesos资源的抽象，比如说有多少CPU、多少memory，disc是多少，都放在Offer里，打包给一个Framework，然后Framework来决定到底怎么用这个Offer。</p></blockquote><hr><p>OK，知识铺垫完成，回到本小节的重心：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// #runOneIteration()</span></div><div class="line">Collection&lt;VMAssignmentResult&gt; vmAssignmentResults = taskScheduler.scheduleOnce(taskRequests, LeasesQueue.getInstance().drainTo()).getResultMap().values();</div><div class="line"></div><div class="line"><span class="comment">// LeasesQueue.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LeasesQueue</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;VirtualMachineLease&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;VirtualMachineLease&gt; <span class="title">drainTo</span><span class="params">()</span> </span>&#123;</div><div class="line">        List&lt;VirtualMachineLease&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(queue.size());</div><div class="line">        queue.drainTo(result);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>调用 <code>TaskScheduler#scheduleOnce(...)</code> 方法，将任务请求分配到 Mesos Offer。通过 Fenzo TaskScheduler 实现对多个任务分配到多个 Mesos Offer 的<strong>合理优化分配</strong>。这是一个相对复杂的问题。为什么这么说呢？</p><blockquote><p>FROM <a href="http://product.dangdang.com/24187450.html" rel="external nofollow noopener noreferrer" target="_blank">《Mesos 框架构建分布式应用》</a> P76<br>将任务匹配到 offer 上，首次适配通常是最好的算法。你可能会想，如果在更多的工作里尝试计算出匹配该 offer 的优化组合，可能比首次适配更能高效地利用 offer。这绝对是正确的，但是要考虑如下这些方面：对于启动所有等待运行的任务来说，集群里要么有充足的资源要么没有。如果资源很多，那么首次适配肯定一直都能保证每个任务的启动。如果资源不够，怎么都无法启动所有任务。因此，编写代码选择接下来会运行哪个任务是很自然的，这样才能保证服务的质量。只有当资源刚够用时，才需要更为精细的打包算法。不幸的是，这里的问题 —— 通常称为背包问题( Knapsack problem ) —— 是一个众所周知的 NP 完全问题。NP 完全问题指的是需要相当长时间才能找到最优解决方案的问题，并且没有任何已知道技巧能够快速解决这类问题。</p></blockquote><p>举个简单的例子，只考虑 <code>memory</code> 资源情况下，有一台 Slave 内存为 8GB ，现在要运行三个 1GB 的作业和 5GB 的作业。其中 5GB 的作业在 1GB 运行多次之后才执行。 </p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_21/06.png" alt=""></p><p>实际情况会比图更加复杂的多的多。通过使用 Fenzo ，可以很方便的，并且令人满意的分配。为了让你对 Fenzo 有更加透彻的理解，这里再引用一段对其的介绍：</p><blockquote><p>FROM <a href="http://product.dangdang.com/24187450.html" rel="external nofollow noopener noreferrer" target="_blank">《Mesos 框架构建分布式应用》</a> P80<br><strong>调用库函数 Fenzo</strong><br>Fenzo 是 Nettflix 在 2015 年夏天发布的库函数。Fenzo 为基于 java 的调度器提供了完整的解决方案，完成 offer 缓冲，多任务启动，以及软和硬约束条件的匹配。就算不是所有的，也是很多调度器都能够受益于使用 Fenzo 来完成计算任务分配，而不用自己编写 offer 缓冲、打包和放置路由等。</p></blockquote><p>下面，来看两次 <code>TaskScheduler#scheduleOnce(...)</code> 的返回：</p><ul><li>第一次调度：<img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_21/07.png" alt=""></li><li>第二次调度：<img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_21/08.png" alt=""></li><li><p><code>com.netflix.fenzo.VMAssignmentResult</code>，每台主机分配任务结果。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VMAssignmentResult</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 主机</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String hostname;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 使用的 Mesos Offer</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;VirtualMachineLease&gt; leasesUsed;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 分配的任务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;TaskAssignmentResult&gt; tasksAssigned;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p>受限于笔者的能力，建议你可以在阅读如下文章，更透彻的理解 TaskScheduler ：</p><ul><li><a href="https://github.com/Netflix/Fenzo/wiki/How-to-use-Fenzo" rel="external nofollow noopener noreferrer" target="_blank">《Fenzo Wiki —— Constraints》</a></li><li><a href="https://github.com/Netflix/Fenzo/wiki/Building-Your-Scheduler" rel="external nofollow noopener noreferrer" target="_blank">《Fenzo Wiki —— Building Your Scheduler》</a></li><li><a href="https://github.com/Netflix/Fenzo/wiki/Scheduling-Tasks" rel="external nofollow noopener noreferrer" target="_blank">《Fenzo Wiki —— Scheduling Tasks》</a></li><li><a href="https://github.com/Netflix/Fenzo/wiki/Insights#how-to-learn-which-tasks-are-assigned-to-which-hosts" rel="external nofollow noopener noreferrer" target="_blank">《Fenzo Wiki —— How to Learn Which Tasks Are Assigned to Which Hosts》</a></li></ul><h2 id="4-4-创建-Mesos-任务信息"><a href="#4-4-创建-Mesos-任务信息" class="headerlink" title="4.4 创建 Mesos 任务信息"></a>4.4 创建 Mesos 任务信息</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// #runOneIteration()</span></div><div class="line">List&lt;TaskContext&gt; taskContextsList = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">// 任务运行时上下文集合</span></div><div class="line">Map&lt;List&lt;Protos.OfferID&gt;, List&lt;Protos.TaskInfo&gt;&gt; offerIdTaskInfoMap = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// Mesos 任务信息集合</span></div><div class="line"><span class="keyword">for</span> (VMAssignmentResult each: vmAssignmentResults) &#123;</div><div class="line">    List&lt;VirtualMachineLease&gt; leasesUsed = each.getLeasesUsed();</div><div class="line">    List&lt;Protos.TaskInfo&gt; taskInfoList = <span class="keyword">new</span> ArrayList&lt;&gt;(each.getTasksAssigned().size() * <span class="number">10</span>);</div><div class="line">    taskInfoList.addAll(getTaskInfoList(</div><div class="line">            launchingTasks.getIntegrityViolationJobs(vmAssignmentResults), <span class="comment">// 获得作业分片不完整的作业集合</span></div><div class="line">            each, leasesUsed.get(<span class="number">0</span>).hostname(), leasesUsed.get(<span class="number">0</span>).getOffer()));</div><div class="line">    <span class="keyword">for</span> (Protos.TaskInfo taskInfo : taskInfoList) &#123;</div><div class="line">        taskContextsList.add(TaskContext.from(taskInfo.getTaskId().getValue()));</div><div class="line">    &#125;</div><div class="line">    offerIdTaskInfoMap.put(getOfferIDs(leasesUsed), <span class="comment">// 获得 Offer ID 集合</span></div><div class="line">            taskInfoList);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p><code>offerIdTaskInfoMap</code>，Mesos 任务信息集合。key 和 value 都为相同 Mesos Slave Offer 和 任务。为什么？调用 <code>SchedulerDriver#launchTasks(...)</code> 方法提交<strong>一次</strong>任务时，必须保证所有任务和 Offer 在相同 Mesos Slave 上。</p><blockquote><p>FROM FROM <a href="http://product.dangdang.com/24187450.html" rel="external nofollow noopener noreferrer" target="_blank">《Mesos 框架构建分布式应用》</a> P61<br><strong>组合 offer</strong><br>latchTasks 接受 offer 列表为输入，这就允许用户将一些相同 slave 的 offer 组合起来，从而将这些 offer 的资源放到池里。它还能接受任务列表为输入，这样就能够启动适合给定 offer 的足够多的任务。注意所有任务和 offer 都必须是同一台 slave —— 如果不在同一台 slave 上，launchTasks 就会失败。如果想在多台 slave 上启动任务，多次调用 latchTasks 即可。</p></blockquote></li><li><p>调用 <code>LaunchingTasks#getIntegrityViolationJobs(...)</code> 方法，获得作业分片不完整的作业集合。<strong>一个作业有多个分片，因为 Mesos Offer 不足，导致有部分分片不能执行，则整个作业都不进行执行</strong>。代码实现如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LaunchingTasks.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获得作业分片不完整的作业集合</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> vmAssignmentResults 主机分配任务结果集合</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 作业分片不完整的作业集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function">Collection&lt;String&gt; <span class="title">getIntegrityViolationJobs</span><span class="params">(<span class="keyword">final</span> Collection&lt;VMAssignmentResult&gt; vmAssignmentResults)</span> </span>&#123;</div><div class="line">   Map&lt;String, Integer&gt; assignedJobShardingTotalCountMap = getAssignedJobShardingTotalCountMap(vmAssignmentResults);</div><div class="line">   Collection&lt;String&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(assignedJobShardingTotalCountMap.size(), <span class="number">1</span>);</div><div class="line">   <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : assignedJobShardingTotalCountMap.entrySet()) &#123;</div><div class="line">       JobContext jobContext = eligibleJobContextsMap.get(entry.getKey());</div><div class="line">       <span class="keyword">if</span> (ExecutionType.FAILOVER != jobContext.getType() <span class="comment">// 不包括 FAILOVER 执行类型的作业</span></div><div class="line">               &amp;&amp; !entry.getValue().equals(jobContext.getJobConfig().getTypeConfig().getCoreConfig().getShardingTotalCount())) &#123;</div><div class="line">           log.warn(<span class="string">"Job &#123;&#125; is not assigned at this time, because resources not enough to run all sharding instances."</span>, entry.getKey());</div><div class="line">           result.add(entry.getKey());</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获得每个作业分片数集合</span></div><div class="line"><span class="comment">* key：作业名</span></div><div class="line"><span class="comment">* value：分片总数</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> vmAssignmentResults 主机分配任务结果集合</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 每个作业分片数集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> Map&lt;String, Integer&gt; <span class="title">getAssignedJobShardingTotalCountMap</span><span class="params">(<span class="keyword">final</span> Collection&lt;VMAssignmentResult&gt; vmAssignmentResults)</span> </span>&#123;</div><div class="line">   Map&lt;String, Integer&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;(eligibleJobContextsMap.size(), <span class="number">1</span>);</div><div class="line">   <span class="keyword">for</span> (VMAssignmentResult vmAssignmentResult: vmAssignmentResults) &#123;</div><div class="line">       <span class="keyword">for</span> (TaskAssignmentResult tasksAssigned: vmAssignmentResult.getTasksAssigned()) &#123;</div><div class="line">           String jobName = TaskContext.from(tasksAssigned.getTaskId()).getMetaInfo().getJobName();</div><div class="line">           <span class="keyword">if</span> (result.containsKey(jobName)) &#123;</div><div class="line">               result.put(jobName, result.get(jobName) + <span class="number">1</span>);</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               result.put(jobName, <span class="number">1</span>);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><ul><li><p>调用 <code>#getTaskInfoList(...)</code> 方法，创建<strong>单个主机</strong>的 Mesos 任务信息集合。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> List&lt;Protos.TaskInfo&gt; getTaskInfoList(<span class="keyword">final</span> Collection&lt;String&gt; integrityViolationJobs, <span class="keyword">final</span> VMAssignmentResult vmAssignmentResult, <span class="keyword">final</span> String hostname, <span class="keyword">final</span> Protos.Offer offer) &#123;</div><div class="line">   List&lt;Protos.TaskInfo&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(vmAssignmentResult.getTasksAssigned().size());</div><div class="line">   <span class="keyword">for</span> (TaskAssignmentResult each: vmAssignmentResult.getTasksAssigned()) &#123;</div><div class="line">       TaskContext taskContext = TaskContext.from(each.getTaskId());</div><div class="line">       String jobName = taskContext.getMetaInfo().getJobName();</div><div class="line">       <span class="keyword">if</span> (!integrityViolationJobs.contains(jobName) <span class="comment">// 排除作业分片不完整的任务</span></div><div class="line">               &amp;&amp; !facadeService.isRunning(taskContext) <span class="comment">// 排除正在运行中的任务</span></div><div class="line">               &amp;&amp; !facadeService.isJobDisabled(jobName)) &#123; <span class="comment">// 排除被禁用的任务</span></div><div class="line">           <span class="comment">// 创建 Mesos 任务</span></div><div class="line">           Protos.TaskInfo taskInfo = getTaskInfo(offer, each);</div><div class="line">           <span class="keyword">if</span> (<span class="keyword">null</span> != taskInfo) &#123;</div><div class="line">               result.add(taskInfo);</div><div class="line">               <span class="comment">// 添加任务主键和主机名称的映射</span></div><div class="line">               facadeService.addMapping(taskInfo.getTaskId().getValue(), hostname);</div><div class="line">               <span class="comment">// 通知 TaskScheduler 主机分配了这个任务</span></div><div class="line">               taskScheduler.getTaskAssigner().call(each.getRequest(), hostname);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>#getTaskInfo(...)</code> 方法，创建单个 Mesos 任务，在<a href="#">「4.4.1 创建单个 Mesos 任务信息」</a>详细解析。</li><li><p>调用 <code>FacadeService#addMapping(...)</code> 方法，添加任务主键和主机名称的映射。通过该映射，可以根据任务主键查询到对应的主机名。实现代码如下：</p> <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// FacadeService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 添加任务主键和主机名称的映射.</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> taskId 任务主键</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> hostname 主机名称</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMapping</span><span class="params">(<span class="keyword">final</span> String taskId, <span class="keyword">final</span> String hostname)</span> </span>&#123;</div><div class="line">   runningService.addMapping(taskId, hostname);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// RunningService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 任务主键和主机名称的映射</span></div><div class="line"><span class="comment">* key: 任务主键</span></div><div class="line"><span class="comment">* value: 主机名称</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, String&gt; TASK_HOSTNAME_MAPPER = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(TASK_INITIAL_SIZE);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMapping</span><span class="params">(<span class="keyword">final</span> String taskId, <span class="keyword">final</span> String hostname)</span> </span>&#123;</div><div class="line">   TASK_HOSTNAME_MAPPER.putIfAbsent(taskId, hostname);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用 <code>TaskScheduler#getTaskAssigner()#call(...)</code> 方法，通知 TaskScheduler 任务被<strong>确认</strong>分配到这个主机。TaskScheduler 做任务和 Offer 的匹配，对哪些任务运行在哪些主机是有依赖的，不然怎么做匹配优化呢。在<a href="https://github.com/Netflix/Fenzo/wiki/How-to-use-Fenzo#notify-the-scheduler-of-assigns-and-unassigns-of-tasks" rel="external nofollow noopener noreferrer" target="_blank">《Fenzo Wiki —— Notify the Scheduler of Assigns and UnAssigns of Tasks》</a>可以进一步了解。</p></li></ul></li><li><p>调用 <code>#getOfferIDs(...)</code> 方法，获得 Offer ID 集合。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> List&lt;Protos.OfferID&gt; getOfferIDs(<span class="keyword">final</span> List&lt;VirtualMachineLease&gt; leasesUsed) &#123;</div><div class="line">   List&lt;Protos.OfferID&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">   <span class="keyword">for</span> (VirtualMachineLease virtualMachineLease: leasesUsed) &#123;</div><div class="line">       result.add(virtualMachineLease.getOffer().getId());</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h3 id="4-4-1-创建单个-Mesos-任务信息"><a href="#4-4-1-创建单个-Mesos-任务信息" class="headerlink" title="4.4.1 创建单个 Mesos 任务信息"></a>4.4.1 创建单个 Mesos 任务信息</h3><p>调用 <code>#getTaskInfo()</code> 方法，创建单个 Mesos 任务信息。实现代码如下：</p><p><strong>如下会涉及大量的 Mesos API</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> Protos.<span class="function">TaskInfo <span class="title">getTaskInfo</span><span class="params">(<span class="keyword">final</span> Protos.Offer offer, <span class="keyword">final</span> TaskAssignmentResult taskAssignmentResult)</span> </span>&#123;</div><div class="line">   <span class="comment">// 校验 作业配置 是否存在</span></div><div class="line">   TaskContext taskContext = TaskContext.from(taskAssignmentResult.getTaskId());</div><div class="line">   Optional&lt;CloudJobConfiguration&gt; jobConfigOptional = facadeService.load(taskContext.getMetaInfo().getJobName());</div><div class="line">   <span class="keyword">if</span> (!jobConfigOptional.isPresent()) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line">   CloudJobConfiguration jobConfig = jobConfigOptional.get();</div><div class="line">   <span class="comment">// 校验 作业配置 是否存在</span></div><div class="line">   Optional&lt;CloudAppConfiguration&gt; appConfigOptional = facadeService.loadAppConfig(jobConfig.getAppName());</div><div class="line">   <span class="keyword">if</span> (!appConfigOptional.isPresent()) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line">   CloudAppConfiguration appConfig = appConfigOptional.get();</div><div class="line">   <span class="comment">// 设置 Mesos Slave ID</span></div><div class="line">   taskContext.setSlaveId(offer.getSlaveId().getValue());</div><div class="line">   <span class="comment">// 获得 分片上下文集合</span></div><div class="line">   ShardingContexts shardingContexts = getShardingContexts(taskContext, appConfig, jobConfig);</div><div class="line">   <span class="comment">// 瞬时的脚本作业，使用 Mesos 命令行执行，无需使用执行器</span></div><div class="line">   <span class="keyword">boolean</span> isCommandExecutor = CloudJobExecutionType.TRANSIENT == jobConfig.getJobExecutionType() &amp;&amp; JobType.SCRIPT == jobConfig.getTypeConfig().getJobType();</div><div class="line">   String script = appConfig.getBootstrapScript();</div><div class="line">   <span class="keyword">if</span> (isCommandExecutor) &#123;</div><div class="line">       script = ((ScriptJobConfiguration) jobConfig.getTypeConfig()).getScriptCommandLine();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 创建 启动命令</span></div><div class="line">   Protos.CommandInfo.URI uri = buildURI(appConfig, isCommandExecutor);</div><div class="line">   Protos.CommandInfo command = buildCommand(uri, script, shardingContexts, isCommandExecutor);</div><div class="line">   <span class="comment">// 创建 Mesos 任务信息</span></div><div class="line">   <span class="keyword">if</span> (isCommandExecutor) &#123;</div><div class="line">       <span class="keyword">return</span> buildCommandExecutorTaskInfo(taskContext, jobConfig, shardingContexts, offer, command);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">return</span> buildCustomizedExecutorTaskInfo(taskContext, appConfig, jobConfig, shardingContexts, offer, command);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>#getShardingContexts(...)</code> 方法， 获得分片上下文集合。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> ShardingContexts <span class="title">getShardingContexts</span><span class="params">(<span class="keyword">final</span> TaskContext taskContext, <span class="keyword">final</span> CloudAppConfiguration appConfig, <span class="keyword">final</span> CloudJobConfiguration jobConfig)</span> </span>&#123;</div><div class="line">   Map&lt;Integer, String&gt; shardingItemParameters = <span class="keyword">new</span> ShardingItemParameters(jobConfig.getTypeConfig().getCoreConfig().getShardingItemParameters()).getMap();</div><div class="line">   Map&lt;Integer, String&gt; assignedShardingItemParameters = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">1</span>, <span class="number">1</span>);</div><div class="line">   <span class="keyword">int</span> shardingItem = taskContext.getMetaInfo().getShardingItems().get(<span class="number">0</span>); <span class="comment">// 单个作业分片</span></div><div class="line">   assignedShardingItemParameters.put(shardingItem, shardingItemParameters.containsKey(shardingItem) ? shardingItemParameters.get(shardingItem) : <span class="string">""</span>);</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ShardingContexts(taskContext.getId(), jobConfig.getJobName(), jobConfig.getTypeConfig().getCoreConfig().getShardingTotalCount(),</div><div class="line">           jobConfig.getTypeConfig().getCoreConfig().getJobParameter(), assignedShardingItemParameters, appConfig.getEventTraceSamplingCount());</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>当任务为<strong>瞬时</strong>的<strong>脚本</strong>作业时，使用 Mesos Slave 命令行调用即可，无需使用 Elastic-Job-Cloud-Executor。</p></li><li><p>调用 <code>#buildURI(...)</code> 方法，创建执行器的二进制文件下载地址。试下代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> Protos.CommandInfo.<span class="function">URI <span class="title">buildURI</span><span class="params">(<span class="keyword">final</span> CloudAppConfiguration appConfig, <span class="keyword">final</span> <span class="keyword">boolean</span> isCommandExecutor)</span> </span>&#123;</div><div class="line">   Protos.CommandInfo.URI.Builder result = Protos.CommandInfo.URI.newBuilder()</div><div class="line">           .setValue(appConfig.getAppURL())</div><div class="line">           .setCache(appConfig.isAppCacheEnable()); <span class="comment">// cache</span></div><div class="line">   <span class="keyword">if</span> (isCommandExecutor &amp;&amp; !SupportedExtractionType.isExtraction(appConfig.getAppURL())) &#123;</div><div class="line">       result.setExecutable(<span class="keyword">true</span>); <span class="comment">// 是否可执行</span></div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       result.setExtract(<span class="keyword">true</span>); <span class="comment">// 是否需要解压</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result.build();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>云作业应用配置 <code>CloudAppConfiguration.appURL</code> ，通过 Mesos 实现文件的下载。</li><li><p>云作业应用配置 <code>CloudAppConfiguration.appCacheEnable</code>，应用文件下载是否缓存。</p><blockquote><p>FROM <a href="http://product.dangdang.com/24187450.html" rel="external nofollow noopener noreferrer" target="_blank">《Mesos 框架构建分布式应用》</a> P99<br><strong>Fetcher 缓存</strong><br>Mesos 0.23 里发布称为 fetcher 缓存的新功能。fetcher 缓存确保每个 artifact 在每个 slave 只会下载一次，即使多个执行器请求同一个 artifact，也只需要等待单词下载完成即可。</p></blockquote></li></ul></li><li><p>调用 <code>#buildCommand(...)</code> 方法，创建执行器启动命令。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> Protos.<span class="function">CommandInfo <span class="title">buildCommand</span><span class="params">(<span class="keyword">final</span> Protos.CommandInfo.URI uri, <span class="keyword">final</span> String script, <span class="keyword">final</span> ShardingContexts shardingContexts, <span class="keyword">final</span> <span class="keyword">boolean</span> isCommandExecutor)</span> </span>&#123;</div><div class="line">   Protos.CommandInfo.Builder result = Protos.CommandInfo.newBuilder().addUris(uri).setShell(<span class="keyword">true</span>);</div><div class="line">   <span class="keyword">if</span> (isCommandExecutor) &#123;</div><div class="line">       CommandLine commandLine = CommandLine.parse(script);</div><div class="line">       commandLine.addArgument(GsonFactory.getGson().toJson(shardingContexts), <span class="keyword">false</span>);</div><div class="line">       result.setValue(Joiner.on(<span class="string">" "</span>).join(commandLine.getExecutable(), Joiner.on(<span class="string">" "</span>).join(commandLine.getArguments())));</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       result.setValue(script);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result.build();</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><ul><li><p>调用 <code>#buildCommandExecutorTaskInfo(...)</code> 方法，为<strong>瞬时</strong>的<strong>脚本</strong>作业创建 Mesos 任务信息。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> Protos.<span class="function">TaskInfo <span class="title">buildCommandExecutorTaskInfo</span><span class="params">(<span class="keyword">final</span> TaskContext taskContext, <span class="keyword">final</span> CloudJobConfiguration jobConfig, <span class="keyword">final</span> ShardingContexts shardingContexts,</span></span></div><div class="line"><span class="function"><span class="params">                                                    <span class="keyword">final</span> Protos.Offer offer, <span class="keyword">final</span> Protos.CommandInfo command)</span> </span>&#123;</div><div class="line">   Protos.TaskInfo.Builder result = Protos.TaskInfo.newBuilder().setTaskId(Protos.TaskID.newBuilder().setValue(taskContext.getId()).build())</div><div class="line">           .setName(taskContext.getTaskName()).setSlaveId(offer.getSlaveId())</div><div class="line">           .addResources(buildResource(<span class="string">"cpus"</span>, jobConfig.getCpuCount(), offer.getResourcesList()))</div><div class="line">           .addResources(buildResource(<span class="string">"mem"</span>, jobConfig.getMemoryMB(), offer.getResourcesList()))</div><div class="line">           .setData(ByteString.copyFrom(<span class="keyword">new</span> TaskInfoData(shardingContexts, jobConfig).serialize())); <span class="comment">//</span></div><div class="line">   <span class="keyword">return</span> result.setCommand(command).build();</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><ul><li><p>调用 <code>#buildCustomizedExecutorTaskInfo(...)</code> 方法，创建 Mesos 任务信息。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> Protos.<span class="function">TaskInfo <span class="title">buildCustomizedExecutorTaskInfo</span><span class="params">(<span class="keyword">final</span> TaskContext taskContext, <span class="keyword">final</span> CloudAppConfiguration appConfig, <span class="keyword">final</span> CloudJobConfiguration jobConfig, </span></span></div><div class="line"><span class="function"><span class="params">                                                       <span class="keyword">final</span> ShardingContexts shardingContexts, <span class="keyword">final</span> Protos.Offer offer, <span class="keyword">final</span> Protos.CommandInfo command)</span> </span>&#123;</div><div class="line">   Protos.TaskInfo.Builder result = Protos.TaskInfo.newBuilder().setTaskId(Protos.TaskID.newBuilder().setValue(taskContext.getId()).build())</div><div class="line">           .setName(taskContext.getTaskName()).setSlaveId(offer.getSlaveId())</div><div class="line">           .addResources(buildResource(<span class="string">"cpus"</span>, jobConfig.getCpuCount(), offer.getResourcesList()))</div><div class="line">           .addResources(buildResource(<span class="string">"mem"</span>, jobConfig.getMemoryMB(), offer.getResourcesList()))</div><div class="line">           .setData(ByteString.copyFrom(<span class="keyword">new</span> TaskInfoData(shardingContexts, jobConfig).serialize()));</div><div class="line">   <span class="comment">// ExecutorInfo</span></div><div class="line">   Protos.ExecutorInfo.Builder executorBuilder = Protos.ExecutorInfo.newBuilder().setExecutorId(Protos.ExecutorID.newBuilder()</div><div class="line">           .setValue(taskContext.getExecutorId(jobConfig.getAppName()))) <span class="comment">// 执行器 ID</span></div><div class="line">           .setCommand(command)</div><div class="line">           .addResources(buildResource(<span class="string">"cpus"</span>, appConfig.getCpuCount(), offer.getResourcesList()))</div><div class="line">           .addResources(buildResource(<span class="string">"mem"</span>, appConfig.getMemoryMB(), offer.getResourcesList()));</div><div class="line">   <span class="keyword">if</span> (env.getJobEventRdbConfiguration().isPresent()) &#123;</div><div class="line">       executorBuilder.setData(ByteString.copyFrom(SerializationUtils.serialize(env.getJobEventRdbConfigurationMap()))).build();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result.setExecutor(executorBuilder.build()).build();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>Protos.ExecutorInfo.Builder#setValue(...)</code> 方法，设置<strong>执行器编号</strong>。大多数在 Mesos 实现的执行器，一个任务对应一个执行器。而 Elastic-Job-Cloud-Executor 不同于大多数在 Mesos 上的执行器，一个执行器可以对应多个作业。什么意思？在一个 Mesos Slave，<strong>相同</strong>作业应用，只会启动一个 Elastic-Job-Cloud-Scheduler。当该执行器不存在时，启动一个。当该执行器已经存在，复用该执行器。那么是如何实现该功能的呢？<strong>相同</strong>作业应用，在同一个 Mesos Slave，使用相同执行器编号。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 获取任务执行器主键.</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> appName 应用名称</span></div><div class="line"><span class="comment"> * <span class="doctag">@return</span> 任务执行器主键</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getExecutorId</span><span class="params">(<span class="keyword">final</span> String appName)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Joiner.on(DELIMITER).join(appName, slaveId);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul></li></ul><h2 id="4-5-将任务运行时上下文放入运行时队列"><a href="#4-5-将任务运行时上下文放入运行时队列" class="headerlink" title="4.5 将任务运行时上下文放入运行时队列"></a>4.5 将任务运行时上下文放入运行时队列</h2><p>调用 <code>FacadeService#addRunning(...)</code> 方法，将任务运行时上下文放入运行时队列。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// FacadeService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 将任务运行时上下文放入运行时队列.</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> taskContext 任务运行时上下文</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addRunning</span><span class="params">(<span class="keyword">final</span> TaskContext taskContext)</span> </span>&#123;</div><div class="line">   runningService.add(taskContext);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// RunningService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 将任务运行时上下文放入运行时队列.</span></div><div class="line"><span class="comment">* </span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> taskContext 任务运行时上下文</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">final</span> TaskContext taskContext)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (!configurationService.load(taskContext.getMetaInfo().getJobName()).isPresent()) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 添加到运行中的任务集合</span></div><div class="line">   getRunningTasks(taskContext.getMetaInfo().getJobName()).add(taskContext);</div><div class="line">   <span class="comment">// 判断是否为常驻任务</span></div><div class="line">   <span class="keyword">if</span> (!isDaemon(taskContext.getMetaInfo().getJobName())) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 添加到运行中队列</span></div><div class="line">   String runningTaskNodePath = RunningNode.getRunningTaskNodePath(taskContext.getMetaInfo().toString());</div><div class="line">   <span class="keyword">if</span> (!regCenter.isExisted(runningTaskNodePath)) &#123;</div><div class="line">       regCenter.persist(runningTaskNodePath, taskContext.getId());</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// RunningNode.java</span></div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunningNode</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ROOT = StateNode.ROOT + <span class="string">"/running"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RUNNING_JOB = ROOT + <span class="string">"/%s"</span>; <span class="comment">// %s = $&#123;JOB_NAME&#125;</span></div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RUNNING_TASK = RUNNING_JOB + <span class="string">"/%s"</span>; <span class="comment">// %s = $&#123;TASK_META_INFO&#125;。$&#123;TASK_META_INFO&#125;=$&#123;JOB_NAME&#125;@-@$&#123;ITEM_ID&#125;。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>RunningService，任务运行时服务，提供对运行中的任务集合、运行中作业队列的各种操作方法。</li><li><p>调用 <code>#getRunningTasks()</code> 方法，获得<strong>运行中的任务集合</strong>，并将当前任务添加到其中。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Collection&lt;TaskContext&gt; <span class="title">getRunningTasks</span><span class="params">(<span class="keyword">final</span> String jobName)</span> </span>&#123;</div><div class="line">   Set&lt;TaskContext&gt; taskContexts = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</div><div class="line">   Collection&lt;TaskContext&gt; result = RUNNING_TASKS.putIfAbsent(jobName, taskContexts);</div><div class="line">   <span class="keyword">return</span> <span class="keyword">null</span> == result ? taskContexts : result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>  在运维平台，我们可以看到当前任务正在运行中：</p><p>  <img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_21/09.png" alt=""></p></li><li><p>常驻作业会存储在<strong>运行中作业队列</strong>。运行中作业队列存储在注册中心( Zookeeper )的<strong>持久</strong>数据节点 <code>/${NAMESPACE}/state/running/${JOB_NAME}/${TASK_META_INFO}</code>，存储值为任务编号。使用 zkClient 查看如下： </p>  <figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 14] ls /elastic-job-cloud/state/running/test_job_simple</div><div class="line">[test_job_simple@-@0, test_job_simple@-@1, test_job_simple@-@2]</div><div class="line">[zk: localhost:2181(CONNECTED) 15] get /elastic-job-cloud/state/running/test_job_simple/test_job_simple@-@0</div><div class="line">test_job_simple@-@0@-@READY@-@400197d9-76ca-464b-b2f0-e0fba5c2a598-S0@-@9780ed12-9612-45e3-ac14-feb2911896ff</div></pre></td></tr></table></figure></li></ul><h2 id="4-6-从队列中删除已运行的作业"><a href="#4-6-从队列中删除已运行的作业" class="headerlink" title="4.6 从队列中删除已运行的作业"></a>4.6 从队列中删除已运行的作业</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// #runOneIteration()</span></div><div class="line">facadeService.removeLaunchTasksFromQueue(taskContextsList);</div><div class="line"></div><div class="line"><span class="comment">// FacadeService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 从队列中删除已运行的作业.</span></div><div class="line"><span class="comment">* </span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> taskContexts 任务上下文集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeLaunchTasksFromQueue</span><span class="params">(<span class="keyword">final</span> List&lt;TaskContext&gt; taskContexts)</span> </span>&#123;</div><div class="line">   List&lt;TaskContext&gt; failoverTaskContexts = <span class="keyword">new</span> ArrayList&lt;&gt;(taskContexts.size());</div><div class="line">   Collection&lt;String&gt; readyJobNames = <span class="keyword">new</span> HashSet&lt;&gt;(taskContexts.size(), <span class="number">1</span>);</div><div class="line">   <span class="keyword">for</span> (TaskContext each : taskContexts) &#123;</div><div class="line">       <span class="keyword">switch</span> (each.getType()) &#123;</div><div class="line">           <span class="keyword">case</span> FAILOVER:</div><div class="line">               failoverTaskContexts.add(each);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> READY:</div><div class="line">               readyJobNames.add(each.getMetaInfo().getJobName());</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">default</span>:</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 从失效转移队列中删除相关任务</span></div><div class="line">   failoverService.remove(Lists.transform(failoverTaskContexts, <span class="keyword">new</span> Function&lt;TaskContext, TaskContext.MetaInfo&gt;() &#123;</div><div class="line">       </div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="keyword">public</span> TaskContext.<span class="function">MetaInfo <span class="title">apply</span><span class="params">(<span class="keyword">final</span> TaskContext input)</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> input.getMetaInfo();</div><div class="line">       &#125;</div><div class="line">   &#125;));</div><div class="line">   <span class="comment">// 从待执行队列中删除相关作业</span></div><div class="line">   readyService.remove(readyJobNames);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="4-7-提交任务给-Mesos"><a href="#4-7-提交任务给-Mesos" class="headerlink" title="4.7 提交任务给 Mesos"></a>4.7 提交任务给 Mesos</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// #runOneIteration()</span></div><div class="line"><span class="keyword">for</span> (Entry&lt;List&lt;OfferID&gt;, List&lt;TaskInfo&gt;&gt; each : offerIdTaskInfoMap.entrySet()) &#123;</div><div class="line">   schedulerDriver.launchTasks(each.getKey(), each.getValue());</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>SchedulerDriver#launchTasks(...)</code> 方法，提交任务给 Mesos Master。由 Mesos Master 调度任务给 Mesos Slave。Mesos Slave 提交执行器执行任务。</li></ul><h1 id="5-TaskExecutor-执行任务"><a href="#5-TaskExecutor-执行任务" class="headerlink" title="5. TaskExecutor 执行任务"></a>5. TaskExecutor 执行任务</h1><p>TaskExecutor，实现了 Mesos Executor 接口 <code>org.apache.mesos.Executor</code>。执行器的主要职责之一：<strong>执行调度器所请求的任务</strong>。TaskExecutor 接收到 Mesos Slave 提交的任务，调用 <code>#launchTask(...)</code> 方法，处理任务。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DaemonTaskScheduler.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">launchTask</span><span class="params">(<span class="keyword">final</span> ExecutorDriver executorDriver, <span class="keyword">final</span> Protos.TaskInfo taskInfo)</span> </span>&#123;</div><div class="line">   executorService.submit(<span class="keyword">new</span> TaskThread(executorDriver, taskInfo));</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>ExecutorService#submit(...)</code> 方法，提交 TaskThread 到线程池，执行任务。</li></ul><h2 id="5-1-TaskThread"><a href="#5-1-TaskThread" class="headerlink" title="5.1 TaskThread"></a>5.1 TaskThread</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@RequiredArgsConstructor</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">   </div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ExecutorDriver executorDriver;</div><div class="line">   </div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> TaskInfo taskInfo;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="comment">// 更新 Mesos 任务状态，运行中。</span></div><div class="line">       executorDriver.sendStatusUpdate(Protos.TaskStatus.newBuilder().setTaskId(taskInfo.getTaskId()).setState(Protos.TaskState.TASK_RUNNING).build());</div><div class="line">       <span class="comment">//</span></div><div class="line">       Map&lt;String, Object&gt; data = SerializationUtils.deserialize(taskInfo.getData().toByteArray());</div><div class="line">       ShardingContexts shardingContexts = (ShardingContexts) data.get(<span class="string">"shardingContext"</span>);</div><div class="line">       <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">       JobConfigurationContext jobConfig = <span class="keyword">new</span> JobConfigurationContext((Map&lt;String, String&gt;) data.get(<span class="string">"jobConfigContext"</span>));</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           <span class="comment">// 获得 分布式作业</span></div><div class="line">           ElasticJob elasticJob = getElasticJobInstance(jobConfig);</div><div class="line">           <span class="comment">// 调度器提供内部服务的门面对象</span></div><div class="line">           <span class="keyword">final</span> CloudJobFacade jobFacade = <span class="keyword">new</span> CloudJobFacade(shardingContexts, jobConfig, jobEventBus);</div><div class="line">           <span class="comment">// 执行作业</span></div><div class="line">           <span class="keyword">if</span> (jobConfig.isTransient()) &#123;</div><div class="line">               <span class="comment">// 执行作业</span></div><div class="line">               JobExecutorFactory.getJobExecutor(elasticJob, jobFacade).execute();</div><div class="line">               <span class="comment">// 更新 Mesos 任务状态，已完成。</span></div><div class="line">               executorDriver.sendStatusUpdate(Protos.TaskStatus.newBuilder().setTaskId(taskInfo.getTaskId()).setState(Protos.TaskState.TASK_FINISHED).build());</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="comment">// 初始化 常驻作业调度器</span></div><div class="line">               <span class="keyword">new</span> DaemonTaskScheduler(elasticJob, jobConfig, jobFacade, executorDriver, taskInfo.getTaskId()).init();</div><div class="line">           &#125;</div><div class="line">           <span class="comment">// CHECKSTYLE:OFF</span></div><div class="line">       &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable ex) &#123;</div><div class="line">           <span class="comment">// CHECKSTYLE:ON</span></div><div class="line">           log.error(<span class="string">"Elastic-Job-Cloud-Executor error"</span>, ex);</div><div class="line">           executorDriver.sendStatusUpdate(Protos.TaskStatus.newBuilder().setTaskId(taskInfo.getTaskId()).setState(Protos.TaskState.TASK_ERROR).setMessage(ExceptionUtil.transform(ex)).build());</div><div class="line">           executorDriver.stop();</div><div class="line">           <span class="keyword">throw</span> ex;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>从 <code>TaskInfo.data</code> 属性中，可以获得提交任务附带的数据，例如分片上下文集合( ShardingContexts )，内部的作业配置上下文( JobConfigurationContext )。</li><li><p>调用 <code>#getElasticJobInstance()</code> 方法，获得任务需要执行的分布式作业( Elastic-Job )。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> ElasticJob <span class="title">getElasticJobInstance</span><span class="params">(<span class="keyword">final</span> JobConfigurationContext jobConfig)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!Strings.isNullOrEmpty(jobConfig.getBeanName()) &amp;&amp; !Strings.isNullOrEmpty(jobConfig.getApplicationContext())) &#123; <span class="comment">// spring 环境</span></div><div class="line">      <span class="keyword">return</span> getElasticJobBean(jobConfig);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> getElasticJobClass(jobConfig);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 从 Spring 容器中获得作业对象</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> jobConfig 作业配置</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 作业对象</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> ElasticJob <span class="title">getElasticJobBean</span><span class="params">(<span class="keyword">final</span> JobConfigurationContext jobConfig)</span> </span>&#123;</div><div class="line">  String applicationContextFile = jobConfig.getApplicationContext();</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">null</span> == applicationContexts.get(applicationContextFile)) &#123;</div><div class="line">      <span class="keyword">synchronized</span> (applicationContexts) &#123;</div><div class="line">          <span class="keyword">if</span> (<span class="keyword">null</span> == applicationContexts.get(applicationContextFile)) &#123;</div><div class="line">              applicationContexts.put(applicationContextFile, <span class="keyword">new</span> ClassPathXmlApplicationContext(applicationContextFile));</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> (ElasticJob) applicationContexts.get(applicationContextFile).getBean(jobConfig.getBeanName());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 创建作业对象</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> jobConfig 作业配置</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 作业对象</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> ElasticJob <span class="title">getElasticJobClass</span><span class="params">(<span class="keyword">final</span> JobConfigurationContext jobConfig)</span> </span>&#123;</div><div class="line">  String jobClass = jobConfig.getTypeConfig().getJobClass();</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">      Class&lt;?&gt; elasticJobClass = Class.forName(jobClass);</div><div class="line">      <span class="keyword">if</span> (!ElasticJob.class.isAssignableFrom(elasticJobClass)) &#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(<span class="string">"Elastic-Job: Class '%s' must implements ElasticJob interface."</span>, jobClass);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (elasticJobClass != ScriptJob.class) &#123;</div><div class="line">          <span class="keyword">return</span> (ElasticJob) elasticJobClass.newInstance();</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> ReflectiveOperationException ex) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(<span class="string">"Elastic-Job: Class '%s' initialize failure, the error message is '%s'."</span>, jobClass, ex.getMessage());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>当作业是<strong>瞬时</strong>作业时，调用 <code>AbstractElasticJobExecutor#execute(...)</code> 执行作业逻辑，并调用 <code>ExecutorDriver#sendStatusUpdate(...)</code> 发送状态，更新 Mesos 任务已完成( Protos.TaskState.TASK_FINISHED )。<code>AbstractElasticJobExecutor#execute(...)</code> 实现代码，在 Elastic-Job-Lite 和 Elastic-Job-Cloud 基本一致，在<a href="http://www.iocoder.cn/Elastic-Job/job-execute/?self">《Elastic-Job-Lite 源码分析 —— 作业执行》</a>有详细解析。</li><li>当作业是<strong>常驻</strong>作业时，调用 <code>DaemonTaskScheduler#init()</code> 方法，初始化作业调度，在「5.2 DaemonTaskScheduler」详细解析。</li></ul></li></ul><h2 id="5-2-DaemonTaskScheduler"><a href="#5-2-DaemonTaskScheduler" class="headerlink" title="5.2 DaemonTaskScheduler"></a>5.2 DaemonTaskScheduler</h2><p><strong>瞬时</strong>作业，通过 Elastic-Job-Cloud-Scheduler 调度任务，提交 Elastic-Job-Cloud-Executor 执行后，等待 Elastic-Job-Scheduler 进行下次调度。</p><p><strong>常驻</strong>作业，通过 Elastic-Job-Scheduler 提交 Elastic-Job-Cloud-Executor 进行调度。Elastic-Job-Cloud-Executor 使用 DaemonTaskScheduler 不断对常驻作业进行调度而无需 Elastic-Job-Cloud-Scheduler 参与其中。</p><p>这就是<strong>瞬时</strong>作业和<strong>常驻</strong>作业不同之处。</p><p>DaemonTaskScheduler，常驻作业调度器。调用 <code>DaemonTaskScheduler#init()</code> 方法，对<strong>一个</strong>作业初始化调度，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 初始化作业.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// Quartz JobDetail</span></div><div class="line">   JobDetail jobDetail = JobBuilder.newJob(DaemonJob.class)</div><div class="line">           .withIdentity(jobRootConfig.getTypeConfig().getCoreConfig().getJobName()).build();</div><div class="line">   jobDetail.getJobDataMap().put(ELASTIC_JOB_DATA_MAP_KEY, elasticJob);</div><div class="line">   jobDetail.getJobDataMap().put(JOB_FACADE_DATA_MAP_KEY, jobFacade);</div><div class="line">   jobDetail.getJobDataMap().put(EXECUTOR_DRIVER_DATA_MAP_KEY, executorDriver);</div><div class="line">   jobDetail.getJobDataMap().put(TASK_ID_DATA_MAP_KEY, taskId);</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       scheduleJob(initializeScheduler(), jobDetail, taskId.getValue(), jobRootConfig.getTypeConfig().getCoreConfig().getCron());</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SchedulerException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> Scheduler <span class="title">initializeScheduler</span><span class="params">()</span> <span class="keyword">throws</span> SchedulerException </span>&#123;</div><div class="line">   StdSchedulerFactory factory = <span class="keyword">new</span> StdSchedulerFactory();</div><div class="line">   factory.initialize(getBaseQuartzProperties());</div><div class="line">   <span class="keyword">return</span> factory.getScheduler();</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> Properties <span class="title">getBaseQuartzProperties</span><span class="params">()</span> </span>&#123;</div><div class="line">   Properties result = <span class="keyword">new</span> Properties();</div><div class="line">   result.put(<span class="string">"org.quartz.threadPool.class"</span>, org.quartz.simpl.SimpleThreadPool.class.getName());</div><div class="line">   result.put(<span class="string">"org.quartz.threadPool.threadCount"</span>, <span class="string">"1"</span>); <span class="comment">// 线程数：1</span></div><div class="line">   result.put(<span class="string">"org.quartz.scheduler.instanceName"</span>, taskId.getValue());</div><div class="line">   <span class="keyword">if</span> (!jobRootConfig.getTypeConfig().getCoreConfig().isMisfire()) &#123;</div><div class="line">       result.put(<span class="string">"org.quartz.jobStore.misfireThreshold"</span>, <span class="string">"1"</span>);</div><div class="line">   &#125;</div><div class="line">   result.put(<span class="string">"org.quartz.plugin.shutdownhook.class"</span>, ShutdownHookPlugin.class.getName());</div><div class="line">   result.put(<span class="string">"org.quartz.plugin.shutdownhook.cleanShutdown"</span>, Boolean.TRUE.toString());</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleJob</span><span class="params">(<span class="keyword">final</span> Scheduler scheduler, <span class="keyword">final</span> JobDetail jobDetail, <span class="keyword">final</span> String triggerIdentity, <span class="keyword">final</span> String cron)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">if</span> (!scheduler.checkExists(jobDetail.getKey())) &#123;</div><div class="line">           scheduler.scheduleJob(jobDetail, createTrigger(triggerIdentity, cron));</div><div class="line">       &#125;</div><div class="line">       scheduler.start();</div><div class="line">       RUNNING_SCHEDULERS.putIfAbsent(scheduler.getSchedulerName(), scheduler);</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SchedulerException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> CronTrigger <span class="title">createTrigger</span><span class="params">(<span class="keyword">final</span> String triggerIdentity, <span class="keyword">final</span> String cron)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> TriggerBuilder.newTrigger()</div><div class="line">           .withIdentity(triggerIdentity)</div><div class="line">           .withSchedule(CronScheduleBuilder.cronSchedule(cron)</div><div class="line">           .withMisfireHandlingInstructionDoNothing())</div><div class="line">           .build();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>DaemonTaskScheduler 基于 Quartz 实现作业调度。这里大家看下源码，就不啰嗦解释啦。</li><li>JobBuilder#newJob(…) 的参数是 DaemonJob，下文会讲解到。 </li></ul><p><strong>DaemonJob 实现代码</strong>如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</div><div class="line">   </div><div class="line">   <span class="meta">@Setter</span></div><div class="line">   <span class="keyword">private</span> ElasticJob elasticJob;</div><div class="line">   </div><div class="line">   <span class="meta">@Setter</span></div><div class="line">   <span class="keyword">private</span> JobFacade jobFacade;</div><div class="line">   </div><div class="line">   <span class="meta">@Setter</span></div><div class="line">   <span class="keyword">private</span> ExecutorDriver executorDriver;</div><div class="line">    </div><div class="line">   <span class="meta">@Setter</span></div><div class="line">   <span class="keyword">private</span> Protos.TaskID taskId;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</div><div class="line">       ShardingContexts shardingContexts = jobFacade.getShardingContexts();</div><div class="line">       <span class="keyword">int</span> jobEventSamplingCount = shardingContexts.getJobEventSamplingCount();</div><div class="line">       <span class="keyword">int</span> currentJobEventSamplingCount = shardingContexts.getCurrentJobEventSamplingCount();</div><div class="line">       <span class="keyword">if</span> (jobEventSamplingCount &gt; <span class="number">0</span> &amp;&amp; ++currentJobEventSamplingCount &lt; jobEventSamplingCount) &#123;</div><div class="line">           shardingContexts.setCurrentJobEventSamplingCount(currentJobEventSamplingCount);</div><div class="line">           <span class="comment">//</span></div><div class="line">           jobFacade.getShardingContexts().setAllowSendJobEvent(<span class="keyword">false</span>);</div><div class="line">           <span class="comment">// 执行作业</span></div><div class="line">           JobExecutorFactory.getJobExecutor(elasticJob, jobFacade).execute();</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="comment">//</span></div><div class="line">           jobFacade.getShardingContexts().setAllowSendJobEvent(<span class="keyword">true</span>);</div><div class="line">           <span class="comment">//</span></div><div class="line">           executorDriver.sendStatusUpdate(Protos.TaskStatus.newBuilder().setTaskId(taskId).setState(Protos.TaskState.TASK_RUNNING).setMessage(<span class="string">"BEGIN"</span>).build());</div><div class="line">           <span class="comment">// 执行作业</span></div><div class="line">           JobExecutorFactory.getJobExecutor(elasticJob, jobFacade).execute();</div><div class="line">           <span class="comment">//</span></div><div class="line">           executorDriver.sendStatusUpdate(Protos.TaskStatus.newBuilder().setTaskId(taskId).setState(Protos.TaskState.TASK_RUNNING).setMessage(<span class="string">"COMPLETE"</span>).build());</div><div class="line">           <span class="comment">// </span></div><div class="line">           shardingContexts.setCurrentJobEventSamplingCount(<span class="number">0</span>);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>AbstractElasticJobExecutor#execute(...)</code> 执行作业逻辑。<code>AbstractElasticJobExecutor#execute(...)</code> 实现代码，在 Elastic-Job-Lite 和 Elastic-Job-Cloud 基本一致，在<a href="http://www.iocoder.cn/Elastic-Job/job-execute/?self">《Elastic-Job-Lite 源码分析 —— 作业执行》</a>有详细解析。</li><li><p><code>jobEventSamplingCount</code> 来自应用配置 (<code>CloudAppConfiguration.eventTraceSamplingCount</code>) 属性，常驻作业事件采样率统计条数，默认采样全部记录。为避免数据量过大，可对频繁调度的常驻作业配置采样率，即作业每执行N次，才会记录作业执行及追踪相关数据。</p><p>当满足采样条件时，调用 <code>ShardingContexts#setAllowSendJobEvent(true)</code>，标记<strong>要</strong>记录作业事件。否则，调用 <code>ShardingContexts#setAllowSendJobEvent(false)</code>，标记<strong>不</strong>记录作业时间。作业事件追踪在<a href="http://www.iocoder.cn/Elastic-Job/job-event-trace/?self">《Elastic-Job-Lite 源码分析 —— 作业事件追踪》</a>有详细解析。</p><p>另外，当满足采样调试时，也会调用 <code>ExecutorDriver#sendStatusUpdate(...)</code> 方法，更新 Mesos 任务状态为运行中，并附带 <code>&quot;BEGIN&quot;</code> 或 <code>&quot;COMPLETE&quot;</code> 消息。</p></li></ul><h1 id="6-SchedulerEngine-处理任务的状态变更"><a href="#6-SchedulerEngine-处理任务的状态变更" class="headerlink" title="6. SchedulerEngine 处理任务的状态变更"></a>6. SchedulerEngine 处理任务的状态变更</h1><p>Mesos 调度器的职责之一，<strong>处理任务的状态，特别是响应任务和故障</strong>。因此在 Elastic-Job-Cloud-Executor 调用 <code>ExecutorDriver#sendStatusUpdate(...)</code> 方法，更新 Mesos 任务状态时，触发调用 Elastic-Job-Cloud-Scheduler 的 SchedulerEngine 的 <code>#statusUpdate(...)</code> 方法，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">statusUpdate</span><span class="params">(<span class="keyword">final</span> SchedulerDriver schedulerDriver, <span class="keyword">final</span> Protos.TaskStatus taskStatus)</span> </span>&#123;</div><div class="line">   String taskId = taskStatus.getTaskId().getValue();</div><div class="line">   TaskContext taskContext = TaskContext.from(taskId);</div><div class="line">   String jobName = taskContext.getMetaInfo().getJobName();</div><div class="line">   log.trace(<span class="string">"call statusUpdate task state is: &#123;&#125;, task id is: &#123;&#125;"</span>, taskStatus.getState(), taskId);</div><div class="line">   jobEventBus.post(<span class="keyword">new</span> JobStatusTraceEvent(jobName, taskContext.getId(), taskContext.getSlaveId(), Source.CLOUD_SCHEDULER, </div><div class="line">           taskContext.getType(), String.valueOf(taskContext.getMetaInfo().getShardingItems()), State.valueOf(taskStatus.getState().name()), taskStatus.getMessage()));</div><div class="line">   <span class="keyword">switch</span> (taskStatus.getState()) &#123;</div><div class="line">       <span class="keyword">case</span> TASK_RUNNING:</div><div class="line">           <span class="keyword">if</span> (!facadeService.load(jobName).isPresent()) &#123;</div><div class="line">               schedulerDriver.killTask(Protos.TaskID.newBuilder().setValue(taskId).build());</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">if</span> (<span class="string">"BEGIN"</span>.equals(taskStatus.getMessage())) &#123;</div><div class="line">               facadeService.updateDaemonStatus(taskContext, <span class="keyword">false</span>);</div><div class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"COMPLETE"</span>.equals(taskStatus.getMessage())) &#123;</div><div class="line">               facadeService.updateDaemonStatus(taskContext, <span class="keyword">true</span>);</div><div class="line">               statisticManager.taskRunSuccessfully();</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       <span class="keyword">case</span> TASK_FINISHED:</div><div class="line">           facadeService.removeRunning(taskContext);</div><div class="line">           unAssignTask(taskId);</div><div class="line">           statisticManager.taskRunSuccessfully();</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       <span class="keyword">case</span> TASK_KILLED:</div><div class="line">           log.warn(<span class="string">"task id is: &#123;&#125;, status is: &#123;&#125;, message is: &#123;&#125;, source is: &#123;&#125;"</span>, taskId, taskStatus.getState(), taskStatus.getMessage(), taskStatus.getSource());</div><div class="line">           facadeService.removeRunning(taskContext);</div><div class="line">           facadeService.addDaemonJobToReadyQueue(jobName);</div><div class="line">           unAssignTask(taskId);</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       <span class="keyword">case</span> TASK_LOST:</div><div class="line">       <span class="keyword">case</span> TASK_DROPPED:</div><div class="line">       <span class="keyword">case</span> TASK_GONE:</div><div class="line">       <span class="keyword">case</span> TASK_GONE_BY_OPERATOR:</div><div class="line">       <span class="keyword">case</span> TASK_FAILED:</div><div class="line">       <span class="keyword">case</span> TASK_ERROR:</div><div class="line">           log.warn(<span class="string">"task id is: &#123;&#125;, status is: &#123;&#125;, message is: &#123;&#125;, source is: &#123;&#125;"</span>, taskId, taskStatus.getState(), taskStatus.getMessage(), taskStatus.getSource());</div><div class="line">           facadeService.removeRunning(taskContext);</div><div class="line">           facadeService.recordFailoverTask(taskContext);</div><div class="line">           unAssignTask(taskId);</div><div class="line">           statisticManager.taskRunFailed();</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       <span class="keyword">case</span> TASK_UNKNOWN:</div><div class="line">       <span class="keyword">case</span> TASK_UNREACHABLE:</div><div class="line">           log.error(<span class="string">"task id is: &#123;&#125;, status is: &#123;&#125;, message is: &#123;&#125;, source is: &#123;&#125;"</span>, taskId, taskStatus.getState(), taskStatus.getMessage(), taskStatus.getSource());</div><div class="line">           statisticManager.taskRunFailed();</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       <span class="keyword">default</span>:</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>当更新 Mesos 任务状态为 <code>TASK_RUNNING</code> 时，根据附带消息为 <code>&quot;BEGIN&quot;</code> 或 <code>&quot;COMPLETE&quot;</code>，分别调用 <code>FacadeService#updateDaemonStatus(false / true)</code> 方法，更新作业闲置状态。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// FacadeService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 更新常驻作业运行状态.</span></div><div class="line"><span class="comment">* </span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> taskContext 任务运行时上下文</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> isIdle 是否空闲</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateDaemonStatus</span><span class="params">(<span class="keyword">final</span> TaskContext taskContext, <span class="keyword">final</span> <span class="keyword">boolean</span> isIdle)</span> </span>&#123;</div><div class="line">   runningService.updateIdle(taskContext, isIdle);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">// RunningService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 更新作业闲置状态.</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> taskContext 任务运行时上下文</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> isIdle 是否闲置</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateIdle</span><span class="params">(<span class="keyword">final</span> TaskContext taskContext, <span class="keyword">final</span> <span class="keyword">boolean</span> isIdle)</span> </span>&#123;</div><div class="line">   <span class="keyword">synchronized</span> (RUNNING_TASKS) &#123;</div><div class="line">       Optional&lt;TaskContext&gt; taskContextOptional = findTask(taskContext);</div><div class="line">       <span class="keyword">if</span> (taskContextOptional.isPresent()) &#123;</div><div class="line">           taskContextOptional.get().setIdle(isIdle);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           add(taskContext);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>  若作业配置不存在时，调用 <code>SchedulerDriver#killTask(...)</code> 方法，杀死该 Mesos 任务。在<a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-second/?self">《Elastic-Job-Cloud 源码分析 —— 作业调度（二）》</a>进一步解析。</p></li><li><p>当更新 Mesos 任务状态为 <code>TASK_FINISHED</code> 时，调用 <code>FacadeService#removeRunning(...)</code> 方法，将任务从运行时队列删除。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// FacadeService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 将任务从运行时队列删除.</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> taskContext 任务运行时上下文</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeRunning</span><span class="params">(<span class="keyword">final</span> TaskContext taskContext)</span> </span>&#123;</div><div class="line">   runningService.remove(taskContext);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// RunningService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 将任务从运行时队列删除.</span></div><div class="line"><span class="comment">* </span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> taskContext 任务运行时上下文</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">final</span> TaskContext taskContext)</span> </span>&#123;</div><div class="line">   <span class="comment">// 移除运行中的任务集合</span></div><div class="line">   getRunningTasks(taskContext.getMetaInfo().getJobName()).remove(taskContext);</div><div class="line">   <span class="comment">// 判断是否为常驻任务</span></div><div class="line">   <span class="keyword">if</span> (!isDaemonOrAbsent(taskContext.getMetaInfo().getJobName())) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 将任务从运行时队列删除</span></div><div class="line">   regCenter.remove(RunningNode.getRunningTaskNodePath(taskContext.getMetaInfo().toString()));</div><div class="line">   String jobRootNode = RunningNode.getRunningJobNodePath(taskContext.getMetaInfo().getJobName());</div><div class="line">   <span class="keyword">if</span> (regCenter.isExisted(jobRootNode) &amp;&amp; regCenter.getChildrenKeys(jobRootNode).isEmpty()) &#123;</div><div class="line">       regCenter.remove(jobRootNode);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>当该作业对应的所有 Mesos 任务状态都更新为 <code>TASK_FINISHED</code> 后，作业可以再次被 Elastic-Job-Cloud-Scheduler 调度。</p><p>调用 <code>#unAssignTask(...)</code> 方法，通知 TaskScheduler 任务被<strong>确认</strong>未分配到这个主机。TaskScheduler 做任务和 Offer 的匹配，对哪些任务运行在哪些主机是有依赖的，不然怎么做匹配优化呢。在<a href="https://github.com/Netflix/Fenzo/wiki/How-to-use-Fenzo#notify-the-scheduler-of-assigns-and-unassigns-of-tasks" rel="external nofollow noopener noreferrer" target="_blank">《Fenzo Wiki —— Notify the Scheduler of Assigns and UnAssigns of Tasks》</a>可以进一步了解。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unAssignTask</span><span class="params">(<span class="keyword">final</span> String taskId)</span> </span>&#123;</div><div class="line">    String hostname = facadeService.popMapping(taskId);</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != hostname) &#123;</div><div class="line">        taskScheduler.getTaskUnAssigner().call(TaskContext.getIdForUnassignedSlave(taskId), hostname);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul></li><li><p>当更新 Mesos 任务状态为 <code>TASK_KILLED</code> 时，调用 <code>FacadeService#addDaemonJobToReadyQueue(...)</code> 方法，将常驻作业放入待执行队列。<strong>为什么要将常驻作业放入待执行队列呢？</strong>被 Kill 掉的作业后续要继续调度执行，如果不加入待执行队列，TaskLaunchScheduledService 就无法提交作业给 Elastic-Job-Cloud-Executor 继续调度执行。</p><p>  另外会调用 <code>FacadeService#removeRunning(...)</code>、<code>#unAssignTask(...)</code> 方法。</p></li><li><p>当更新 Mesos 任务状态为 <code>TASK_ERROR</code> 等等时，调用 <code>FacadeService#recordFailoverTask(...)</code> 方法，在 <a href="http://www.iocoder.cn/Elastic-Job/cloud-job-failover/?self">《Elastic-Job-Cloud 源码分析 —— 作业失效转移》</a>详细解析。</p><p>  另外会调用 <code>FacadeService#removeRunning(...)</code> 和 <code>#unAssignTask(...)</code> 方法。</p></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>旁白君：真的真的真的，好长好长好长啊。但是真的真的真的，干货！<br>芋道君：那必须的！</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_21/12.png" alt=""></p><p>道友，赶紧上车，分享一波朋友圈！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. 作业执行类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;
      
    
    </summary>
    
      <category term="Elastic-Job-Cloud" scheme="http://www.iocoder.cn/categories/Elastic-Job-Cloud/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Cloud 源码分析 —— 作业配置</title>
    <link href="http://www.iocoder.cn/Elastic-Job/cloud-job-config/"/>
    <id>http://www.iocoder.cn/Elastic-Job/cloud-job-config/</id>
    <published>2017-12-13T16:00:00.000Z</published>
    <updated>2017-09-06T10:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p><ul><li><a href="#">1. 概述</a></li><li><a href="#">2. 云作业App</a><ul><li><a href="#">2.1 云作业App配置类</a></li><li><a href="#">2.2 操作云作业App配置</a></li></ul></li><li><a href="#3">3. 云作业</a><ul><li><a href="#">3.1 云作业配置</a><ul><li><a href="#">3.1.1 操作云作业配置</a></li></ul></li><li><a href="#">3.2 本地云作业配置</a></li><li><a href="#">3.3 云作业配置总结</a></li></ul></li><li><a href="#">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Cloud 作业配置</strong>。</p><p>如果你阅读过以下文章，有助于对本文的理解：</p><ul><li><a href="http://elasticjob.io/docs/elastic-job-cloud/02-guide/cloud-restful-api/" rel="external nofollow noopener noreferrer" target="_blank">《官方文档 —— RESTFUL API》</a></li><li><a href="http://www.iocoder.cn/Elastic-Job/job-config/?self">《Elastic-Job-Lite 源码分析 —— 作业配置》</a></li><li><a href="https://segmentfault.com/a/1190000007723430" rel="external nofollow noopener noreferrer" target="_blank">《由浅入深 | 如何优雅地写一个Mesos Framework》</a></li></ul><p>😈 另外，笔者假设你已经对 <strong><a href="http://www.iocoder.cn/categories/Elastic-Job/?self">《Elastic-Job-Lite 源码分析系列》</a></strong> 有一定的了解。</p><p>本文涉及到主体类的类图如下( <a href="http://www.iocoder.cn/images/Elastic-Job/2017_12_14/01.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_14/01.png" alt=""></p><ul><li><strong>黄色</strong>的类在 <code>elastic-job-common-core</code> 项目里，为 Elastic-Job-Lite、Elastic-Job-Cloud <strong>公用</strong>作业配置类。</li><li><strong>紫色</strong>的类在 <code>elastic-job-cloud</code> 项目里，为 Elastic-Job-Cloud 作业配置类。</li><li><strong>红色</strong>的类在 <code>elastic-job-lite</code> 项目里，为 Elastic-Job-Lite 作业配置类。</li></ul><blockquote><p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p></blockquote><h1 id="2-云作业App"><a href="#2-云作业App" class="headerlink" title="2. 云作业App"></a>2. 云作业App</h1><p>首先，理解下 <strong>云作业App</strong> 的定义：</p><blockquote><p>FROM <a href="http://dangdangdotcom.github.io/elastic-job/elastic-job-cloud/02-guide/cloud-concepts/" rel="external nofollow noopener noreferrer" target="_blank">http://dangdangdotcom.github.io/elastic-job/elastic-job-cloud/02-guide/cloud-concepts/</a>      </p><p>作业APP指作业打包部署后的应用，描述了作业启动需要用到的CPU、内存、启动脚本及应用下载路径等基本信息，每个APP可以包含一个或多个作业。</p></blockquote><p>简单来说，一个云作业App可以理解成由多个作业打在一起的 <code>jar</code>。</p><h2 id="2-1-云作业App配置类"><a href="#2-1-云作业App配置类" class="headerlink" title="2.1 云作业App配置类"></a>2.1 云作业App配置类</h2><p>CloudAppConfiguration，云作业App配置。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CloudAppConfiguration</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用名</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String appName;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用包地址</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String appURL;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用启动脚本</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String bootstrapScript;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * cpu 数量</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> cpuCount = <span class="number">1</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 内存 大小</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> memoryMB = <span class="number">128</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 每次执行作业时是否从缓存中读取应用。禁用则每次执行任务均从应用仓库下载应用至本地</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> appCacheEnable = <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 常驻作业事件采样率统计条数，默认不采样全部记录。</span></div><div class="line"><span class="comment">     * 为避免数据量过大，可对频繁调度的常驻作业配置采样率，即作业每执行N次，才会记录作业执行及追踪相关数据</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> eventTraceSamplingCount;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>在 Elastic-Job-Lite 里，打包作业，部署到服务器里启动。而在 Elastic-Job-Cloud 里，打包作业上传至可下载的地址。作业被调度时，Mesos 会从 <code>appURL</code> 下载应用包，使用 <code>bootstrapScript</code> 启动应用进行执行。实际情况会更加复杂一丢丢，在<a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor/?self">《Elastic-Job-Cloud 源码解析 —— 作业调度（一）》</a>详细解析。</li><li><code>cpuCount</code>, <code>memoryMB</code> 配置<strong>云作业App自身占用的资源情况</strong>。其包含的每个作业占用的资源情况，使用作业对应的云作业配置( CloudJobConfiguration ) ，下文也会看到。</li><li><code>appCacheEnable</code>：每次执行作业时是否从缓存中读取应用。禁用则每次执行任务均从应用仓库下载应用至本地。</li><li><code>eventTraceSamplingCount</code>：常驻作业事件采样率统计条数，默认采样全部记录。为避免数据量过大，可对频繁调度的常驻作业配置采样率，即作业每执行N次，才会记录作业执行及追踪相关数据。</li></ul><h2 id="2-2-操作云作业App配置"><a href="#2-2-操作云作业App配置" class="headerlink" title="2.2 操作云作业App配置"></a>2.2 操作云作业App配置</h2><p>云作业App配置有多种操作：</p><ol><li>添加 / 更新 / 删除</li><li>开启 / 禁用</li></ol><p>有两种方式进行操作，以<strong>添加</strong>举例子：</p><ul><li><p>调用 HTTP 接口：</p>  <figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">curl -l -H "Content-type: application/json" -X POST -d '&#123;"appName":"foo_app","appURL":"http://app_host:8080/yourJobs.gz","cpuCount":0.1,"memoryMB":64.0,"bootstrapScript":"bin/start.sh","appCacheEnable":true,"eventTraceSamplingCount":0&#125;' http://elastic_job_cloud_host:8899/api/app</div></pre></td></tr></table></figure></li><li><p>运维平台</p><p>  <img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_14/02.png" alt=""></p></li></ul><p>运维平台是对调用 HTTP 接口的UI封装，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// CloudAppRestfulApi</span></div><div class="line"><span class="meta">@Path</span>(<span class="string">"/app"</span>)</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CloudAppRestfulApi</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 注册应用配置.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> appConfig 应用配置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@POST</span></div><div class="line">    <span class="meta">@Consumes</span>(MediaType.APPLICATION_JSON)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> CloudAppConfiguration appConfig)</span> </span>&#123;</div><div class="line">        Optional&lt;CloudAppConfiguration&gt; appConfigFromZk = appConfigService.load(appConfig.getAppName());</div><div class="line">        <span class="keyword">if</span> (appConfigFromZk.isPresent()) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AppConfigurationException(<span class="string">"app '%s' already existed."</span>, appConfig.getAppName());</div><div class="line">        &#125;</div><div class="line">        appConfigService.add(appConfig);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// CloudAppConfigurationService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 添加云作业APP配置.</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> appConfig 云作业App配置对象</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">final</span> CloudAppConfiguration appConfig)</span> </span>&#123;</div><div class="line">   regCenter.persist(CloudAppConfigurationNode.getRootNodePath(appConfig.getAppName()), CloudAppConfigurationGsonFactory.toJson(appConfig));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// CloudAppConfigurationNode.JAVA</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CloudAppConfigurationNode</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROOT =  <span class="string">"/config/app"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String APP_CONFIG =  ROOT + <span class="string">"/%s"</span>; <span class="comment">// %s = $&#123;APP_NAME&#125;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>CloudAppRestfulApi，云作业应用的REST API，实现了云作业App配置的多种操作的 HTTP 接口。</li><li>CloudAppConfigurationService，云作业App配置服务，实现了云作业应用的存储功能。</li><li>调用 <code>AppConfigService#add(...)</code> 方法，存储 CloudAppConfiguration 到注册中心( Zookeeper )的<strong>持久</strong>数据节点 <code>${NAMESPACE}/config/app/${APP_NAME}</code>，JSON 格式化对象。使用 zkClient 查看如下：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 1] get /elastic-job-cloud/config/app/exampleApp</div><div class="line">&#123;"appName":"exampleApp","appURL":"http://785j8w.com1.z0.glb.clouddn.com/elastic-job-example-cloud-2.1.5.tar.gz","bootstrapScript":"bin/start.sh","cpuCount":1.0,"memoryMB":128.0,"appCacheEnable":true,"eventTraceSamplingCount":0&#125;</div></pre></td></tr></table></figure><h1 id="3-云作业"><a href="#3-云作业" class="headerlink" title="3. 云作业"></a>3. 云作业</h1><p>一个云作业应用可以包含一个或多个云作业。云作业有<strong>两种</strong>作业配置：云作业配置、本地云作业配置。下面来分别分享它们。</p><h2 id="3-1-云作业配置"><a href="#3-1-云作业配置" class="headerlink" title="3.1 云作业配置"></a>3.1 云作业配置</h2><p>CloudJobConfiguration，云作业配置。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CloudJobConfiguration</span> <span class="keyword">implements</span> <span class="title">JobRootConfiguration</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 作业应用名称 &#123;<span class="doctag">@link</span> com.dangdang.ddframe.job.cloud.scheduler.config.app.CloudAppConfiguration&#125;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String appName;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 作业类型配置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobTypeConfiguration typeConfig;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 单片作业所需要的CPU数量，最小值为0.001</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> cpuCount;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 单片作业所需要的内存MB，最小值为1</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> memoryMB;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 作业执行类型</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CloudJobExecutionType jobExecutionType;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Spring容器中配置的bean名称</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String beanName;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Spring方式配置Spring配置文件相对路径以及名称，如：META-INF\applicationContext.xml</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String applicationContext; </div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>JobTypeConfiguration，作业类型配置，在 <code>elastic-job-common-core</code> 项目里，为 Elastic-Job-Lite、Elastic-Job-Cloud <strong>公用</strong>作业配置类。在<a href="http://www.iocoder.cn/Elastic-Job/job-config/?self">《Elastic-Job-Lite 源码分析 —— 作业配置》的「2.2.1 作业类型配置」</a>有详细解析。</li><li><code>cpuCount</code>, <code>memoryMB</code> 配置<strong>单片作业占用的资源情况</strong>。这里一定要注意是单片作业，例如一个作业有三个分片( <code>shardingTotalCount = 3</code> )，则占用资源为 3 <em> <code>cpuCount</code> + 3 </em> <code>memoryMB</code>。</li><li>作业执行类型( CloudJobExecutionType )有两种：常驻作业( DAEMON )，瞬时作业( TRANSIENT )。在<a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor/?self">《Elastic-Job-Cloud 源码解析 —— 作业调度（一）》</a>详细解析。Elastic-Job-Cloud 独有，非常有趣。👍👍👍</li><li><code>beanName</code>, <code>applicationContext</code> 实现 Spring 启动方式作业。在<a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor/?self">《Elastic-Job-Cloud 源码解析 —— 作业调度（一）》</a>有详细解析。</li></ul><h3 id="3-1-1-操作云作业配置"><a href="#3-1-1-操作云作业配置" class="headerlink" title="3.1.1 操作云作业配置"></a>3.1.1 操作云作业配置</h3><p>云作业配置有多种操作：</p><ol><li>添加 / 更新 / 删除</li><li>开启 / 禁用</li></ol><p>有两种方式进行操作，以<strong>添加</strong>举例子：</p><ul><li><p>调用 HTTP 接口：</p>  <figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">// Java启动方式作业注册</div><div class="line">curl -l -H "Content-type: application/json" -X POST -d '&#123;"jobName":"foo_job","appName":"foo_app","jobClass":"yourJobClass","jobType":"SIMPLE","jobExecutionType":"TRANSIENT","cron":"0/5 * * * * ?","shardingTotalCount":5,"cpuCount":0.1,"memoryMB":64.0,"appURL":"http://app_host:8080/foo-job.tar.gz","failover":true,"misfire":true,"bootstrapScript":"bin/start.sh"&#125;' http://elastic_job_cloud_host:8899/api/job/register</div><div class="line"></div><div class="line">// Spring启动方式作业注册</div><div class="line">curl -l -H "Content-type: application/json" -X POST -d '&#123;"jobName":"foo_job","jobClass":"yourJobClass","beanName":"yourBeanName","applicationContext":"applicationContext.xml","jobType":"SIMPLE","jobExecutionType":"TRANSIENT","cron":"0/5 * * * * ?","shardingTotalCount":5,"cpuCount":0.1,"memoryMB":64.0,"appURL":"http://file_host:8080/foo-job.tar.gz","failover":false,"misfire":true,"bootstrapScript":"bin/start.sh"&#125;' http://elastic_job_cloud_masterhost:8899/api/job/register</div></pre></td></tr></table></figure></li><li><p>运维平台</p><p>  <img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_14/03.png" alt=""></p></li></ul><p>运维平台是对调用 HTTP 接口的UI封装，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// CloudJobRestfulApi.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CloudJobRestfulApi</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 注册作业.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> jobConfig 作业配置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@POST</span></div><div class="line">    <span class="meta">@Path</span>(<span class="string">"/register"</span>)</div><div class="line">    <span class="meta">@Consumes</span>(MediaType.APPLICATION_JSON)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> CloudJobConfiguration jobConfig)</span> </span>&#123;</div><div class="line">        producerManager.register(jobConfig);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ProducerManager.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerManager</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 注册作业.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> jobConfig 作业配置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> CloudJobConfiguration jobConfig)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (disableJobService.isDisabled(jobConfig.getJobName())) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JobConfigurationException(<span class="string">"Job '%s' has been disable."</span>, jobConfig.getJobName());</div><div class="line">        &#125;</div><div class="line">        Optional&lt;CloudAppConfiguration&gt; appConfigFromZk = appConfigService.load(jobConfig.getAppName());</div><div class="line">        <span class="keyword">if</span> (!appConfigFromZk.isPresent()) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AppConfigurationException(<span class="string">"Register app '%s' firstly."</span>, jobConfig.getAppName());</div><div class="line">        &#125;</div><div class="line">        Optional&lt;CloudJobConfiguration&gt; jobConfigFromZk = configService.load(jobConfig.getJobName());</div><div class="line">        <span class="keyword">if</span> (jobConfigFromZk.isPresent()) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JobConfigurationException(<span class="string">"Job '%s' already existed."</span>, jobConfig.getJobName());</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 添加云作业配置</span></div><div class="line">        configService.add(jobConfig);</div><div class="line">        <span class="comment">// 调度作业</span></div><div class="line">        schedule(jobConfig);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// CloudJobConfigurationService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 添加云作业配置.</span></div><div class="line"><span class="comment">* </span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> jobConfig 云作业配置对象</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">final</span> CloudJobConfiguration jobConfig)</span> </span>&#123;</div><div class="line">   regCenter.persist(CloudJobConfigurationNode.getRootNodePath(jobConfig.getJobName()), CloudJobConfigurationGsonFactory.toJson(jobConfig));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// CloudJobConfigurationNode.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CloudJobConfigurationNode</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROOT =  <span class="string">"/config/job"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String JOB_CONFIG =  ROOT + <span class="string">"/%s"</span>;  <span class="comment">// %s = $&#123;JOB_NAME&#125;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>CloudJobRestfulApi，作业云Job的REST API，实现了作业云Job配置的多种操作、查询运行中 / 待运行 / 失效转移作业列表等 HTTP 接口。</li><li>ProducerManager，发布任务作业调度管理器。这是一个很重要的类，在<a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor/?self">《Elastic-Job-Cloud 源码解析 —— 作业调度（一）》</a>详细解析。</li><li>CloudJobConfigurationService，作业配置服务，实现了作业配置的存储功能。</li><li><p>调用 <code>CloudJobConfigurationService#add(...)</code> 方法，存储 CloudJobConfiguration 到注册中心( Zookeeper )的<strong>持久</strong>数据节点 <code>${NAMESPACE}/config/job/${JOB_NAME}</code>，JSON 格式化对象。使用 zkClient 查看如下：</p>  <figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">    [zk: localhost:2181(CONNECTED) 3] get /elastic-job-cloud/config/job/test_job_simple</div><div class="line">&#123;"jobName":"test_job_simple","jobClass":"com.dangdang.ddframe.job.example.job.simple.JavaSimpleJob","jobType":"SIMPLE","cron":"0/10 * * * * ?","shardingTotalCount":1,"shardingItemParameters":"","jobParameter":"","failover":false,"misfire":false,"description":"","jobProperties":&#123;"job_exception_handler":"com.dangdang.ddframe.job.executor.handler.impl.DefaultJobExceptionHandler","executor_service_handler":"com.dangdang.ddframe.job.executor.handler.impl.DefaultExecutorServiceHandler"&#125;,"appName":"exampleApp","cpuCount":0.1,"memoryMB":64.0,"jobExecutionType":"TRANSIENT"&#125;</div></pre></td></tr></table></figure></li><li><p>调用 <code>#schedule(...)</code> 方法，调度作业。这是个很有趣的方法，在<a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor/?self">《Elastic-Job-Cloud 源码解析 —— 作业调度（一）》</a>详细解析。</p></li></ul><h2 id="3-2-本地云作业配置"><a href="#3-2-本地云作业配置" class="headerlink" title="3.2 本地云作业配置"></a>3.2 本地云作业配置</h2><p>LocalCloudJobConfiguration，本地云作业配置。实现代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public final class LocalCloudJobConfiguration implements JobRootConfiguration &#123;</div><div class="line">    </div><div class="line">    private final JobTypeConfiguration typeConfig;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 分片作业序号</div><div class="line">     */</div><div class="line">    private final int shardingItem;</div><div class="line">    </div><div class="line">    private String beanName;</div><div class="line">    </div><div class="line">    private String applicationContext;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>shardingItem</code>，分片作业序号，用于本地调试指定分片作业项。</li></ul><p>到底有什么用呢？</p><blockquote><p>在开发Elastic-Job-Cloud作业时，开发人员可以脱离Mesos环境，在本地运行和调试作业。可以利用本地运行模式充分的调试业务功能以及单元测试，完成之后再部署至Mesos集群。<br>本地运行作业无需安装Mesos环境。</p></blockquote><p>在<a href="http://elasticjob.io/docs/elastic-job-cloud/02-guide/local-executor/" rel="external nofollow noopener noreferrer" target="_blank">《官方文档 —— 本地运行模式》</a>有详细解析。</p><h2 id="3-3-云作业配置总结"><a href="#3-3-云作业配置总结" class="headerlink" title="3.3 云作业配置总结"></a>3.3 云作业配置总结</h2><ul><li>CloudJobConfiguration：生产运行使用。</li><li>LocalCloudJobConfiguration：本地开发调试。</li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>芋道君：本文主要为<a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor/?self">《Elastic-Job-Cloud 源码解析 —— 作业调度（一）》</a>做铺垫，这会是一篇长文。读懂 Elastic-Job-Cloud 作业调度后，整个人脑洞又开的不行不行的！<br>旁白君：支持+1024。</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_14/04.png" alt=""></p><p>另外，推荐资料如下，对理解 Elastic-Job-Cloud 很有帮助。</p><ul><li><a href="http://www.infoq.com/cn/news/2016/09/Mesos-Elastic-Job-Cloud" rel="external nofollow noopener noreferrer" target="_blank">《基于Mesos的当当作业云Elastic Job Cloud》</a></li><li><a href="http://www.infoq.com/cn/presentations/how-to-build-elastic-job-cloud" rel="external nofollow noopener noreferrer" target="_blank">《如何从0到1搭建弹性作业云Elastic-Job-Cloud》</a></li></ul><p>道友，赶紧上车，分享一波朋友圈！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. 云作业App&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2
      
    
    </summary>
    
      <category term="Elastic-Job-Cloud" scheme="http://www.iocoder.cn/categories/Elastic-Job-Cloud/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Lite 源码分析 —— 运维平台</title>
    <link href="http://www.iocoder.cn/Elastic-Job/job-console/"/>
    <id>http://www.iocoder.cn/Elastic-Job/job-console/</id>
    <published>2017-12-06T16:00:00.000Z</published>
    <updated>2017-09-06T10:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p><ul><li><a href="#">1. 概述</a></li><li><a href="#">2. Maven模块 elastic-job-common-restful</a></li><li><a href="#">3. Maven模块 elastic-job-console</a></li><li><a href="#">4. Maven模块 elastic-job-lite-lifecycle</a></li><li><a href="#">5. 其它</a></li><li><a href="#">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Lite 运维平台</strong>。内容对应<a href="http://dangdangdotcom.github.io/elastic-job/elastic-job-lite/02-guide/web-console/" rel="external nofollow noopener noreferrer" target="_blank">《官方文档 —— 运维平台》</a>。</p><p>运维平台实现上比较易懂，就不特别<strong>啰嗦</strong>的解析，简略说下每个类的用途和 UI 上的关联。</p><blockquote><p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p></blockquote><h1 id="2-Maven模块-elastic-job-common-restful"><a href="#2-Maven模块-elastic-job-common-restful" class="headerlink" title="2. Maven模块 elastic-job-common-restful"></a>2. Maven模块 elastic-job-common-restful</h1><ol><li>RestfulServer 内嵌服务器，基于 Jetty 实现</li><li>GSONProvider 后端接口 JSON 格式化 </li><li>RestfulExceptionMapper 异常映射</li><li>WwwAuthFilter 授权认证 Filter</li></ol><h1 id="3-Maven模块-elastic-job-console"><a href="#3-Maven模块-elastic-job-console" class="headerlink" title="3. Maven模块 elastic-job-console"></a>3. Maven模块 elastic-job-console</h1><h2 id="3-1-domain-包"><a href="#3-1-domain-包" class="headerlink" title="3.1 domain 包"></a>3.1 domain 包</h2><ul><li>RegistryCenterConfigurations / RegistryCenterConfiguration ：注册中心配置实体相关。</li><li>EventTraceDataSourceConfigurations / EventTraceDataSourceConfiguration / EventTraceDataSource / EventTraceDataSourceFactory ：事件事件追踪数据源配置实体相关。</li></ul><h2 id="3-2-filter-包"><a href="#3-2-filter-包" class="headerlink" title="3.2 filter 包"></a>3.2 filter 包</h2><ul><li>GlobalConfigurationFilter ：全局配置过滤器，加载当前会话( HttpSession ) 选择的 RegistryCenterConfiguration / EventTraceDataSource 。</li></ul><h2 id="3-3-repository-包"><a href="#3-3-repository-包" class="headerlink" title="3.3 repository 包"></a>3.3 repository 包</h2><p>使用 <strong>XML文件</strong> 存储 EventTraceDataSource / RegistryCenterConfiguration 配置实体。</p><h2 id="3-4-restful-包"><a href="#3-4-restful-包" class="headerlink" title="3.4 restful 包"></a>3.4 restful 包</h2><ul><li><p><code>config</code> / RegistryCenterRestfulApi ：注册中心配置( RegistryCenterConfiguration )的RESTful API<br> <img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_07/01.png" alt=""></p></li><li><p><code>config</code> / EventTraceDataSourceRestfulApi ：事件追踪数据源配置( EventTraceDataSource )的RESTful API<br> <img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_07/02.png" alt=""></p></li><li><p><code>config</code> / LiteJobConfigRestfulApi ：作业配置( LiteJobConfiguration )的RESTful API<br> <img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_07/03.png" alt=""></p></li><li><p>EventTraceHistoryRestfulApi ：事件追踪历史记录( <code>JOB_EXECUTION_LOG</code> / <code>JOB_STATUS_TRACE_LOG</code> )的RESTful API<br> <img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_07/06.png" alt=""><br> <img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_07/07.png" alt=""></p></li><li><p>ServerOperationRestfulApi ：服务器维度操作的RESTful API。<br> <img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_07/05.png" alt=""></p></li><li><p>JobOperationRestfulApi ：作业维度操作的RESTful API。<br> <img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_07/04.png" alt=""></p></li></ul><h2 id="3-5-service-包"><a href="#3-5-service-包" class="headerlink" title="3.5 service 包"></a>3.5 service 包</h2><ul><li>RegistryCenterConfigurationService ：注册中心( RegistryCenterConfiguration )配置服务。</li><li>EventTraceDataSourceConfigurationService ：事件追踪数据源配置( EventTraceDataSource )服务。</li><li>JobAPIService ：和作业相关的 API 集合服务。这些 API 在 Maven模块 <code>elastic-job-lite-lifecycle</code> 实现。<ul><li>JobSettingsAPI：作业配置的API。</li><li>JobOperateAPI ：操作作业的API。</li><li>ShardingOperateAPI ：操作分片的API。</li><li>JobStatisticsAPI ：JobStatisticsAPI。</li><li>ServerStatisticsAPI ：作业服务器状态展示的API。</li><li>ShardingStatisticsAPI ：作业分片状态展示的API。</li></ul></li></ul><h1 id="4-Maven模块-elastic-job-lite-lifecycle"><a href="#4-Maven模块-elastic-job-lite-lifecycle" class="headerlink" title="4. Maven模块 elastic-job-lite-lifecycle"></a>4. Maven模块 elastic-job-lite-lifecycle</h1><p>在 JobAPIService 已经基本提到，这里不重复叙述。</p><h1 id="5-其它"><a href="#5-其它" class="headerlink" title="5. 其它"></a>5. 其它</h1><ol><li>前后端分离，后端使用 JSON 为前端提供数据接口。</li><li>后端 API 使用 Restful 设计规范。 </li><li>国际化使用 <code>jquery.i18n.js</code> 实现。</li><li>界面使用 Bootstrap AdminLTE 模板实现。</li></ol><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>旁白君：这写的… 略飘逸（随意）<br>芋道君：哈哈哈，我要开始 Elastic-Job-Cloud 啦啦啦啦。</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_07/08.png" alt=""></p><p>道友，赶紧上车，分享一波朋友圈！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. Maven模块 elastic-job-common-restf
      
    
    </summary>
    
      <category term="Elastic-Job-Lite" scheme="http://www.iocoder.cn/categories/Elastic-Job-Lite/"/>
    
    
  </entry>
  
  <entry>
    <title>闲聊如何阅读源码（音频）</title>
    <link href="http://www.iocoder.cn/Architecture/how-to-read-source-code/"/>
    <id>http://www.iocoder.cn/Architecture/how-to-read-source-code/</id>
    <published>2017-12-01T16:00:00.000Z</published>
    <updated>2017-09-06T10:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-从零开始"><a href="#0-从零开始" class="headerlink" title="0. 从零开始"></a>0. 从零开始</h1><p>一个喝了假酒的视频：</p><p><a href="https://v.qq.com/x/page/p0543tzm648.html" rel="external nofollow noopener noreferrer" target="_blank">视频传送门</a><br><a href="https://v.qq.com/x/page/p0543tzm648.html" rel="external nofollow noopener noreferrer" target="_blank">视频传送门</a><br><a href="https://v.qq.com/x/page/p0543tzm648.html" rel="external nofollow noopener noreferrer" target="_blank">视频传送门</a>  </p><p>请关注笔者的公众号：芋道源码</p><ul><li>专注源码解析三十年！</li><li>专注源码解析三十年！</li><li>专注源码解析三十年！</li><li><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></li></ul><h1 id="1-调试"><a href="#1-调试" class="headerlink" title="1. 调试"></a>1. 调试</h1><p>通过 IDE 工具<strong>调试</strong>的方式阅读源码。</p><h2 id="1-1-Elastic-Job"><a href="#1-1-Elastic-Job" class="headerlink" title="1.1 Elastic-Job"></a>1.1 Elastic-Job</h2><ul><li>GitHub地址：<a href="https://github.com/dangdangdotcom/elastic-job" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/dangdangdotcom/elastic-job</a><ul><li>开源不易，请点 Star 支持。</li><li>个人 Fork，增加部分中文注释 GitHub地址：<a href="https://github.com/YunaiV/elastic-job" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/YunaiV/elastic-job</a></li></ul></li><li>为什么阅读 Elastic-Job 源码？：<a href="http://www.iocoder.cn/Elastic-Job/why-read-Elastic-Job-source-code/">http://www.iocoder.cn/Elastic-Job/why-read-Elastic-Job-source-code/</a></li><li>调试方式：<code>com.dangdang.ddframe.job.example.JavaMain</code> 直接 DEBUG 即可。</li></ul><h2 id="1-2-Sharding-JDBC"><a href="#1-2-Sharding-JDBC" class="headerlink" title="1.2 Sharding-JDBC"></a>1.2 Sharding-JDBC</h2><ul><li>GitHub地址：<a href="https://github.com/dangdangdotcom/sharding-jdbc" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/dangdangdotcom/sharding-jdbc</a><ul><li>开源不易，请点 Star 支持。</li><li>个人 Fork，增加部分中文注释 GitHub地址：<a href="https://github.com/YunaiV/sharding-jdbc" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/YunaiV/sharding-jdbc</a><ul><li>基于 Sharding-JDBC V1.5.1 版本，建议阅读最新版本代码，我的可以作为注释补充。 </li></ul></li></ul></li><li>为什么阅读 Sharding-JDBC 源码？：<a href="http://www.iocoder.cn/Sharding-JDBC/why-read-Sharding-JDBC-source-code/">http://www.iocoder.cn/Sharding-JDBC/why-read-Sharding-JDBC-source-code/</a></li><li>调试方式：<code>com.dangdang.ddframe.rdb.sharding.example.jdbc.Main</code> 配置数据源后可以 DEBUG。</li><li>拆解图：<img src="http://www.iocoder.cn/images/Architecture/2017_12_02/01.png" alt=""></li></ul><h2 id="1-3-MyCAT"><a href="#1-3-MyCAT" class="headerlink" title="1.3 MyCAT"></a>1.3 MyCAT</h2><ul><li>GitHub地址：<a href="https://github.com/MyCATApache/Mycat-Server" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/MyCATApache/Mycat-Server</a><ul><li>开源不易，请点 Star 支持。</li><li>个人 Fork，增加部分中文注释 GitHub地址：<a href="https://github.com/YunaiV/Mycat-Server" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/YunaiV/Mycat-Server</a></li></ul></li><li>为什么阅读 MyCAT 源码？：<a href="http://www.iocoder.cn/MyCAT/why-read-MyCAT-source-code/">http://www.iocoder.cn/MyCAT/why-read-MyCAT-source-code/</a></li><li>调试方式：<a href="http://www.iocoder.cn/MyCAT/build-debugging-environment/">http://www.iocoder.cn/MyCAT/build-debugging-environment/</a></li></ul><h2 id="1-4-RocketMQ"><a href="#1-4-RocketMQ" class="headerlink" title="1.4 RocketMQ"></a>1.4 RocketMQ</h2><ul><li>GitHub地址：<a href="https://github.com/apache/incubator-rocketmq" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubator-rocketmq</a><ul><li>开源不易，请点 Star 支持。</li><li>个人 Fork，增加部分中文注释 GitHub地址：<a href="https://github.com/YunaiV/incubator-rocketmq" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/YunaiV/incubator-rocketmq</a></li></ul></li><li>为什么阅读 RocketMQ 源码？：<a href="http://www.iocoder.cn/RocketMQ/why-read-RocketMQ-source-code/">http://www.iocoder.cn/RocketMQ/why-read-RocketMQ-source-code/</a></li><li>调试方式：有点想不起来了。以后补充哈。</li></ul><h2 id="1-5-补充"><a href="#1-5-补充" class="headerlink" title="1.5 补充"></a>1.5 补充</h2><p>如果源码比较多，你不太清楚按照什么样的功能顺序调试下去，可以参考我写的博客。这个不是广告。确实有朋友是对照着博客顺序调试的。</p><h1 id="2-UML图"><a href="#2-UML图" class="headerlink" title="2. UML图"></a>2. UML图</h1><p>推荐使用 Astah 社区版。对的，不要考虑破解不破解的。社区版，够！</p><p>另外，请不要纠结用什么 UML 工具牛逼！重点先迈出调试源码那一步，其他的，慢慢优化。</p><p>推荐画两种图：</p><ul><li><p>类图：对整体、或者某个模块，有系统性的认识。</p><p>  <img src="http://www.iocoder.cn/images/Architecture/2017_12_02/02.png" alt=""></p></li><li><p>顺序图：对流程的调用顺序有整体的认识，避免调试，越调试越晕。</p><p>  <img src="http://www.iocoder.cn/images/Architecture/2017_12_02/03.png" alt=""></p></li></ul><p>如果你不会画 UML 图，直接直接 Google，不要去找什么 UML 的书，先干起来！</p><p>恩，笔者不排除看 UML 书，因为，我也看过几本，收获不小，哈哈哈哈。</p><h1 id="3-输出"><a href="#3-输出" class="headerlink" title="3. 输出"></a>3. 输出</h1><p>阅读源码，不尝试输出，就是在耍流氓。</p><p>推荐三种输出方式：</p><ol><li>写博客。</li><li>团队分享。</li><li>造小轮。</li></ol><p>刚开始推荐写博客。对的，不太建议只写自己看得懂的笔记。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0-从零开始&quot;&gt;&lt;a href=&quot;#0-从零开始&quot; class=&quot;headerlink&quot; title=&quot;0. 从零开始&quot;&gt;&lt;/a&gt;0. 从零开始&lt;/h1&gt;&lt;p&gt;一个喝了假酒的视频：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://v.qq.com/x/page/p
      
    
    </summary>
    
      <category term="技术杂文" scheme="http://www.iocoder.cn/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E6%96%87/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Lite 源码分析 —— 作业监控服务</title>
    <link href="http://www.iocoder.cn/Elastic-Job/job-monitor/"/>
    <id>http://www.iocoder.cn/Elastic-Job/job-monitor/</id>
    <published>2017-11-30T16:00:00.000Z</published>
    <updated>2017-09-06T10:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p><ul><li><a href="#">1. 概述</a></li><li><a href="#">2. MonitorService</a></li><li><a href="#">3. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Lite 作业监控服务</strong>。内容对应<a href="http://dangdangdotcom.github.io/elastic-job/elastic-job-lite/02-guide/dump/" rel="external nofollow noopener noreferrer" target="_blank">《官方文档 —— DUMP作业运行信息》</a>。</p><blockquote><p>使用Elastic-Job-Lite过程中可能会碰到一些分布式问题，导致作业运行不稳定。<br>由于无法在生产环境调试，通过dump命令可以把作业内部相关信息dump出来，方便开发者debug分析； 另外为了不泄露隐私，已将相关信息中的ip地址以ip1, ip2…的形式过滤，可以在互联网上公开传输环境信息，便于进一步完善Elastic-Job。</p></blockquote><p>涉及到主要类的类图如下( <a href="http://www.iocoder.cn/images/Elastic-Job/2017_12_01/01.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_01/01.png" alt=""></p><ul><li>在 Elastic-Job-lite 里，作业监控服务( MonitorService ) 实现了<strong>DUMP作业运行信息</strong>功能。</li></ul><blockquote><p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p></blockquote><h1 id="2-MonitorService"><a href="#2-MonitorService" class="headerlink" title="2. MonitorService"></a>2. MonitorService</h1><p>MonitorService，作业监控服务。</p><p><strong>初始化 MonitorService 方法实现如下</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// MonitorService.java</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> String jobName;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> port = configService.load(<span class="keyword">true</span>).getMonitorPort();</div><div class="line">   <span class="keyword">if</span> (port &lt; <span class="number">0</span>) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       log.info(<span class="string">"Elastic job: Monitor service is running, the port is '&#123;&#125;'"</span>, port);</div><div class="line">       openSocketForMonitor(port);</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IOException ex) &#123;</div><div class="line">       log.error(<span class="string">"Elastic job: Monitor service listen failure, error is: "</span>, ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openSocketForMonitor</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">   serverSocket = <span class="keyword">new</span> ServerSocket(port);</div><div class="line">   <span class="keyword">new</span> Thread() &#123;</div><div class="line">       </div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">           <span class="keyword">while</span> (!closed) &#123;</div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                   process(serverSocket.accept());</div><div class="line">               &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IOException ex) &#123;</div><div class="line">                   log.error(<span class="string">"Elastic job: Monitor service open socket for monitor failure, error is: "</span>, ex);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>在作业配置的监控服务端口属性( <code>LiteJobConfiguration.monitorPort</code> )启动 <strong>ServerSocket</strong>。一个作业对应一个作业监控端口，所以配置时，请不要重复端口噢。</li></ul><p><strong>处理 dump命令 方法如下</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// MonitorService.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> Socket socket)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">   <span class="keyword">try</span> (</div><div class="line">           BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</div><div class="line">           BufferedWriter writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(socket.getOutputStream()));</div><div class="line">           Socket autoCloseSocket = socket) &#123;</div><div class="line">       <span class="comment">// 读取命令</span></div><div class="line">       String cmdLine = reader.readLine();</div><div class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> != cmdLine &amp;&amp; DUMP_COMMAND.equalsIgnoreCase(cmdLine)) &#123; <span class="comment">// DUMP</span></div><div class="line">           List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">           dumpDirectly(<span class="string">"/"</span> + jobName, result);</div><div class="line">           outputMessage(writer, Joiner.on(<span class="string">"\n"</span>).join(SensitiveInfoUtils.filterSensitiveIps(result)) + <span class="string">"\n"</span>);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>#process()</code> 方法，目前只支持 <code>DUMP</code> 命令。如果你有自定义命令的需要，可以拓展该方法。</li><li><p>调用 <code>#dumpDirectly()</code> 方法，输出当前作业名对应的相关调试信息。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dumpDirectly</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> List&lt;String&gt; result)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (String each : regCenter.getChildrenKeys(path)) &#123;</div><div class="line">       String zkPath = path + <span class="string">"/"</span> + each;</div><div class="line">       String zkValue = regCenter.get(zkPath);</div><div class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> == zkValue) &#123;</div><div class="line">           zkValue = <span class="string">""</span>;</div><div class="line">       &#125;</div><div class="line">       TreeCache treeCache = (TreeCache) regCenter.getRawCache(<span class="string">"/"</span> + jobName);</div><div class="line">       ChildData treeCacheData = treeCache.getCurrentData(zkPath);</div><div class="line">       String treeCachePath =  <span class="keyword">null</span> == treeCacheData ? <span class="string">""</span> : treeCacheData.getPath();</div><div class="line">       String treeCacheValue = <span class="keyword">null</span> == treeCacheData ? <span class="string">""</span> : <span class="keyword">new</span> String(treeCacheData.getData());</div><div class="line">       <span class="comment">// 判断 TreeCache缓存 和 注册中心 数据一致</span></div><div class="line">       <span class="keyword">if</span> (zkValue.equals(treeCacheValue) &amp;&amp; zkPath.equals(treeCachePath)) &#123;</div><div class="line">           result.add(Joiner.on(<span class="string">" | "</span>).join(zkPath, zkValue));</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           result.add(Joiner.on(<span class="string">" | "</span>).join(zkPath, zkValue, treeCachePath, treeCacheValue));</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 递归</span></div><div class="line">       dumpDirectly(zkPath, result);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>当作业本地 <strong>TreeCache缓存</strong> 和注册中心数据不一致时，DUMP 出 [zkPath, zkValue, treeCachePath, treeCacheValue]。当相同时，只需 DUMP 出 [zkPath, zkValue]，<strong>方便看出本地和注册中心是否存在数据差异。</strong></li></ul></li><li><p>DUMP 信息例子如下：</p>  <figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">Yunai-MacdeMacBook-Pro-2:elastic-job yunai$ <span class="built_in">echo</span> <span class="string">"dump"</span> | nc 127.0.0.1 10024</div><div class="line">/javaSimpleJob/sharding | </div><div class="line">/javaSimpleJob/sharding/2 | </div><div class="line">/javaSimpleJob/sharding/2/instance | ip198@-@5100</div><div class="line">/javaSimpleJob/sharding/1 | </div><div class="line">/javaSimpleJob/sharding/1/instance | ip198@-@5100</div><div class="line">/javaSimpleJob/sharding/0 | </div><div class="line">/javaSimpleJob/sharding/0/instance | ip198@-@5100</div><div class="line">/javaSimpleJob/servers | </div><div class="line">/javaSimpleJob/servers/ip2 | </div><div class="line">/javaSimpleJob/servers/ip198 | </div><div class="line">/javaSimpleJob/leader | </div><div class="line">/javaSimpleJob/leader/sharding | </div><div class="line">/javaSimpleJob/leader/failover | </div><div class="line">/javaSimpleJob/leader/failover/latch | </div><div class="line">/javaSimpleJob/leader/failover/items | </div><div class="line">/javaSimpleJob/leader/election | </div><div class="line">/javaSimpleJob/leader/election/latch | </div><div class="line">/javaSimpleJob/leader/election/instance | ip198@-@5100</div><div class="line">/javaSimpleJob/instances | </div><div class="line">/javaSimpleJob/instances/ip198@-@5100 | </div><div class="line">/javaSimpleJob/config | &#123;<span class="string">"jobName"</span>:<span class="string">"javaSimpleJob"</span>,<span class="string">"jobClass"</span>:<span class="string">"com.dangdang.ddframe.job.example.job.simple.JavaSimpleJob"</span>,<span class="string">"jobType"</span>:<span class="string">"SIMPLE"</span>,<span class="string">"cron"</span>:<span class="string">"0 0/2 * * * ?"</span>,<span class="string">"shardingTotalCount"</span>:3,<span class="string">"shardingItemParameters"</span>:<span class="string">"0\u003dBeijing,1\u003dShanghai,2\u003dGuangzhou"</span>,<span class="string">"jobParameter"</span>:<span class="string">""</span>,<span class="string">"failover"</span>:<span class="literal">true</span>,<span class="string">"misfire"</span>:<span class="literal">true</span>,<span class="string">"description"</span>:<span class="string">""</span>,<span class="string">"jobProperties"</span>:&#123;<span class="string">"job_exception_handler"</span>:<span class="string">"com.dangdang.ddframe.job.executor.handler.impl.DefaultJobExceptionHandler"</span>,<span class="string">"executor_service_handler"</span>:<span class="string">"com.dangdang.ddframe.job.executor.handler.impl.DefaultExecutorServiceHandler"</span>&#125;,<span class="string">"monitorExecution"</span>:<span class="literal">false</span>,<span class="string">"maxTimeDiffSeconds"</span>:-1,<span class="string">"monitorPort"</span>:10024,<span class="string">"jobShardingStrategyClass"</span>:<span class="string">"com.dangdang.ddframe.job.lite.api.strategy.impl.OdevitySortByNameJobShardingStrategy"</span>,<span class="string">"reconcileIntervalMinutes"</span>:10,<span class="string">"disabled"</span>:<span class="literal">false</span>,<span class="string">"overwrite"</span>:<span class="literal">true</span>&#125;</div></pre></td></tr></table></figure></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>芋道君：是是是，对对的，我水更啦！😆</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_01/02.png" alt=""></p><p>道友，赶紧上车，分享一波朋友圈！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. MonitorService&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a h
      
    
    </summary>
    
      <category term="Elastic-Job-Lite" scheme="http://www.iocoder.cn/categories/Elastic-Job-Lite/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Lite 源码分析 —— 自诊断修复</title>
    <link href="http://www.iocoder.cn/Elastic-Job/reconcile/"/>
    <id>http://www.iocoder.cn/Elastic-Job/reconcile/</id>
    <published>2017-11-27T16:00:00.000Z</published>
    <updated>2017-09-06T10:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p><ul><li><a href="#">1. 概述</a></li><li><a href="#">2. ReconcileService</a></li><li><a href="#">3. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Lite 自诊断修复</strong>。</p><blockquote><p>在分布式的场景下由于网络、时钟等原因，可能导致 Zookeeper 的数据与真实运行的作业产生不一致，这种不一致通过正向的校验无法完全避免。需要另外启动一个线程定时校验注册中心数据与真实作业状态的一致性，即维持 Elastic-Job 的<strong>最终一致性</strong>。</p></blockquote><p>涉及到主要类的类图如下( <a href="http://www.iocoder.cn/images/Elastic-Job/2017_11_28/01.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_11_28/01.png" alt=""></p><ul><li>在 Elastic-Job-lite 里，调解分布式作业不一致状态服务( ReconcileService ) 实现了<strong>自诊断修复</strong>功能。</li></ul><blockquote><p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p></blockquote><h1 id="2-ReconcileService"><a href="#2-ReconcileService" class="headerlink" title="2. ReconcileService"></a>2. ReconcileService</h1><p>ReconcileService，调解分布式作业不一致状态服务。</p><p>ReconcileService 继承 Google Guava AbstractScheduledService 抽象类，实现 <code>#scheduler()</code>、<code>#runOneIteration()</code> 方法，达到<strong>周期性</strong>校验注册中心数据与真实作业状态的一致性。</p><p><strong><code>#scheduler()</code> 方法实现如下</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ReconcileService.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> Scheduler <span class="title">scheduler</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> Scheduler.newFixedDelaySchedule(<span class="number">0</span>, <span class="number">1</span>, TimeUnit.MINUTES);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>每 1 分钟会调用一次 <code>#runOneIteration()</code> 方法进行校验。</li><li>Google Guava AbstractScheduledService 相关的知识，有兴趣的同学可以自己 Google 学习哟。</li></ul><p><strong><code>#runOneIteration()</code> 方法实现如下</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ReconcileService.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">runOneIteration</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">   LiteJobConfiguration config = configService.load(<span class="keyword">true</span>);</div><div class="line">   <span class="keyword">int</span> reconcileIntervalMinutes = <span class="keyword">null</span> == config ? -<span class="number">1</span> : config.getReconcileIntervalMinutes();</div><div class="line">   <span class="keyword">if</span> (reconcileIntervalMinutes &gt; <span class="number">0</span> &amp;&amp; (System.currentTimeMillis() - lastReconcileTime &gt;= reconcileIntervalMinutes * <span class="number">60</span> * <span class="number">1000</span>)) &#123; <span class="comment">// 校验是否达到校验周期</span></div><div class="line">       <span class="comment">// 设置最后校验时间</span></div><div class="line">       lastReconcileTime = System.currentTimeMillis();</div><div class="line">       <span class="keyword">if</span> (leaderService.isLeaderUntilBlock() <span class="comment">// 主作业节点才可以执行</span></div><div class="line">               &amp;&amp; !shardingService.isNeedSharding() <span class="comment">// 当前作业不需要重新分片</span></div><div class="line">               &amp;&amp; shardingService.hasShardingInfoInOfflineServers()) &#123; <span class="comment">// 查询是包含有分片节点的不在线服务器</span></div><div class="line">           log.warn(<span class="string">"Elastic Job: job status node has inconsistent value,start reconciling..."</span>);</div><div class="line">           <span class="comment">// 设置需要重新分片的标记</span></div><div class="line">           shardingService.setReshardingFlag();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>通过作业配置，设置<strong>修复作业服务器不一致状态服务调度间隔时间</strong>属性( <code>LiteJobConfiguration.reconcileIntervalMinutes</code> )。</li><li>调用 <code>ShardingService#setReshardingFlag()</code> 方法，设置需要重新分片的标记。这个也是 ReconcileService 最本质的行为，有了这个标记后，作业会重新进行分片，<strong>达到作业节点本地分片数据与 Zookeeper 数据一致</strong>。作业分片逻辑，在<a href="http://www.iocoder.cn/Elastic-Job/job-sharding/?self">《Elastic-Job-Lite 源码分析 —— 作业分片》</a>有详细解析。</li><li><p>调解分布式作业不一致状态服务一共有三个条件：</p><ul><li>调用 <code>LeaderService#isLeaderUntilBlock()</code> 方法，判断当前作业节点是否为主节点。在<a href="http://www.iocoder.cn/Elastic-Job/election/?self">《Elastic-Job-Lite 源码分析 —— 主节点选举》</a>有详细解析。</li><li>调用 <code>ShardingService#isNeedSharding()</code> 方法，判断当前作业是否需要重分片。如果需要重新分片，就不要重复设置当前作业需要重新分片的标记。</li><li><p>调用 <code>ShardingService#hasShardingInfoInOfflineServers()</code> 方法，查询是否包含有分片节点的不在线服务器。<strong>永久</strong>数据节点 <code>/${JOB_NAME}/sharding/${ITEM_INDEX}/instance</code> 存储分配的作业节点主键( <code>${JOB_INSTANCE_ID}</code> )， <strong>不会</strong>随着作业节点因为各种原因断开后会话超时移除，而<strong>临时</strong>数据节点<code>/${JOB_NAME}/instances/${JOB_INSTANCE_ID}</code> <strong>会</strong>随着作业节点因为各种原因断开后超时会话超时移除。当查询到包含有分片节点的不在线的作业节点，设置需要重新分片的标记后进行重新分片，将其持有的作业分片分配给其它在线的作业节点。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingService.java</span></div><div class="line"> <span class="comment">/**</span></div><div class="line"><span class="comment"> * 查询是包含有分片节点的不在线服务器.</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * <span class="doctag">@return</span> 是包含有分片节点的不在线服务器</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasShardingInfoInOfflineServers</span><span class="params">()</span> </span>&#123;</div><div class="line">    List&lt;String&gt; onlineInstances = jobNodeStorage.getJobNodeChildrenKeys(InstanceNode.ROOT); <span class="comment">// `/$&#123;JOB_NAME&#125;/instances/$&#123;JOB_INSTANCE_ID&#125;`</span></div><div class="line">    <span class="keyword">int</span> shardingTotalCount = configService.load(<span class="keyword">true</span>).getTypeConfig().getCoreConfig().getShardingTotalCount();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shardingTotalCount; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (!onlineInstances.contains(jobNodeStorage.getJobNodeData(ShardingNode.getInstanceNode(i)))) &#123; <span class="comment">// `/$&#123;JOB_NAME&#125;/sharding/$&#123;ITEM_INDEX&#125;/instance`</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>芋道君：【动作：一脚踢开旁白君】，这是对前面解析的主节点选举和作业分片的复习！不是水更！<br>旁白君：你承认水…【动作：芋道君又来一记千年杀】</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_11_28/02.png" alt=""></p><p>道友，赶紧上车，分享一波朋友圈！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. ReconcileService&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
      
    
    </summary>
    
      <category term="Elastic-Job-Lite" scheme="http://www.iocoder.cn/categories/Elastic-Job-Lite/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Lite 源码分析 —— 作业监听器</title>
    <link href="http://www.iocoder.cn/Elastic-Job/job-listener/"/>
    <id>http://www.iocoder.cn/Elastic-Job/job-listener/</id>
    <published>2017-11-20T16:00:00.000Z</published>
    <updated>2017-09-06T10:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p><ul><li><a href="#">1. 概述</a></li><li><a href="#">2. ElasticJobListener</a></li><li><a href="#">3. AbstractDistributeOnceElasticJobListener</a></li><li><a href="#">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Lite 作业监听器</strong>。</p><p>涉及到主要类的类图如下( <a href="http://www.iocoder.cn/images/Elastic-Job/2017_11_21/01.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_11_21/01.png" alt=""></p><ul><li>绿色<strong>监听器</strong>接口 ElasticJobListener，每台作业节点均执行。</li><li>粉色<strong>监听器</strong>接口 AbstractDistributeOnceElasticJobListener，分布式场景中仅单一节点执行。</li><li>蓝色类在 <code>com.dangdang.ddframe.job.lite.internal.guarantee</code> 里，保证分布式任务全部开始和结束状态。 AbstractDistributeOnceElasticJobListener 通过 <code>guarantee</code> 功能，实现分布式场景中仅单一节点执行。</li></ul><blockquote><p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p></blockquote><h1 id="2-ElasticJobListener"><a href="#2-ElasticJobListener" class="headerlink" title="2. ElasticJobListener"></a>2. ElasticJobListener</h1><p>ElasticJobListener，作业监听器接口，<strong>每台作业节点均执行</strong>。</p><blockquote><p>若作业处理作业服务器的文件，处理完成后删除文件，可考虑使用每个节点均执行清理任务。此类型任务实现简单，且无需考虑全局分布式任务是否完成，请尽量使用此类型监听器。</p></blockquote><p>接口代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ElasticJobListener</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 作业执行前的执行的方法.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> shardingContexts 分片上下文</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">beforeJobExecuted</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts)</span></span>;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 作业执行后的执行的方法.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> shardingContexts 分片上下文</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterJobExecuted</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>调用执行如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// ...省略无关代码</span></div><div class="line">   </div><div class="line">   <span class="comment">// 执行 作业执行前的方法</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       jobFacade.beforeJobExecuted(shardingContexts);</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable cause) &#123;</div><div class="line">       jobExceptionHandler.handleException(jobName, cause);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// ...省略无关代码（执行 普通触发的作业）</span></div><div class="line">   <span class="comment">// ...省略无关代码（执行 被跳过触发的作业）</span></div><div class="line">   <span class="comment">// ...省略无关代码（执行 作业失效转移）</span></div><div class="line">   </div><div class="line">   <span class="comment">// ...执行 作业执行后的方法</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       jobFacade.afterJobExecuted(shardingContexts);</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable cause) &#123;</div><div class="line">       jobExceptionHandler.handleException(jobName, cause);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>JobFacade 对作业监听器简单封装进行调用。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeJobExecuted</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (ElasticJobListener each : elasticJobListeners) &#123;</div><div class="line">       each.beforeJobExecuted(shardingContexts);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterJobExecuted</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (ElasticJobListener each : elasticJobListeners) &#123;</div><div class="line">       each.afterJobExecuted(shardingContexts);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>下文提到的 AbstractDistributeOnceElasticJobListener，也是这么调用。</p></li></ul><h1 id="3-AbstractDistributeOnceElasticJobListener"><a href="#3-AbstractDistributeOnceElasticJobListener" class="headerlink" title="3. AbstractDistributeOnceElasticJobListener"></a>3. AbstractDistributeOnceElasticJobListener</h1><p>AbstractDistributeOnceElasticJobListener，在分布式作业中只执行一次的监听器。</p><blockquote><p>若作业处理数据库数据，处理完成后只需一个节点完成数据清理任务即可。此类型任务处理复杂，需同步分布式环境下作业的状态同步，提供了超时设置来避免作业不同步导致的死锁，请谨慎使用。</p></blockquote><p><strong>创建</strong> AbstractDistributeOnceElasticJobListener 代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDistributeOnceElasticJobListener</span> <span class="keyword">implements</span> <span class="title">ElasticJobListener</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 开始超时时间</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> startedTimeoutMilliseconds;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 开始等待对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object startedWait = <span class="keyword">new</span> Object();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 完成超时时间</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> completedTimeoutMilliseconds;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 完成等待对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object completedWait = <span class="keyword">new</span> Object();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 保证分布式任务全部开始和结束状态的服务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Setter</span></div><div class="line">    <span class="keyword">private</span> GuaranteeService guaranteeService;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> TimeService timeService = <span class="keyword">new</span> TimeService();</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractDistributeOnceElasticJobListener</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> startedTimeoutMilliseconds, <span class="keyword">final</span> <span class="keyword">long</span> completedTimeoutMilliseconds)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (startedTimeoutMilliseconds &lt;= <span class="number">0L</span>) &#123;</div><div class="line">            <span class="keyword">this</span>.startedTimeoutMilliseconds = Long.MAX_VALUE;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">this</span>.startedTimeoutMilliseconds = startedTimeoutMilliseconds;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (completedTimeoutMilliseconds &lt;= <span class="number">0L</span>) &#123;</div><div class="line">            <span class="keyword">this</span>.completedTimeoutMilliseconds = Long.MAX_VALUE; </div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">this</span>.completedTimeoutMilliseconds = completedTimeoutMilliseconds;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>超时参数 <code>startedTimeoutMilliseconds</code>、<code>completedTimeoutMilliseconds</code> 务必传递，避免作业不同步导致的死锁。</li></ul><p>👇下面，我们来看本文的<strong>重点</strong>：AbstractDistributeOnceElasticJobListener，在分布式作业中只执行一次：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">beforeJobExecuted</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts)</span> </span>&#123;</div><div class="line">   <span class="comment">// 注册作业分片项开始运行</span></div><div class="line">   guaranteeService.registerStart(shardingContexts.getShardingItemParameters().keySet());</div><div class="line">   <span class="comment">// 判断是否所有的分片项开始运行</span></div><div class="line">   <span class="keyword">if</span> (guaranteeService.isAllStarted()) &#123;</div><div class="line">       <span class="comment">// 执行</span></div><div class="line">       doBeforeJobExecutedAtLastStarted(shardingContexts);</div><div class="line">       <span class="comment">// 清理启动信息</span></div><div class="line">       guaranteeService.clearAllStartedInfo();</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 等待</span></div><div class="line">   <span class="keyword">long</span> before = timeService.getCurrentMillis();</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">synchronized</span> (startedWait) &#123;</div><div class="line">           startedWait.wait(startedTimeoutMilliseconds);</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> InterruptedException ex) &#123;</div><div class="line">       Thread.interrupted();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 等待超时</span></div><div class="line">   <span class="keyword">if</span> (timeService.getCurrentMillis() - before &gt;= startedTimeoutMilliseconds) &#123;</div><div class="line">       <span class="comment">// 清理启动信息</span></div><div class="line">       guaranteeService.clearAllStartedInfo();</div><div class="line">       handleTimeout(startedTimeoutMilliseconds);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>GuaranteeService#registerStart(...)</code> 方法，注册作业分片项开始运行。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// GuaranteeService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStart</span><span class="params">(<span class="keyword">final</span> Collection&lt;Integer&gt; shardingItems)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> each : shardingItems) &#123;</div><div class="line">       jobNodeStorage.createJobNodeIfNeeded(GuaranteeNode.getStartedNode(each));</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// GuaranteeNode.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GuaranteeNode</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ROOT = <span class="string">"guarantee"</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String STARTED_ROOT = ROOT + <span class="string">"/started"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> String <span class="title">getStartedNode</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> shardingItem)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> Joiner.on(<span class="string">"/"</span>).join(STARTED_ROOT, shardingItem);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>Zookeeper 数据节点 <code>/${JOB_NAME}/guarantee/started/${ITEM_INDEX}</code> 为<strong>永久</strong>节点，存储空串( <code>&quot;&quot;</code> )。为什么是<strong>永久</strong>节点呢？在 <code>GuaranteeService#isAllStarted()</code> 见分晓。</li></ul></li><li><p>调用 <code>GuaranteeService#isAllStarted()</code> 方法，判断是否所有的分片项开始运行。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 判断是否所有的任务均启动完毕.</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 是否所有的任务均启动完毕</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAllStarted</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> jobNodeStorage.isJobNodeExisted(GuaranteeNode.STARTED_ROOT)</div><div class="line">           &amp;&amp; configService.load(<span class="keyword">false</span>).getTypeConfig().getCoreConfig().getShardingTotalCount() == jobNodeStorage.getJobNodeChildrenKeys(GuaranteeNode.STARTED_ROOT).size();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>当 <code>/${JOB_NAME}/guarantee/started/</code> 目录下，所有作业分片项都开始运行，即运行总数等于作业分片总数( <code>JobCoreConfiguration.ShardingTotalCount</code> )，<strong>代表所有的任务均启动完毕</strong>。</li><li>等待所有任务启动过程中，不排除有作业节点会挂掉，如果 <code>/${JOB_NAME}/guarantee/started/${ITEM_INDEX}</code> 存储<strong>临时</strong>节点，会导致不能满足所有的分片项开始运行的条件。</li><li>等待过程中，如果调整作业分片总数( <code>JobCoreConfiguration.ShardingTotalCount</code> )，会导致异常。</li></ul></li><li><p>当不满足所有的分片项开始运行时，作业节点调用 <code>Object#wait(...)</code>  方法进行等待。该等待怎么结束等待？当满足所有的分片项开始运行的作业节点调用 <code>GuaranteeService#clearAllStartedInfo()</code> 时，StartedNodeRemovedJobListener 会监听到 <code>/${JOB_NAME}/guarantee/started/</code> 被删除，调用 <code>Object#notifyAll(...)</code> 方法进行唤醒全部。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// GuaranteeService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 清理所有任务启动信息.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearAllStartedInfo</span><span class="params">()</span> </span>&#123;</div><div class="line">   jobNodeStorage.removeJobNodeIfExisted(GuaranteeNode.STARTED_ROOT);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// StartedNodeRemovedJobListener.java</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StartedNodeRemovedJobListener</span> <span class="keyword">extends</span> <span class="title">AbstractJobListener</span> </span>&#123;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String data)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (Type.NODE_REMOVED == eventType &amp;&amp; guaranteeNode.isStartedRootNode(path)) &#123;</div><div class="line">           <span class="keyword">for</span> (ElasticJobListener each : elasticJobListeners) &#123;</div><div class="line">               <span class="keyword">if</span> (each <span class="keyword">instanceof</span> AbstractDistributeOnceElasticJobListener) &#123;</div><div class="line">                   ((AbstractDistributeOnceElasticJobListener) each).notifyWaitingTaskStart();</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用 <code>#doBeforeJobExecutedAtLastStarted(...)</code> 方法，执行最后一个作业执行前的执行的方法，实现该抽象方法，完成自定义逻辑。<code>#doAfterJobExecutedAtLastCompleted(...)</code> 实现的方式一样，就不重复解析了。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractDistributeOnceElasticJobListener.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 分布式环境中最后一个作业执行前的执行的方法.</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> shardingContexts 分片上下文</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doBeforeJobExecutedAtLastStarted</span><span class="params">(ShardingContexts shardingContexts)</span></span>;</div><div class="line">    </div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 分布式环境中最后一个作业执行后的执行的方法.</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> shardingContexts 分片上下文</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doAfterJobExecutedAtLastCompleted</span><span class="params">(ShardingContexts shardingContexts)</span></span>;</div></pre></td></tr></table></figure></li><li><p>整体流程如下图：<img src="http://www.iocoder.cn/images/Elastic-Job/2017_11_21/02.png" alt="">    </p></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>旁白君：哎哟喂，AbstractDistributeOnceElasticJobListener 还不错哟。<br>芋道君：那必须必的。</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_11_21/03.png" alt=""></p><p>道友，赶紧上车，分享一波朋友圈！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. ElasticJobListener&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="Elastic-Job-Lite" scheme="http://www.iocoder.cn/categories/Elastic-Job-Lite/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Lite 源码分析 —— 作业事件追踪</title>
    <link href="http://www.iocoder.cn/Elastic-Job/job-event-trace/"/>
    <id>http://www.iocoder.cn/Elastic-Job/job-event-trace/</id>
    <published>2017-11-13T16:00:00.000Z</published>
    <updated>2017-09-06T12:09:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p><ul><li><a href="#">1. 概述</a></li><li><a href="#">2. 作业事件总线</a></li><li><a href="#">3. 作业事件</a><ul><li><a href="#">3.1 作业状态追踪事件</a></li><li><a href="#">3.2 作业执行追踪事件</a></li><li><a href="#">3.3 作业事件数据库存储</a></li><li><a href="#">3.4 作业事件数据库查询</a></li></ul></li><li><a href="#">4. 作业监听器</a></li><li><a href="#">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Lite 作业事件追踪</strong>。</p><p>另外，<strong>Elastic-Job-Cloud 作业事件追踪</strong> 和 Elastic-Job-Lite 基本类似，不单独开一篇文章，记录在该文章里。如果你对 Elastic-Job-Cloud 暂时不感兴趣，可以跳过相应部分。</p><p>Elastic-Job 提供了事件追踪功能，可通过事件订阅的方式处理调度过程的重要事件，用于查询、统计和监控。Elastic-Job 目前订阅两种事件，基于<strong>关系型数据库</strong>记录事件。</p><p>涉及到主要类的类图如下( <a href="http://www.iocoder.cn/images/Elastic-Job/2017_11_14/01.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_11_14/01.png" alt=""></p><ul><li>以上类在 <code>com.dangdang.ddframe.job.event</code> 包，不仅为 Elastic-Job-Lite，而且为 Elastic-Job-Cloud 实现了事件追踪功能。</li><li>作业<strong>事件</strong>：粉色的类。</li><li>作业<strong>事件总线</strong>：黄色的类。</li><li>作业<strong>事件监听器</strong>：蓝色的类。 </li></ul><blockquote><p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p></blockquote><h1 id="2-作业事件总线"><a href="#2-作业事件总线" class="headerlink" title="2. 作业事件总线"></a>2. 作业事件总线</h1><p>JobEventBus，作业事件总线，提供了注册监听器、发布事件两个方法。</p><p><strong>创建</strong> JobEventBus 代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobEventBus</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 作业事件配置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobEventConfiguration jobEventConfig;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 线程池执行服务对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorServiceObject executorServiceObject;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 事件总线</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 是否注册作业监听器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isRegistered;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JobEventBus</span><span class="params">()</span> </span>&#123;</div><div class="line">        jobEventConfig = <span class="keyword">null</span>;</div><div class="line">        executorServiceObject = <span class="keyword">null</span>;</div><div class="line">        eventBus = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JobEventBus</span><span class="params">(<span class="keyword">final</span> JobEventConfiguration jobEventConfig)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.jobEventConfig = jobEventConfig;</div><div class="line">        executorServiceObject = <span class="keyword">new</span> ExecutorServiceObject(<span class="string">"job-event"</span>, Runtime.getRuntime().availableProcessors() * <span class="number">2</span>);</div><div class="line">        <span class="comment">// 创建 异步事件总线</span></div><div class="line">        eventBus = <span class="keyword">new</span> AsyncEventBus(executorServiceObject.createExecutorService());</div><div class="line">        <span class="comment">// 注册 事件监听器</span></div><div class="line">        register();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>JobEventBus 基于 <a href="https://github.com/google/guava/wiki/EventBusExplained" rel="external nofollow noopener noreferrer" target="_blank">Google Guava EventBus</a>，在<a href="http://www.iocoder.cn/Sharding-JDBC/sql-execute">《Sharding-JDBC 源码分析 —— SQL 执行》「4.1 EventBus」</a>有详细分享。这里要注意的是 AsyncEventBus( <strong>异步事件总线</strong> )，注册在其上面的监听器是<strong>异步</strong>监听执行，事件发布无需阻塞等待监听器执行完逻辑，所以对性能不存在影响。</li><li><p>使用 JobEventConfiguration( 作业事件配置 ) 创建事件监听器，调用 <code>#register()</code> 方法进行注册监听。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       eventBus.register(jobEventConfig.createJobEventListener());</div><div class="line">       isRegistered = <span class="keyword">true</span>;</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> JobEventListenerConfigurationException ex) &#123;</div><div class="line">       log.error(<span class="string">"Elastic job: create JobEventListener failure, error is: "</span>, ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>该方法是私有( <code>private</code> )方法，只能使用 JobEventConfiguration 创建事件监听器注册。当不传递该配置时，意味着不开启<strong>事件追踪</strong>功能。</li></ul></li></ul><p><strong>发布作业事件</strong></p><p>发布作业事件( JobEvent ) 代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobEventBus.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(<span class="keyword">final</span> JobEvent event)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (isRegistered &amp;&amp; !executorServiceObject.isShutdown()) &#123;</div><div class="line">       eventBus.post(event);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在 Elaistc-Job-Lite 里，LiteJobFacade 对 <code>JobEventBus#post(...)</code> 进行封装，提供给作业执行器( AbstractElasticJobExecutor )调用( Elastic-Job-Cloud 实际也进行了封装 )：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postJobExecutionEvent</span><span class="params">(<span class="keyword">final</span> JobExecutionEvent jobExecutionEvent)</span> </span>&#123;</div><div class="line">   jobEventBus.post(jobExecutionEvent);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postJobStatusTraceEvent</span><span class="params">(<span class="keyword">final</span> String taskId, <span class="keyword">final</span> State state, <span class="keyword">final</span> String message)</span> </span>&#123;</div><div class="line">   TaskContext taskContext = TaskContext.from(taskId);</div><div class="line">   jobEventBus.post(<span class="keyword">new</span> JobStatusTraceEvent(taskContext.getMetaInfo().getJobName(), taskContext.getId(),</div><div class="line">           taskContext.getSlaveId(), Source.LITE_EXECUTOR, taskContext.getType(), taskContext.getMetaInfo().getShardingItems().toString(), state, message));</div><div class="line">   <span class="keyword">if</span> (!Strings.isNullOrEmpty(message)) &#123;</div><div class="line">       log.trace(message);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>TaskContext 通过 <code>#from(...)</code> 方法，对作业任务ID( <code>taskId</code> ) 解析，获取任务上下文。TaskContext 代码注释很完整，点击<a href="https://github.com/dangdangdotcom/elastic-job/blob/8926e94aa7c48dc635a36518da2c4b10194420a5/elastic-job-common/elastic-job-common-core/src/main/java/com/dangdang/ddframe/job/context/TaskContext.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a>直接查看。</li></ul><h1 id="3-作业事件"><a href="#3-作业事件" class="headerlink" title="3. 作业事件"></a>3. 作业事件</h1><p>目前有两种作业事件( JobEvent )：</p><ul><li>JobStatusTraceEvent，作业状态追踪事件。</li><li>JobExecutionEvent，作业执行追踪事件。</li></ul><p>本小节分享两方面：</p><ul><li>作业事件<strong>发布时机</strong>。</li><li>Elastic-Job 基于<strong>关系型数据库</strong>记录事件的<strong>表结构</strong>。</li></ul><h2 id="3-1-作业状态追踪事件"><a href="#3-1-作业状态追踪事件" class="headerlink" title="3.1 作业状态追踪事件"></a>3.1 作业状态追踪事件</h2><p>JobStatusTraceEvent，作业状态追踪事件。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobStatusTraceEvent</span> <span class="keyword">implements</span> <span class="title">JobEvent</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 主键</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String id = UUID.randomUUID().toString();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 作业名称</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String jobName;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 原作业任务ID</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Setter</span></div><div class="line">    <span class="keyword">private</span> String originalTaskId = <span class="string">""</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 作业任务ID</span></div><div class="line"><span class="comment">     * 来自 &#123;<span class="doctag">@link</span> com.dangdang.ddframe.job.executor.ShardingContexts#taskId&#125;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String taskId;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 执行作业服务器的名字</span></div><div class="line"><span class="comment">     * Elastic-Job-Lite，作业节点的 IP 地址</span></div><div class="line"><span class="comment">     * Elastic-Job-Cloud，Mesos 执行机主键</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String slaveId;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 任务来源</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Source source;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 任务执行类型</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutionType executionType;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 作业分片项</span></div><div class="line"><span class="comment">     * 多个分片项以逗号分隔</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String shardingItems;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 任务执行状态</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> State state;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 相关信息</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 记录创建时间</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Date creationTime = <span class="keyword">new</span> Date();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>ExecutionType，执行类型。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ExecutionType &#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 准备执行的任务.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    READY,</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 失效转移的任务.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    FAILOVER</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>Source，任务来源。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Source &#123;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * Elastic-Job-Cloud 调度器</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   CLOUD_SCHEDULER,</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * Elastic-Job-Cloud 执行器</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   CLOUD_EXECUTOR,</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * Elastic-Job-Lite 执行器</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   LITE_EXECUTOR</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>State，任务执行状态。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 开始中</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   TASK_STAGING,</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 运行中</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   TASK_RUNNING,</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 完成（正常）</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   TASK_FINISHED,</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 完成（异常）</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   TASK_ERROR,</div><div class="line">       </div><div class="line">   TASK_KILLED, TASK_LOST, TASK_FAILED,  TASK_DROPPED, TASK_GONE, TASK_GONE_BY_OPERATOR, TASK_UNREACHABLE, TASK_UNKNOWN</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>Elastic-Job-Lite 使用  TASK_STAGING、TASK_RUNNING、TASK_FINISHED、TASK_ERROR 四种执行状态。</li><li>Elastic-Job-Cloud 使用所有执行状态。</li></ul></li></ul><p>关系数据库表 <code>JOB_STATUS_TRACE_LOG</code> 结构如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`JOB_STATUS_TRACE_LOG`</span> (</div><div class="line">  <span class="string">`id`</span> <span class="built_in">varchar</span>(<span class="number">40</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`job_name`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`original_task_id`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`task_id`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`slave_id`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`source`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`execution_type`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`sharding_item`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`state`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`message`</span> <span class="built_in">varchar</span>(<span class="number">4000</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`creation_time`</span> <span class="keyword">timestamp</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</div><div class="line">  <span class="keyword">KEY</span> <span class="string">`TASK_ID_STATE_INDEX`</span> (<span class="string">`task_id`</span>,<span class="string">`state`</span>)</div><div class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COLLATE</span>=utf8_bin</div></pre></td></tr></table></figure><ul><li><p>Elastic-Job-Lite 一次作业执行记录如下( <a href="http://www.iocoder.cn/images/Elastic-Job/2017_11_14/02.png">打开大图</a> )：</p><p>  <img src="http://www.iocoder.cn/images/Elastic-Job/2017_11_14/02.png" alt=""></p></li></ul><p><strong>JobStatusTraceEvent 在 Elastic-Job-Lite 发布时机</strong>：</p><ul><li><p>State.TASK_STAGING：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line">    <span class="comment">// 发布作业状态追踪事件(State.TASK_STAGING)</span></div><div class="line">    <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">        jobFacade.postJobStatusTraceEvent(shardingContexts.getTaskId(), State.TASK_STAGING, String.format(<span class="string">"Job '%s' execute begin."</span>, jobName));</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>State.TASK_RUNNING：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts, <span class="keyword">final</span> JobExecutionEvent.ExecutionSource executionSource)</span> </span>&#123;</div><div class="line">   <span class="comment">// ... 省略无关代码</span></div><div class="line">   <span class="comment">// 发布作业状态追踪事件(State.TASK_RUNNING)</span></div><div class="line">   <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">       jobFacade.postJobStatusTraceEvent(taskId, State.TASK_RUNNING, <span class="string">""</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// ... 省略无关代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>State.TASK_FINISHED、State.TASK_ERROR【第一种】：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line">    <span class="comment">// 跳过 存在运行中的被错过作业</span></div><div class="line">    <span class="keyword">if</span> (jobFacade.misfireIfRunning(shardingContexts.getShardingItemParameters().keySet())) &#123;</div><div class="line">      <span class="comment">// 发布作业状态追踪事件(State.TASK_FINISHED)</span></div><div class="line">      <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">          jobFacade.postJobStatusTraceEvent(shardingContexts.getTaskId(), State.TASK_FINISHED, String.format(</div><div class="line">                  <span class="string">"Previous job '%s' - shardingItems '%s' is still running, misfired job will start after previous job completed."</span>, jobName, </div><div class="line">                  shardingContexts.getShardingItemParameters().keySet()));</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><ul><li><p>State.TASK_FINISHED、State.TASK_ERROR【第二种】：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts, <span class="keyword">final</span> JobExecutionEvent.ExecutionSource executionSource)</span> </span>&#123;</div><div class="line">  <span class="comment">// ... 省略无关代码</span></div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">      process(shardingContexts, executionSource);</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      <span class="comment">// ... 省略无关代码</span></div><div class="line">      <span class="comment">// 根据是否有异常，发布作业状态追踪事件(State.TASK_FINISHED / State.TASK_ERROR)</span></div><div class="line">      <span class="keyword">if</span> (itemErrorMessages.isEmpty()) &#123;</div><div class="line">          <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">              jobFacade.postJobStatusTraceEvent(taskId, State.TASK_FINISHED, <span class="string">""</span>);</div><div class="line">          &#125;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">              jobFacade.postJobStatusTraceEvent(taskId, State.TASK_ERROR, itemErrorMessages.toString());</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p><strong>JobStatusTraceEvent 在 Elastic-Job-Cloud 发布时机</strong>：</p><p>Elastic-Job-Cloud 除了上文 Elastic-Job-Lite 会多一个场景下记录作业状态追踪事件( <strong>State.TASK_STAGING</strong> )，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TaskLaunchScheduledService.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> JobStatusTraceEvent <span class="title">createJobStatusTraceEvent</span><span class="params">(<span class="keyword">final</span> TaskContext taskContext)</span> </span>&#123;</div><div class="line">  TaskContext.MetaInfo metaInfo = taskContext.getMetaInfo();</div><div class="line">  JobStatusTraceEvent result = <span class="keyword">new</span> JobStatusTraceEvent(metaInfo.getJobName(), taskContext.getId(), taskContext.getSlaveId(),</div><div class="line">          Source.CLOUD_SCHEDULER, taskContext.getType(), String.valueOf(metaInfo.getShardingItems()), JobStatusTraceEvent.State.TASK_STAGING, <span class="string">""</span>);</div><div class="line">  <span class="comment">// 失效转移</span></div><div class="line">  <span class="keyword">if</span> (ExecutionType.FAILOVER == taskContext.getType()) &#123;</div><div class="line">      Optional&lt;String&gt; taskContextOptional = facadeService.getFailoverTaskId(metaInfo);</div><div class="line">      <span class="keyword">if</span> (taskContextOptional.isPresent()) &#123;</div><div class="line">          result.setOriginalTaskId(taskContextOptional.get());</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>任务提交调度服务( TaskLaunchScheduledService )提交任务时，记录发布作业状态追踪事件(State.TASK_STAGING)。</li></ul><p>Elastic-Job-Cloud 根据 Mesos Master 通知任务状态变更，记录<strong>多种</strong>作业状态追踪事件，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SchedulerEngine.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">statusUpdate</span><span class="params">(<span class="keyword">final</span> SchedulerDriver schedulerDriver, <span class="keyword">final</span> Protos.TaskStatus taskStatus)</span> </span>&#123;</div><div class="line">   String taskId = taskStatus.getTaskId().getValue();</div><div class="line">   TaskContext taskContext = TaskContext.from(taskId);</div><div class="line">   String jobName = taskContext.getMetaInfo().getJobName();</div><div class="line">   log.trace(<span class="string">"call statusUpdate task state is: &#123;&#125;, task id is: &#123;&#125;"</span>, taskStatus.getState(), taskId);</div><div class="line">   <span class="comment">//</span></div><div class="line">   jobEventBus.post(<span class="keyword">new</span> JobStatusTraceEvent(jobName, taskContext.getId(), taskContext.getSlaveId(), Source.CLOUD_SCHEDULER,</div><div class="line">           taskContext.getType(), String.valueOf(taskContext.getMetaInfo().getShardingItems()), State.valueOf(taskStatus.getState().name()), taskStatus.getMessage()));</div><div class="line">   <span class="comment">// ... 省略无关代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3-2-作业执行追踪事件"><a href="#3-2-作业执行追踪事件" class="headerlink" title="3.2 作业执行追踪事件"></a>3.2 作业执行追踪事件</h2><p>JobExecutionEvent，作业执行追踪事件。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobExecutionEvent</span> <span class="keyword">implements</span> <span class="title">JobEvent</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 主键</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String id = UUID.randomUUID().toString();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 主机名称</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String hostname = IpUtils.getHostName();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * IP</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String ip = IpUtils.getIp();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 作业任务ID</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String taskId;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 作业名字</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String jobName;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 执行来源</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutionSource source;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 作业分片项</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> shardingItem;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 开始时间</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Date startTime = <span class="keyword">new</span> Date();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 结束时间</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Setter</span></div><div class="line">    <span class="keyword">private</span> Date completeTime;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 是否执行成功</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Setter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> success;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 执行失败原因</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Setter</span></div><div class="line">    <span class="keyword">private</span> JobExecutionEventThrowable failureCause;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>ExecutionSource，执行来源</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ExecutionSource &#123;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 普通触发执行</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   NORMAL_TRIGGER,</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 被错过执行</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   MISFIRE,</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 失效转移执行</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   FAILOVER</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p>关系数据库表 <code>JOB_EXECUTION_LOG</code> 结构如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`JOB_EXECUTION_LOG`</span> (</div><div class="line">  <span class="string">`id`</span> <span class="built_in">varchar</span>(<span class="number">40</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`job_name`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`task_id`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`hostname`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`ip`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`sharding_item`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`execution_source`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`failure_cause`</span> <span class="built_in">varchar</span>(<span class="number">4000</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`is_success`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`start_time`</span> <span class="keyword">timestamp</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`complete_time`</span> <span class="keyword">timestamp</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</div><div class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COLLATE</span>=utf8_bin</div></pre></td></tr></table></figure><ul><li><p>Elastic-Job-Lite 一次作业<strong>多作业分片项</strong>执行记录如下( <a href="http://www.iocoder.cn/images/Elastic-Job/2017_11_14/03.png">打开大图</a> )：</p><p>  <img src="http://www.iocoder.cn/images/Elastic-Job/2017_11_14/03.png" alt=""></p></li></ul><p><strong>JobExecutionEvent 在 Elastic-Job-Lite 发布时机</strong>：</p><pre><code><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts, <span class="keyword">final</span> <span class="keyword">int</span> item, <span class="keyword">final</span> JobExecutionEvent startEvent)</span> </span>&#123;</div><div class="line">   <span class="comment">// 发布执行事件(开始)</span></div><div class="line">   <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">       jobFacade.postJobExecutionEvent(startEvent);</div><div class="line">   &#125;</div><div class="line">   JobExecutionEvent completeEvent;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 执行单个作业</span></div><div class="line">       process(<span class="keyword">new</span> ShardingContext(shardingContexts, item));</div><div class="line">       <span class="comment">// 发布执行事件(成功)</span></div><div class="line">       completeEvent = startEvent.executionSuccess();</div><div class="line">       <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">           jobFacade.postJobExecutionEvent(completeEvent);</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable cause) &#123;</div><div class="line">       <span class="comment">// 发布执行事件(失败)</span></div><div class="line">       completeEvent = startEvent.executionFailure(cause);</div><div class="line">       jobFacade.postJobExecutionEvent(completeEvent);</div><div class="line">       <span class="comment">// ... 省略无关代码</span></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><p><strong>JobExecutionEvent 在 Elastic-Job-Cloud 发布时机</strong>：</p><p>和 Elastic-Job-Cloud 一致。</p><h2 id="3-3-作业事件数据库存储"><a href="#3-3-作业事件数据库存储" class="headerlink" title="3.3 作业事件数据库存储"></a>3.3 作业事件数据库存储</h2><p>JobEventRdbStorage，作业事件数据库存储。</p><p><strong>创建</strong> JobEventRdbStorage 代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">JobEventRdbStorage(<span class="keyword">final</span> DataSource dataSource) <span class="keyword">throws</span> SQLException &#123;</div><div class="line">   <span class="keyword">this</span>.dataSource = dataSource;</div><div class="line">   initTablesAndIndexes();</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initTablesAndIndexes</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">try</span> (Connection conn = dataSource.getConnection()) &#123;</div><div class="line">       createJobExecutionTableAndIndexIfNeeded(conn);</div><div class="line">       createJobStatusTraceTableAndIndexIfNeeded(conn);</div><div class="line">       databaseType = DatabaseType.valueFrom(conn.getMetaData().getDatabaseProductName());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>#createJobExecutionTableAndIndexIfNeeded(...)</code> 创建 <code>JOB_EXECUTION_LOG</code> 表和索引。</li><li>调用 <code>#createJobStatusTraceTableAndIndexIfNeeded(...)</code> 创建 <code>JOB_STATUS_TRACE_LOG</code> 表和索引。</li></ul><p><strong>存储</strong> JobStatusTraceEvent 代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobEventRdbStorage.java</span></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addJobStatusTraceEvent</span><span class="params">(<span class="keyword">final</span> JobStatusTraceEvent jobStatusTraceEvent)</span> </span>&#123;</div><div class="line">   String originalTaskId = jobStatusTraceEvent.getOriginalTaskId();</div><div class="line">   <span class="keyword">if</span> (State.TASK_STAGING != jobStatusTraceEvent.getState()) &#123;</div><div class="line">       originalTaskId = getOriginalTaskId(jobStatusTraceEvent.getTaskId());</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</div><div class="line">   String sql = <span class="string">"INSERT INTO `"</span> + TABLE_JOB_STATUS_TRACE_LOG + <span class="string">"` (`id`, `job_name`, `original_task_id`, `task_id`, `slave_id`, `source`, `execution_type`, `sharding_item`,  "</span> </div><div class="line">           + <span class="string">"`state`, `message`, `creation_time`) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);"</span>;</div><div class="line">   <span class="comment">// ... 省略你懂的代码</span></div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getOriginalTaskId</span><span class="params">(<span class="keyword">final</span> String taskId)</span> </span>&#123;</div><div class="line">   String sql = String.format(<span class="string">"SELECT original_task_id FROM %s WHERE task_id = '%s' and state='%s'"</span>, TABLE_JOB_STATUS_TRACE_LOG, taskId, State.TASK_STAGING);</div><div class="line">   <span class="comment">// ... 省略你懂的代码</span></div><div class="line">   <span class="keyword">return</span> original_task_id;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>originalTaskId</code>，原任务作业ID。<ul><li>Elastic-Job-Lite 暂未使用到该字段，存储空串( <code>&quot;&quot;</code> )。</li><li>Elastic-Job-Cloud 在<strong>作业失效转移</strong>场景下使用该字段，存储失效转移的任务作业ID。</li></ul></li></ul><p><strong>存储</strong> JobExecutionEvent 代码如下：     </p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobEventRdbStorage.java</span></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addJobExecutionEvent</span><span class="params">(<span class="keyword">final</span> JobExecutionEvent jobExecutionEvent)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> == jobExecutionEvent.getCompleteTime()) &#123; <span class="comment">// 作业分片项执行开始</span></div><div class="line">       <span class="keyword">return</span> insertJobExecutionEvent(jobExecutionEvent);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">if</span> (jobExecutionEvent.isSuccess()) &#123; <span class="comment">// 作业分片项执行完成（正常）</span></div><div class="line">           <span class="keyword">return</span> updateJobExecutionEventWhenSuccess(jobExecutionEvent);</div><div class="line">       &#125; <span class="keyword">else</span> &#123; <span class="comment">// 作业分片项执行完成（异常）</span></div><div class="line">           <span class="keyword">return</span> updateJobExecutionEventFailure(jobExecutionEvent);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>作业分片项执行完成进行的是<strong>更新</strong>操作。</li></ul><h2 id="3-4-作业事件数据库查询"><a href="#3-4-作业事件数据库查询" class="headerlink" title="3.4 作业事件数据库查询"></a>3.4 作业事件数据库查询</h2><p>JobEventRdbSearch，作业事件数据库查询，提供给运维平台调用查询数据。感兴趣的同学点击<a href="https://github.com/dangdangdotcom/elastic-job/blob/8283acf01548222f39f7bfc202a8f89d27728e6c/elastic-job-common/elastic-job-common-core/src/main/java/com/dangdang/ddframe/job/event/rdb/JobEventRdbSearch.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a>直接查看。</p><h1 id="4-作业监听器"><a href="#4-作业监听器" class="headerlink" title="4. 作业监听器"></a>4. 作业监听器</h1><p>在上文我们看到，作业监听器通过传递作业事件配置( JobEventConfiguration )给作业事件总线( JobEventBus ) <strong>进行创建监听器，并注册监听器到事件总线</strong>。</p><p>我们来看下 Elastic-Job 提供的基于<strong>关系数据库</strong>的事件配置实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobEventConfiguration.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JobEventConfiguration</span> <span class="keyword">extends</span> <span class="title">JobEventIdentity</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 创建作业事件监听器.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 作业事件监听器.</span></div><div class="line"><span class="comment">     * <span class="doctag">@throws</span> JobEventListenerConfigurationException 作业事件监听器配置异常</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">JobEventListener <span class="title">createJobEventListener</span><span class="params">()</span> <span class="keyword">throws</span> JobEventListenerConfigurationException</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// JobEventRdbConfiguration.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobEventRdbConfiguration</span> <span class="keyword">extends</span> <span class="title">JobEventRdbIdentity</span> <span class="keyword">implements</span> <span class="title">JobEventConfiguration</span>, <span class="title">Serializable</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> DataSource dataSource;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> JobEventListener <span class="title">createJobEventListener</span><span class="params">()</span> <span class="keyword">throws</span> JobEventListenerConfigurationException </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JobEventRdbListener(dataSource);</div><div class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JobEventListenerConfigurationException(ex);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>JobEventRdbConfiguration，作业数据库事件配置。调用 <code>#createJobEventListener()</code> 创建作业事件数据库监听器( JobEventRdbListener )。</li></ul><p>JobEventRdbListener，作业事件数据库监听器。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobEventListener.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JobEventListener</span> <span class="keyword">extends</span> <span class="title">JobEventIdentity</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 作业执行事件监听执行.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> jobExecutionEvent 作业执行事件</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Subscribe</span></div><div class="line">    <span class="meta">@AllowConcurrentEvents</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">listen</span><span class="params">(JobExecutionEvent jobExecutionEvent)</span></span>;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 作业状态痕迹事件监听执行.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> jobStatusTraceEvent 作业状态痕迹事件</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Subscribe</span></div><div class="line">    <span class="meta">@AllowConcurrentEvents</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">listen</span><span class="params">(JobStatusTraceEvent jobStatusTraceEvent)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// JobEventRdbListener.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobEventRdbListener</span> <span class="keyword">extends</span> <span class="title">JobEventRdbIdentity</span> <span class="keyword">implements</span> <span class="title">JobEventListener</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobEventRdbStorage repository;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JobEventRdbListener</span><span class="params">(<span class="keyword">final</span> DataSource dataSource)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        repository = <span class="keyword">new</span> JobEventRdbStorage(dataSource);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(<span class="keyword">final</span> JobExecutionEvent executionEvent)</span> </span>&#123;</div><div class="line">        repository.addJobExecutionEvent(executionEvent);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(<span class="keyword">final</span> JobStatusTraceEvent jobStatusTraceEvent)</span> </span>&#123;</div><div class="line">        repository.addJobStatusTraceEvent(jobStatusTraceEvent);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>通过 JobEventRdbStorage 存储作业事件到关系型数据库。</li></ul><p><strong>如何自定义作业监听器？</strong></p><p>有些同学可能希望使用 ES 或者其他数据库存储作业事件，这个时候可以通过实现 JobEventConfiguration、JobEventListener 进行拓展。</p><p><strong>Elastic-Job-Cloud JobEventConfiguration 怎么配置？</strong></p><ul><li><p>Elastic-Job-Cloud-Scheduler：从 <code>conf/elastic-job-cloud-scheduler.properties</code> 配置文件读取如下属性，生成 JobEventConfiguration 配置对象。</p><ul><li><code>event_trace_rdb_driver</code></li><li><code>event_trace_rdb_url</code></li><li><code>event_trace_rdb_username</code></li><li><code>event_trace_rdb_password</code></li></ul></li><li><p>Elastic-Job-Cloud-Executor：通过接收到任务执行信息里读取JobEventConfiguration，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TaskExecutor.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registered</span><span class="params">(<span class="keyword">final</span> ExecutorDriver executorDriver, <span class="keyword">final</span> Protos.ExecutorInfo executorInfo, <span class="keyword">final</span> Protos.FrameworkInfo frameworkInfo, <span class="keyword">final</span> Protos.SlaveInfo slaveInfo)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (!executorInfo.getData().isEmpty()) &#123;</div><div class="line">       Map&lt;String, String&gt; data = SerializationUtils.deserialize(executorInfo.getData().toByteArray());</div><div class="line">       BasicDataSource dataSource = <span class="keyword">new</span> BasicDataSource();</div><div class="line">       dataSource.setDriverClassName(data.get(<span class="string">"event_trace_rdb_driver"</span>));</div><div class="line">       dataSource.setUrl(data.get(<span class="string">"event_trace_rdb_url"</span>));</div><div class="line">       dataSource.setPassword(data.get(<span class="string">"event_trace_rdb_password"</span>));</div><div class="line">       dataSource.setUsername(data.get(<span class="string">"event_trace_rdb_username"</span>));</div><div class="line">       jobEventBus = <span class="keyword">new</span> JobEventBus(<span class="keyword">new</span> JobEventRdbConfiguration(dataSource));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>旁白君：瞎比比了这么长，能不能简单粗暴一点。<br>芋道君：是是是。</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_11_14/04.png" alt=""></p><p>道友，赶紧上车，分享一波朋友圈！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. 作业事件总线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;
      
    
    </summary>
    
      <category term="Elastic-Job-Lite" scheme="http://www.iocoder.cn/categories/Elastic-Job-Lite/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Lite 源码分析 —— 作业失效转移</title>
    <link href="http://www.iocoder.cn/Elastic-Job/job-failover/"/>
    <id>http://www.iocoder.cn/Elastic-Job/job-failover/</id>
    <published>2017-11-06T16:00:00.000Z</published>
    <updated>2017-09-06T10:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><ul><li><a href="#">1. 概述</a></li><li><a href="#">2. 作业节点崩溃监听</a></li><li><a href="#">3. 作业失效转移</a></li><li><a href="#">4. 获取作业分片上下文集合</a></li><li><a href="#">5. 监听作业失效转移功能关闭</a></li><li><a href="#">666. 彩蛋</a></li></ul><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Lite 作业失效转移</strong>。</p><p>当作业节点执行作业异常崩溃时，其所分配的作业分片项在下次重新分片之前不会被重新执行。开启失效转移功能后，这部分作业分片项将被其他作业节点抓取后“执行”。为什么此处的执行打引号呢？😈下文我们会分享到噢，卖个关子。</p><p>笔者对<strong>失效转移</strong>理解了蛮久时间，因此引用官方对它的解释，让你能更好的理解：</p><blockquote><p>来源地址：<a href="https://my.oschina.net/u/719192/blog/506062" rel="external nofollow noopener noreferrer" target="_blank">https://my.oschina.net/u/719192/blog/506062</a><br>失效转移： 运行中的作业服务器崩溃不会导致重新分片，只会在下次作业启动时分片。启用失效转移功能可以在本次作业执行过程中，监测其他作业服务器空闲，抓取未完成的孤儿分片项执行。<br>– 分隔符 –<br>来源地址：<a href="http://dangdangdotcom.github.io/elastic-job/elastic-job-lite/03-design/lite-design/" rel="external nofollow noopener noreferrer" target="_blank">http://dangdangdotcom.github.io/elastic-job/elastic-job-lite/03-design/lite-design/</a><br>实现失效转移功能，在某台服务器执行完毕后主动抓取未分配的分片，并且在某台服务器下线后主动寻找可用的服务器执行任务。</p></blockquote><p>这样看概念可能还是比较难理解，代码搞起来！</p><p>涉及到主要类的类图如下( <a href="http://www.iocoder.cn/images/Elastic-Job/2017_11_07/01.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_11_07/01.png" alt=""></p><ul><li>粉色的类在 <code>com.dangdang.ddframe.job.lite.internal.failover</code> 包下，实现了 Elastic-Job-Lite 作业失效转移。</li><li>FailoverService，作业失效转移服务。</li><li>FailoverNode，作业失效转移数据存储路径。</li><li>FailoverListenerManager，作业失效转移监听管理器。</li></ul><blockquote><p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p></blockquote><h1 id="2-作业节点崩溃监听"><a href="#2-作业节点崩溃监听" class="headerlink" title="2. 作业节点崩溃监听"></a>2. 作业节点崩溃监听</h1><p>当作业节点崩溃时，监听器 JobCrashedJobListener 会监听到该情况，进行作业失效转移处理。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobCrashedJobListener.java</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">JobCrashedJobListener</span> <span class="keyword">extends</span> <span class="title">AbstractJobListener</span> </span>&#123;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String data)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (isFailoverEnabled() &amp;&amp; Type.NODE_REMOVED == eventType</div><div class="line">               &amp;&amp; instanceNode.isInstancePath(path)) &#123; <span class="comment">// /$&#123;JOB_NAME&#125;/instances/$&#123;INSTANCE_ID&#125;</span></div><div class="line">           String jobInstanceId = path.substring(instanceNode.getInstanceFullPath().length() + <span class="number">1</span>);</div><div class="line">           <span class="keyword">if</span> (jobInstanceId.equals(JobRegistry.getInstance().getJobInstance(jobName).getJobInstanceId())) &#123;</div><div class="line">               <span class="keyword">return</span>;</div><div class="line">           &#125;</div><div class="line">           List&lt;Integer&gt; failoverItems = failoverService.getFailoverItems(jobInstanceId); <span class="comment">// /$&#123;JOB_NAME&#125;/sharding/$&#123;ITEM_ID&#125;/failover</span></div><div class="line">           <span class="keyword">if</span> (!failoverItems.isEmpty()) &#123;</div><div class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> each : failoverItems) &#123;</div><div class="line">                   failoverService.setCrashedFailoverFlag(each);</div><div class="line">                   failoverService.failoverIfNecessary();</div><div class="line">               &#125;</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> each : shardingService.getShardingItems(jobInstanceId)) &#123; <span class="comment">// /$&#123;JOB_NAME&#125;/sharding/$&#123;ITEM_ID&#125;/instance</span></div><div class="line">                   failoverService.setCrashedFailoverFlag(each);</div><div class="line">                   failoverService.failoverIfNecessary();</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>通过判断 <code>/${JOB_NAME}/instances/${INSTANCE_ID}</code> 被移除，执行作业失效转移逻辑。❓说好的作业节点<strong>崩溃</strong>呢？经过确认，目前这块存在 BUG，未判断作业节点是否为奔溃。<strong>所以在当前版本，作业失效转移面向的是所有作业节点关闭逻辑，不仅限于作业崩溃关闭。</strong></li><li><p>优先调用 <code>FailoverService#getFailoverItems(...)</code> 方法，获得关闭作业节点( <code>${JOB_INSTANCE_ID}</code> )对应的 <code>${JOB_NAME}/sharding/${ITEM_ID}/failover</code> 作业分片项。</p><p>若该作业分片项为空，再调用 <code>ShardingService#getShardingItems(...)</code> 方法，获得关闭作业节点( <code>${JOB_INSTANCE_ID}</code> )对应的 <code>/${JOB_NAME}/sharding/${ITEM_ID}/instance</code> 作业分片项。</p><p>为什么是这样的顺序呢？放在 <code>FailoverService#failoverIfNecessary()</code> 一起讲。这里先看下 <code>FailoverService#getFailoverItems(...)</code> 方法的实现：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// FailoverService</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getFailoverItems</span><span class="params">(<span class="keyword">final</span> String jobInstanceId)</span> </span>&#123;</div><div class="line">   List&lt;String&gt; items = jobNodeStorage.getJobNodeChildrenKeys(ShardingNode.ROOT);</div><div class="line">   List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(items.size());</div><div class="line">   <span class="keyword">for</span> (String each : items) &#123;</div><div class="line">       <span class="keyword">int</span> item = Integer.parseInt(each);</div><div class="line">       String node = FailoverNode.getExecutionFailoverNode(item); <span class="comment">// `$&#123;JOB_NAME&#125;/sharding/$&#123;ITEM_ID&#125;/failover`</span></div><div class="line">       <span class="keyword">if</span> (jobNodeStorage.isJobNodeExisted(node) &amp;&amp; jobInstanceId.equals(jobNodeStorage.getJobNodeDataDirectly(node))) &#123;</div><div class="line">           result.add(item);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   Collections.sort(result);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用 <code>FailoverService#setCrashedFailoverFlag(...)</code> 方法，设置失效的分片项标记 <code>/${JOB_NAME}/leader/failover/items/${ITEM_ID}</code>。该数据节点为<strong>永久</strong>节点，存储空串( <code>&quot;&quot;</code> )。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// FailoverService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCrashedFailoverFlag</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> item)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (!isFailoverAssigned(item)) &#123;</div><div class="line">       jobNodeStorage.createJobNodeIfNeeded(FailoverNode.getItemsNode(item)); <span class="comment">// /$&#123;JOB_NAME&#125;/leader/failover/items/$&#123;ITEM_ID&#125;</span></div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isFailoverAssigned</span><span class="params">(<span class="keyword">final</span> Integer item)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> jobNodeStorage.isJobNodeExisted(FailoverNode.getExecutionFailoverNode(item));</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用 <code>FailoverService#failoverIfNecessary()</code> 方法，如果需要失效转移, 则执行作业失效转移。</p></li></ul><h1 id="3-作业失效转移"><a href="#3-作业失效转移" class="headerlink" title="3. 作业失效转移"></a>3. 作业失效转移</h1><p>调用 <code>FailoverService#failoverIfNecessary()</code> 方法，如果需要失效转移, 则执行作业失效转移。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// FailoverService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failoverIfNecessary</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (needFailover()) &#123;</div><div class="line">       jobNodeStorage.executeInLeader(FailoverNode.LATCH, <span class="keyword">new</span> FailoverLeaderExecutionCallback());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>#needFailover()</code> 方法，判断是否满足失效转移条件。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">needFailover</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">// `$&#123;JOB_NAME&#125;/leader/failover/items/$&#123;ITEM_ID&#125;` 有失效转移的作业分片项</span></div><div class="line">    <span class="keyword">return</span> jobNodeStorage.isJobNodeExisted(FailoverNode.ITEMS_ROOT) &amp;&amp; !jobNodeStorage.getJobNodeChildrenKeys(FailoverNode.ITEMS_ROOT).isEmpty()</div><div class="line">            <span class="comment">// 当前作业不在运行中</span></div><div class="line">            &amp;&amp; !JobRegistry.getInstance().isJobRunning(jobName);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>条件一：<code>${JOB_NAME}/leader/failover/items/${ITEM_ID}</code> 有失效转移的作业分片项。</li><li><p>条件二：当前作业不在运行中。此条件即是上文提交的作业节点<strong>空闲</strong>的定义。</p><blockquote><p>失效转移： 运行中的作业服务器崩溃不会导致重新分片，只会在下次作业启动时分片。启用失效转移功能可以在本次作业执行过程中，监测其他作业服务器【空闲】，抓取未完成的孤儿分片项执行</p></blockquote></li></ul></li><li><p>调用 <code>JobNodeStorage#executeInLeader(...)</code> 方法，使用 <code>FailoverNode.LATCH</code>( <code>/${JOB_NAME}/leader/failover/latch</code> ) 路径构成的<strong>分布式锁</strong>，保证 FailoverLeaderExecutionCallback 的回调方法同一时间，即使多个作业节点调用，有且仅有一个作业节点进行执行。另外，虽然 <code>JobNodeStorage#executeInLeader(...)</code> 方法上带有 <code>Leader</code> 关键字，实际非必须在主节点的操作，任何一个拿到<strong>分布式锁</strong>的作业节点都可以调用。目前和<strong>分布式锁</strong>相关的逻辑，在 Elastic-Job-Lite 里，都会调用 <code>JobNodeStorage#executeInLeader(...)</code> 方法，数据都存储在 <code>/leader/</code> 节点目录下。关于<strong>分布式锁</strong>相关的，在<a href="http://www.iocoder.cn/Elastic-Job/reg-center-zookeeper/?self">《Elastic-Job-Lite 源码分析 —— 注册中心》「3.1 在主节点执行操作」</a>有详细分享。</p></li></ul><hr><p>FailoverLeaderExecutionCallback 回调逻辑如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FailoverLeaderExecutionCallback</span> <span class="keyword">implements</span> <span class="title">LeaderExecutionCallback</span> </span>&#123;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="comment">// 判断需要失效转移</span></div><div class="line">       <span class="keyword">if</span> (JobRegistry.getInstance().isShutdown(jobName) || !needFailover()) &#123;</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 获得一个 `$&#123;JOB_NAME&#125;/leader/failover/items/$&#123;ITEM_ID&#125;` 作业分片项</span></div><div class="line">       <span class="keyword">int</span> crashedItem = Integer.parseInt(jobNodeStorage.getJobNodeChildrenKeys(FailoverNode.ITEMS_ROOT).get(<span class="number">0</span>));</div><div class="line">       log.debug(<span class="string">"Failover job '&#123;&#125;' begin, crashed item '&#123;&#125;'"</span>, jobName, crashedItem);</div><div class="line">       <span class="comment">// 设置这个 `$&#123;JOB_NAME&#125;/sharding/$&#123;ITEM_ID&#125;/failover` 作业分片项 为 当前作业节点</span></div><div class="line">       jobNodeStorage.fillEphemeralJobNode(FailoverNode.getExecutionFailoverNode(crashedItem), JobRegistry.getInstance().getJobInstance(jobName).getJobInstanceId());</div><div class="line">       <span class="comment">// 移除这个 `$&#123;JOB_NAME&#125;/leader/failover/items/$&#123;ITEM_ID&#125;` 作业分片项</span></div><div class="line">       jobNodeStorage.removeJobNodeIfExisted(FailoverNode.getItemsNode(crashedItem));</div><div class="line">       <span class="comment">// TODO 不应使用triggerJob, 而是使用executor统一调度 疑问：为什么要用executor统一，后面研究下</span></div><div class="line">       <span class="comment">// 触发作业执行</span></div><div class="line">       JobScheduleController jobScheduleController = JobRegistry.getInstance().getJobScheduleController(jobName);</div><div class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> != jobScheduleController) &#123;</div><div class="line">           jobScheduleController.triggerJob();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>再次调用 <code>#needFailover()</code> 方法，确保经过分布式锁获取等待过程中，仍然需要失效转移。因为可能多个作业节点调用了该回调，第一个作业节点执行了失效转移，可能第二个作业节点就不需要执行失效转移了。</li><li><p>调用 <code>JobNodeStorage#getJobNodeChildrenKeys(FailoverNode.ITEMS_ROOT)#get(0)</code> 方法，获得<strong>一个</strong> <code>${JOB_NAME}/leader/failover/items/${ITEM_ID}</code> 作业分片项。  </p><p>调用 <code>JobNodeStorage#fillEphemeralJobNode(...)</code> 方法，设置这个<strong>临时</strong>数据节点 <code>${JOB_NAME}/sharding/${ITEM_ID}failover</code> 作业分片项为当前作业节点( <code>${JOB_INSTANCE_ID}</code> )。  </p><p>调用 <code>JobNodeStorage#removeJobNodeIfExisted(...)</code> 方法，移除这个<code>${JOB_NAME}/leader/failover/items/${ITEM_ID}</code> 作业分片项。</p></li><li><p>调用 <code>JobScheduleController#triggerJob()</code> 方法，立即启动作业。调用该方法，实际作业不会立即执行，而仅仅是进行触发。如果有多个失效转移的作业分片项，多次调用 <code>JobScheduleController#triggerJob()</code> 方法会不会导致作业是<strong>并行执行</strong>的？答案是不会，因为一个作业的 Quartz 线程数设置为 1。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobScheduler.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> Properties <span class="title">getBaseQuartzProperties</span><span class="params">()</span> </span>&#123;</div><div class="line">   Properties result = <span class="keyword">new</span> Properties();</div><div class="line">   <span class="comment">// ... 省略无关代码</span></div><div class="line">   result.put(<span class="string">"org.quartz.threadPool.threadCount"</span>, <span class="string">"1"</span>); <span class="comment">// Quartz 线程数：1</span></div><div class="line">   <span class="comment">// ... 省略无关代码</span></div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><hr><p>如果说作业分片项实现转移时，每个作业节点都不处于非空闲状态，岂不是 FailoverLeaderExecutionCallback 一直无法被回调？答案当然不是的。作业在执行完分配给自己的作业分片项，会调用 <code>LiteJobFacade#failoverIfNecessary()</code> 方法，进行失效转移的作业分片项抓取：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// ...  省略无关代码</span></div><div class="line">   </div><div class="line">   <span class="comment">// 执行 普通触发的作业</span></div><div class="line">   execute(shardingContexts, JobExecutionEvent.ExecutionSource.NORMAL_TRIGGER);</div><div class="line">   <span class="comment">// 执行 被跳过触发的作业</span></div><div class="line">   <span class="keyword">while</span> (jobFacade.isExecuteMisfired(shardingContexts.getShardingItemParameters().keySet())) &#123;</div><div class="line">       jobFacade.clearMisfire(shardingContexts.getShardingItemParameters().keySet());</div><div class="line">       execute(shardingContexts, JobExecutionEvent.ExecutionSource.MISFIRE);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="comment">// 执行 作业失效转移</span></div><div class="line">   jobFacade.failoverIfNecessary();</div><div class="line">   </div><div class="line">   <span class="comment">// ...  省略无关代码</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failoverIfNecessary</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (configService.load(<span class="keyword">true</span>).isFailover()) &#123;</div><div class="line">       failoverService.failoverIfNecessary();</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// FailoverService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failoverIfNecessary</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (needFailover()) &#123;</div><div class="line">       jobNodeStorage.executeInLeader(FailoverNode.LATCH, <span class="keyword">new</span> FailoverLeaderExecutionCallback());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>让我们在翻回 JobCrashedJobListener 处代码，为什么获取失效转移的作业分片项是这样的优先顺序？一个作业节点拥有 <code>${JOB_NAME}/sharding/${ITEM_ID}/failover</code> 数据分片项，意味着分配给它的作业分片项已经执行完成，否则怎么回调 FailoverLeaderExecutionCallback 方法，抓取失效转移的作业分片项呢？！</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_11_07/02.png" alt=""></p><p>旁白君：双击666，关注笔者公众号一波。</p><h1 id="4-获取作业分片上下文集合"><a href="#4-获取作业分片上下文集合" class="headerlink" title="4. 获取作业分片上下文集合"></a>4. 获取作业分片上下文集合</h1><p>在<a href="http://www.iocoder.cn/Elastic-Job/job-execute/?self">《Elastic-Job-Lite 源码分析 —— 作业执行》「4.2 获取当前作业服务器的分片上下文」</a>中，我们可以看到作业执行器( AbstractElasticJobExecutor ) 执行作业时，会获取当前作业服务器的分片上下文进行执行。获取过程总体如下顺序图( <a href="http://www.iocoder.cn/images/Elastic-Job/2017_11_07/03.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_11_07/03.png" alt=""></p><ul><li>红色叉叉在<a href="http://www.iocoder.cn/Elastic-Job/job-sharding/?self">《Elastic-Job-Lite 源码解析 —— 作业分片》</a>有详细分享。</li></ul><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ShardingContexts <span class="title">getShardingContexts</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 获得 失效转移的作业分片项</span></div><div class="line">   <span class="keyword">boolean</span> isFailover = configService.load(<span class="keyword">true</span>).isFailover();</div><div class="line">   <span class="keyword">if</span> (isFailover) &#123;</div><div class="line">       List&lt;Integer&gt; failoverShardingItems = failoverService.getLocalFailoverItems();</div><div class="line">       <span class="keyword">if</span> (!failoverShardingItems.isEmpty()) &#123;</div><div class="line">           <span class="comment">// 【忽略，作业分片详解】获取当前作业服务器分片上下文</span></div><div class="line">           <span class="keyword">return</span> executionContextService.getJobShardingContext(failoverShardingItems);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 【忽略，作业分片详解】作业分片，如果需要分片且当前节点为主节点</span></div><div class="line">   shardingService.shardingIfNecessary();</div><div class="line">   <span class="comment">// 【忽略，作业分片详解】获得 分配在本机的作业分片项</span></div><div class="line">   List&lt;Integer&gt; shardingItems = shardingService.getLocalShardingItems();</div><div class="line">   <span class="comment">// 移除 分配在本机的失效转移的作业分片项目</span></div><div class="line">   <span class="keyword">if</span> (isFailover) &#123;</div><div class="line">       shardingItems.removeAll(failoverService.getLocalTakeOffItems());</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 移除 被禁用的作业分片项</span></div><div class="line">   shardingItems.removeAll(executionService.getDisabledItems(shardingItems));</div><div class="line">   <span class="comment">// 【忽略，作业分片详解】获取当前作业服务器分片上下文</span></div><div class="line">   <span class="keyword">return</span> executionContextService.getJobShardingContext(shardingItems);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>FailoverService#getLocalFailoverItems()</code> 方法，获取运行在本作业节点的失效转移分片项集合。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// FailoverService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getLocalFailoverItems</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (JobRegistry.getInstance().isShutdown(jobName)) &#123;</div><div class="line">       <span class="keyword">return</span> Collections.emptyList();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> getFailoverItems(JobRegistry.getInstance().getJobInstance(jobName).getJobInstanceId()); <span class="comment">// `$&#123;JOB_NAME&#125;/sharding/$&#123;ITEM_ID&#125;/failover`</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用 <code>ExecutionContextService#getJobShardingContext()</code> 方法，获取当前作业服务器分片上下文。在<a href="http://www.iocoder.cn/Elastic-Job/job-sharding/?self">《Elastic-Job-Lite 源码解析 —— 作业分片》「4. 获取作业分片上下文集合」</a>有详细解析。</p></li><li><p>当本作业节点不存在抓取的失效转移分片项，则获得分配给本作业分解的作业分片项。此时你会看到略奇怪的方法调用，<code>shardingItems.removeAll(failoverService.getLocalTakeOffItems())</code>。为什么呢？举个例子，作业节点A持有作业分片项[0, 1]，此时异常断网，导致[0, 1]被作业节点B失效转移抓取，此时若作业节点A恢复，作业分片项[0, 1]依然属于作业节点A，但是可能已经在作业节点B执行，因此需要进行移除，避免多节点运行相同的作业分片项。<code>FailoverService#getLocalTakeOffItems()</code> 方法实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// FailoverService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获取运行在本作业服务器的被失效转移的序列号.</span></div><div class="line"><span class="comment">* </span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 运行在本作业服务器的被失效转移的序列号</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getLocalTakeOffItems</span><span class="params">()</span> </span>&#123;</div><div class="line">   List&lt;Integer&gt; shardingItems = shardingService.getLocalShardingItems();</div><div class="line">   List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(shardingItems.size());</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> each : shardingItems) &#123;</div><div class="line">       <span class="keyword">if</span> (jobNodeStorage.isJobNodeExisted(FailoverNode.getExecutionFailoverNode(each))) &#123;</div><div class="line">           result.add(each);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h1 id="5-监听作业失效转移功能关闭"><a href="#5-监听作业失效转移功能关闭" class="headerlink" title="5. 监听作业失效转移功能关闭"></a>5. 监听作业失效转移功能关闭</h1><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FailoverSettingsChangedJobListener</span> <span class="keyword">extends</span> <span class="title">AbstractJobListener</span> </span>&#123;</div><div class="line">        </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String data)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (configNode.isConfigPath(path) &amp;&amp; Type.NODE_UPDATED == eventType</div><div class="line">               &amp;&amp; !LiteJobConfigurationGsonFactory.fromJson(data).isFailover()) &#123; <span class="comment">// 关闭失效转移功能</span></div><div class="line">           failoverService.removeFailoverInfo();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>旁白君：啊啊啊，有点绕。<br>芋道君：耐心，耐心，耐心。</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_11_07/04.png" alt=""></p><p>道友，赶紧上车，分享一波朋友圈！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注&lt;strong&gt;微信公众号：【芋道源码】&lt;/strong&gt;
      
    
    </summary>
    
      <category term="Elastic-Job-Lite" scheme="http://www.iocoder.cn/categories/Elastic-Job-Lite/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Lite 源码分析 —— 作业分片</title>
    <link href="http://www.iocoder.cn/Elastic-Job/job-sharding/"/>
    <id>http://www.iocoder.cn/Elastic-Job/job-sharding/</id>
    <published>2017-10-30T16:00:00.000Z</published>
    <updated>2017-09-06T10:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p><ul><li><a href="#">1. 概述</a></li><li><a href="#">2. 作业分片条件</a></li><li><a href="#">3. 分配作业分片项</a></li><li><a href="#">4. 获取作业分片上下文集合</a></li><li><a href="#">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Lite 作业分片</strong>。</p><p>涉及到主要类的类图如下( <a href="http://www.iocoder.cn/images/Elastic-Job/2017_10_31/01.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_10_31/01.png" alt=""></p><ul><li>粉色的类在 <code>com.dangdang.ddframe.job.lite.internal.sharding</code> 包下，实现了 Elastic-Job-Lite 作业分片。</li><li>ShardingService，作业分片服务。</li><li>ShardingNode，作业分片数据存储路径。</li><li>ShardingListenerManager，作业分片监听管理器。</li></ul><blockquote><p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p></blockquote><h1 id="2-作业分片条件"><a href="#2-作业分片条件" class="headerlink" title="2. 作业分片条件"></a>2. 作业分片条件</h1><p>当作业满足分片条件时，不会<strong>立即</strong>进行作业分片分配，而是设置需要重新进行分片的<strong>标记</strong>，等到作业分片获取时，判断有该标记后<strong>执行</strong>作业分配。</p><p>设置需要重新进行分片的<strong>标记</strong>的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 设置需要重新分片的标记.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReshardingFlag</span><span class="params">()</span> </span>&#123;</div><div class="line">   jobNodeStorage.createJobNodeIfNeeded(ShardingNode.NECESSARY);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// JobNodeStorage.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 如果存在则创建作业节点.</span></div><div class="line"><span class="comment">* 如果作业根节点不存在表示作业已经停止, 不再继续创建节点.</span></div><div class="line"><span class="comment">* </span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> node 作业节点名称</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createJobNodeIfNeeded</span><span class="params">(<span class="keyword">final</span> String node)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (isJobRootNodeExisted() &amp;&amp; !isJobNodeExisted(node)) &#123;</div><div class="line">       regCenter.persist(jobNodePath.getFullPath(node), <span class="string">""</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>#setReshardingFlag()</code> 方法设置<strong>需要重新分片的标记</strong> <code>/${JOB_NAME}/leader/sharding/necessary</code>。该 Zookeeper 数据节点是<strong>永久</strong>节点，存储空串( <code>&quot;&quot;</code> )，使用 zkClient 查看如下：</p>  <figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 2] ls /elastic-job-example-lite-java/javaSimpleJob/leader/sharding</div><div class="line">[necessary]</div><div class="line">[zk: localhost:2181(CONNECTED) 3] get /elastic-job-example-lite-java/javaSimpleJob/leader/sharding/necessary</div></pre></td></tr></table></figure></li><li><p>设置标记之后，通过调用 <code>#isNeedSharding()</code> 方法即可判断是否需要重新分片。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 判断是否需要重分片.</span></div><div class="line"><span class="comment">* </span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 是否需要重分片</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNeedSharding</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> jobNodeStorage.isJobNodeExisted(ShardingNode.NECESSARY);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// JobNodeStorage.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 判断作业节点是否存在.</span></div><div class="line"><span class="comment">* </span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> node 作业节点名称</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 作业节点是否存在</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isJobNodeExisted</span><span class="params">(<span class="keyword">final</span> String node)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> regCenter.isExisted(jobNodePath.getFullPath(node));</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p><strong>设置需要重新进行分片有 4 种情况</strong></p><p><strong>第一种</strong>，注册作业启动信息时。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SchedulerFacade.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStartUpInfo</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> enabled)</span> </span>&#123;</div><div class="line">   <span class="comment">// ... 省略无关代码</span></div><div class="line">   <span class="comment">// 设置 需要重新分片的标记</span></div><div class="line">   shardingService.setReshardingFlag();</div><div class="line">  <span class="comment">// ... 省略无关代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>第二种</strong>，作业分片总数( <code>JobCoreConfiguration.shardingTotalCount</code> )变化时。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingTotalCountChangedJobListener.java</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShardingTotalCountChangedJobListener</span> <span class="keyword">extends</span> <span class="title">AbstractJobListener</span> </span>&#123;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String data)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (configNode.isConfigPath(path)</div><div class="line">               &amp;&amp; <span class="number">0</span> != JobRegistry.getInstance().getCurrentShardingTotalCount(jobName)) &#123;</div><div class="line">           <span class="keyword">int</span> newShardingTotalCount = LiteJobConfigurationGsonFactory.fromJson(data).getTypeConfig().getCoreConfig().getShardingTotalCount();</div><div class="line">           <span class="keyword">if</span> (newShardingTotalCount != JobRegistry.getInstance().getCurrentShardingTotalCount(jobName)) &#123; <span class="comment">// 作业分片总数变化</span></div><div class="line">               <span class="comment">// 设置需要重新分片的标记</span></div><div class="line">               shardingService.setReshardingFlag();</div><div class="line">               <span class="comment">// 设置当前分片总数</span></div><div class="line">               JobRegistry.getInstance().setCurrentShardingTotalCount(jobName, newShardingTotalCount);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>第三种</strong>，服务器变化时。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingListenerManager.java</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListenServersChangedJobListener</span> <span class="keyword">extends</span> <span class="title">AbstractJobListener</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String data)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (!JobRegistry.getInstance().isShutdown(jobName)</div><div class="line">               &amp;&amp; (isInstanceChange(eventType, path)</div><div class="line">                   || isServerChange(path))) &#123;</div><div class="line">           shardingService.setReshardingFlag();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isInstanceChange</span><span class="params">(<span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String path)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> instanceNode.isInstancePath(path) &amp;&amp; Type.NODE_UPDATED != eventType;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isServerChange</span><span class="params">(<span class="keyword">final</span> String path)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> serverNode.isServerPath(path);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>服务器变化有<strong>两种</strong>情况。</li><li>第一种，<code>#isServerChange(...)</code> 服务器被开启或禁用。</li><li>第二种，<code>#isInstanceChange(...)</code> 作业节点新增或者移除。</li></ul><p><strong>第四种</strong>，在<a href="http://www.iocoder.cn/Elastic-Job/reconcile/?self">《Elastic-Job-Lite 源码解析 —— 自诊断修复》</a>详细分享。</p><h1 id="3-分配作业分片项"><a href="#3-分配作业分片项" class="headerlink" title="3. 分配作业分片项"></a>3. 分配作业分片项</h1><p>调用 <code>ShardingService#shardingIfNecessary()</code> 方法，如果需要分片且当前节点为主节点, 则作业分片。</p><p>总体流程如下<strong>顺序图</strong>：( <a href="http://www.iocoder.cn/images/Elastic-Job/2017_10_31/02.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_10_31/02.png" alt=""></p><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 如果需要分片且当前节点为主节点, 则作业分片.</span></div><div class="line"><span class="comment">* </span></div><div class="line"><span class="comment">* 如果当前无可用节点则不分片.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shardingIfNecessary</span><span class="params">()</span> </span>&#123;</div><div class="line">   List&lt;JobInstance&gt; availableJobInstances = instanceService.getAvailableJobInstances();</div><div class="line">   <span class="keyword">if</span> (!isNeedSharding() <span class="comment">// 判断是否需要重新分片</span></div><div class="line">           || availableJobInstances.isEmpty()) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 【非主节点】等待 作业分片项分配完成</span></div><div class="line">   <span class="keyword">if</span> (!leaderService.isLeaderUntilBlock()) &#123; <span class="comment">// 判断是否为【主节点】</span></div><div class="line">       blockUntilShardingCompleted();</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 【主节点】作业分片项分配</span></div><div class="line">   <span class="comment">// 等待 作业未在运行中状态</span></div><div class="line">   waitingOtherJobCompleted();</div><div class="line">   <span class="comment">//</span></div><div class="line">   LiteJobConfiguration liteJobConfig = configService.load(<span class="keyword">false</span>);</div><div class="line">   <span class="keyword">int</span> shardingTotalCount = liteJobConfig.getTypeConfig().getCoreConfig().getShardingTotalCount();</div><div class="line">   <span class="comment">// 设置 作业正在重分片的标记</span></div><div class="line">   log.debug(<span class="string">"Job '&#123;&#125;' sharding begin."</span>, jobName);</div><div class="line">   jobNodeStorage.fillEphemeralJobNode(ShardingNode.PROCESSING, <span class="string">""</span>);</div><div class="line">   <span class="comment">// 重置 作业分片项信息</span></div><div class="line">   resetShardingInfo(shardingTotalCount);</div><div class="line">   <span class="comment">// 【事务中】设置 作业分片项信息</span></div><div class="line">   JobShardingStrategy jobShardingStrategy = JobShardingStrategyFactory.getStrategy(liteJobConfig.getJobShardingStrategyClass());</div><div class="line">   jobNodeStorage.executeInTransaction(<span class="keyword">new</span> PersistShardingInfoTransactionExecutionCallback(jobShardingStrategy.sharding(availableJobInstances, jobName, shardingTotalCount)));</div><div class="line">   log.debug(<span class="string">"Job '&#123;&#125;' sharding complete."</span>, jobName);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>#isNeedSharding()</code> 方法判断是否需要重新分片。</li><li>调用 <code>LeaderService#isLeaderUntilBlock()</code> 方法判断是否为<strong>主节点</strong>。作业分片项的分配过程：<ul><li>【主节点】<strong>执行</strong>作业分片项分配。</li><li>【非主节点】<strong>等待</strong>作业分片项分配完成。</li><li><code>LeaderService#isLeaderUntilBlock()</code> 方法在<a href="http://www.iocoder.cn/Elastic-Job/election/?self">《Elastic-Job-Lite 源码分析 —— 主节点选举》「3. 选举主节点」</a>有详细分享。</li></ul></li><li><p>调用 <code>#blockUntilShardingCompleted()</code> 方法【非主节点】<strong>等待</strong>作业分片项分配完成。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">blockUntilShardingCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">while</span> (!leaderService.isLeaderUntilBlock() <span class="comment">// 当前作业节点不为【主节点】</span></div><div class="line">           &amp;&amp; (jobNodeStorage.isJobNodeExisted(ShardingNode.NECESSARY) <span class="comment">// 存在作业需要重分片的标记</span></div><div class="line">               || jobNodeStorage.isJobNodeExisted(ShardingNode.PROCESSING))) &#123; <span class="comment">// 存在作业正在重分片的标记</span></div><div class="line">       log.debug(<span class="string">"Job '&#123;&#125;' sleep short time until sharding completed."</span>, jobName);</div><div class="line">       BlockUtils.waitingShortTime();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>#LeaderService#isLeaderUntilBlock()</code> 方法判断是否为<strong>主节点</strong>。为什么上面判断了一次，这里又判断一次？主节点作业分片项分配过程中，不排除自己挂掉了，此时【非主节点】若选举成主节点，无需继续等待，当然也不能等待，因为已经没节点在执行作业分片项分配，所有节点都会卡在这里。</li><li>当 <strong>作业需要重分片的标记</strong>、<strong>作业正在重分片的标记</strong> 都不存在时，意味着作业分片项分配已经完成，下文 PersistShardingInfoTransactionExecutionCallback 类里我们会看到。</li></ul></li><li><p>调用 <code>#waitingOtherJobCompleted()</code> 方法等待作业未在运行中状态。作业是否在运行中需要 <code>LiteJobConfiguration.monitorExecution = true</code>，<a href="http://www.iocoder.cn/Elastic-Job/election/?self">《Elastic-Job-Lite 源码分析 —— 作业执行》「4.6 执行普通触发的作业」</a>有详细分享。</p></li><li>调用 <code>ConfigurationService#load(...)</code> 方法从注册中心获取作业配置( <strong>非缓存</strong> )，避免主节点本地作业配置可能非最新的，主要目的是获得作业分片总数( <code>shardingTotalCount</code> )。</li><li>调用 <code>jobNodeStorage.fillEphemeralJobNode(ShardingNode.PROCESSING, &quot;&quot;)</code> 设置<strong>作业正在重分片的标记</strong> <code>/${JOB_NAME}/leader/sharding/processing</code>。该 Zookeeper 数据节点是<strong>临时</strong>节点，存储空串( <code>&quot;&quot;</code> )，仅用于标记作业正在重分片，无特别业务逻辑。</li><li><p>调用 <code>#resetShardingInfo(...)</code> 方法<strong>重置</strong>作业分片信息。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resetShardingInfo</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> shardingTotalCount)</span> </span>&#123;</div><div class="line">  <span class="comment">// 重置 有效的作业分片项</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shardingTotalCount; i++) &#123;</div><div class="line">      jobNodeStorage.removeJobNodeIfExisted(ShardingNode.getInstanceNode(i)); <span class="comment">// 移除 `/$&#123;JOB_NAME&#125;/sharding/$&#123;ITEM_ID&#125;/instance`</span></div><div class="line">      jobNodeStorage.createJobNodeIfNeeded(ShardingNode.ROOT + <span class="string">"/"</span> + i); <span class="comment">// 创建 `/$&#123;JOB_NAME&#125;/sharding/$&#123;ITEM_ID&#125;`</span></div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 移除 多余的作业分片项</span></div><div class="line">  <span class="keyword">int</span> actualShardingTotalCount = jobNodeStorage.getJobNodeChildrenKeys(ShardingNode.ROOT).size();</div><div class="line">  <span class="keyword">if</span> (actualShardingTotalCount &gt; shardingTotalCount) &#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = shardingTotalCount; i &lt; actualShardingTotalCount; i++) &#123;</div><div class="line">          jobNodeStorage.removeJobNodeIfExisted(ShardingNode.ROOT + <span class="string">"/"</span> + i); <span class="comment">// 移除 `/$&#123;JOB_NAME&#125;/sharding/$&#123;ITEM_ID&#125;`</span></div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用 <code>JobShardingStrategy#sharding(...)</code> 方法<strong>计算</strong>每个节点分配的作业分片项。<a href="http://www.iocoder.cn/Elastic-Job/job-sharding-strategy/?self">《Elastic-Job-Lite 源码分析 —— 作业分片策略》</a>有详细分享。</p></li><li><p>调用 <code>JobNodeStorage#executeInTransaction(...)</code> + <code>PersistShardingInfoTransactionExecutionCallback#execute()</code> 方法实现在<strong>事务</strong>中<strong>设置</strong>每个节点分配的作业分片项。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// PersistShardingInfoTransactionExecutionCallback.java</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersistShardingInfoTransactionExecutionCallback</span> <span class="keyword">implements</span> <span class="title">TransactionExecutionCallback</span> </span>&#123;</div><div class="line">   </div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 作业分片项分配结果</span></div><div class="line"><span class="comment">    * key：作业节点</span></div><div class="line"><span class="comment">    * value：作业分片项</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;JobInstance, List&lt;Integer&gt;&gt; shardingResults;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> CuratorTransactionFinal curatorTransactionFinal)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">       <span class="comment">// 设置 每个节点分配的作业分片项</span></div><div class="line">       <span class="keyword">for</span> (Map.Entry&lt;JobInstance, List&lt;Integer&gt;&gt; entry : shardingResults.entrySet()) &#123;</div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> shardingItem : entry.getValue()) &#123;</div><div class="line">               curatorTransactionFinal.create().forPath(jobNodePath.getFullPath(ShardingNode.getInstanceNode(shardingItem))</div><div class="line">                       , entry.getKey().getJobInstanceId().getBytes()).and();</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 移除 作业需要重分片的标记、作业正在重分片的标记</span></div><div class="line">       curatorTransactionFinal.delete().forPath(jobNodePath.getFullPath(ShardingNode.NECESSARY)).and();</div><div class="line">       curatorTransactionFinal.delete().forPath(jobNodePath.getFullPath(ShardingNode.PROCESSING)).and();</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// JobNodeStorage.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 在事务中执行操作.</span></div><div class="line"><span class="comment">* </span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> callback 执行操作的回调</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeInTransaction</span><span class="params">(<span class="keyword">final</span> TransactionExecutionCallback callback)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       CuratorTransactionFinal curatorTransactionFinal = getClient().inTransaction().check().forPath(<span class="string">"/"</span>).and();</div><div class="line">       callback.execute(curatorTransactionFinal);</div><div class="line">       curatorTransactionFinal.commit();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       RegExceptionHandler.handleException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>设置<strong>临时</strong>数据节点 <code>/${JOB_NAME}/sharding/${ITEM_ID}/instance</code> 为分配的作业节点的作业实例主键( <code>jobInstanceId</code> )。使用 zkClient 查看如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 0] get /elastic-job-example-lite-java/javaSimpleJob/sharding/0/instance</div><div class="line">192.168.3.2@-@31492</div></pre></td></tr></table></figure></li></ul></li></ul><p><strong>作业分片项分配整体流程有点长，耐着心看，毕竟是核心代码哟。如果中间有任何疑问，欢迎给我公众号：<a href="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg">芋道源码</a> 留言。</strong></p><h1 id="4-获取作业分片上下文集合"><a href="#4-获取作业分片上下文集合" class="headerlink" title="4. 获取作业分片上下文集合"></a>4. 获取作业分片上下文集合</h1><p>在<a href="http://www.iocoder.cn/Elastic-Job/job-execute/?self">《Elastic-Job-Lite 源码分析 —— 作业执行的》「4.2 获取当前作业服务器的分片上下文」</a>中，我们可以看到作业执行器( AbstractElasticJobExecutor ) 执行作业时，会获取当前作业服务器的分片上下文进行执行。获取过程总体如下顺序图( <a href="http://www.iocoder.cn/images/Elastic-Job/2017_10_31/03.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_10_31/03.png" alt=""></p><ul><li>橘色叉叉在<a href="http://www.iocoder.cn/Elastic-Job/job-failover/?self">《Elastic-Job-Lite 源码解析 —— 作业失效转移》</a>有详细分享。</li></ul><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ShardingContexts <span class="title">getShardingContexts</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 【忽略，作业失效转移详解】获得 失效转移的作业分片项</span></div><div class="line">   <span class="keyword">boolean</span> isFailover = configService.load(<span class="keyword">true</span>).isFailover();</div><div class="line">   <span class="keyword">if</span> (isFailover) &#123;</div><div class="line">       List&lt;Integer&gt; failoverShardingItems = failoverService.getLocalFailoverItems();</div><div class="line">       <span class="keyword">if</span> (!failoverShardingItems.isEmpty()) &#123;</div><div class="line">           <span class="keyword">return</span> executionContextService.getJobShardingContext(failoverShardingItems);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 作业分片，如果需要分片且当前节点为主节点</span></div><div class="line">   shardingService.shardingIfNecessary();</div><div class="line">   <span class="comment">// 获得 分配在本机的作业分片项</span></div><div class="line">   List&lt;Integer&gt; shardingItems = shardingService.getLocalShardingItems();</div><div class="line">   <span class="comment">// 【忽略，作业失效转移详解】移除 分配在本机的失效转移的作业分片项目</span></div><div class="line">   <span class="keyword">if</span> (isFailover) &#123;</div><div class="line">       shardingItems.removeAll(failoverService.getLocalTakeOffItems());</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 移除 被禁用的作业分片项</span></div><div class="line">   shardingItems.removeAll(executionService.getDisabledItems(shardingItems));</div><div class="line">   <span class="comment">// 获取当前作业服务器分片上下文</span></div><div class="line">   <span class="keyword">return</span> executionContextService.getJobShardingContext(shardingItems);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>ShardingService#shardingIfNecessary()</code> 方法，如果需要分片且当前节点为主节点，作业分片项<strong>分配</strong>。<strong>不是每次都需要作业分片，必须满足「2. 作业分片条件」才执行作业分片</strong>。</li><li><p>调用 <code>ShardingService#getLocalShardingItems()</code>方法，获得分配在<strong>本机</strong>的作业分片项，即 <code>/${JOB_NAME}/sharding/${ITEM_ID}/instance</code> 为本机的作业分片项。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获取运行在本作业实例的分片项集合.</span></div><div class="line"><span class="comment">* </span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 运行在本作业实例的分片项集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getLocalShardingItems</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (JobRegistry.getInstance().isShutdown(jobName) || !serverService.isAvailableServer(JobRegistry.getInstance().getJobInstance(jobName).getIp())) &#123;</div><div class="line">       <span class="keyword">return</span> Collections.emptyList();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> getShardingItems(JobRegistry.getInstance().getJobInstance(jobName).getJobInstanceId());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获取作业运行实例的分片项集合.</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> jobInstanceId 作业运行实例主键</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 作业运行实例的分片项集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getShardingItems</span><span class="params">(<span class="keyword">final</span> String jobInstanceId)</span> </span>&#123;</div><div class="line">   JobInstance jobInstance = <span class="keyword">new</span> JobInstance(jobInstanceId);</div><div class="line">   <span class="keyword">if</span> (!serverService.isAvailableServer(jobInstance.getIp())) &#123;</div><div class="line">       <span class="keyword">return</span> Collections.emptyList();</div><div class="line">   &#125;</div><div class="line">   List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">   <span class="keyword">int</span> shardingTotalCount = configService.load(<span class="keyword">true</span>).getTypeConfig().getCoreConfig().getShardingTotalCount();</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shardingTotalCount; i++) &#123;</div><div class="line">       <span class="comment">// `/$&#123;JOB_NAME&#125;/sharding/$&#123;ITEM_ID&#125;/instance`</span></div><div class="line">       <span class="keyword">if</span> (jobInstance.getJobInstanceId().equals(jobNodeStorage.getJobNodeData(ShardingNode.getInstanceNode(i)))) &#123;</div><div class="line">           result.add(i);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用 <code>shardingItems.removeAll(executionService.getDisabledItems(shardingItems))</code>，移除<strong>被禁用</strong>的作业分片项，即 <code>/${JOB_NAME}/sharding/${ITEM_ID}/disabled</code> <strong>存在</strong>的作业分片项。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ExecutionService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获取禁用的任务分片项.</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> items 需要获取禁用的任务分片项</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 禁用的任务分片项</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getDisabledItems</span><span class="params">(<span class="keyword">final</span> List&lt;Integer&gt; items)</span> </span>&#123;</div><div class="line">   List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(items.size());</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> each : items) &#123;</div><div class="line">       <span class="comment">// /$&#123;JOB_NAME&#125;/sharding/$&#123;ITEM_ID&#125;/disabled</span></div><div class="line">       <span class="keyword">if</span> (jobNodeStorage.isJobNodeExisted(ShardingNode.getDisabledNode(each))) &#123;</div><div class="line">           result.add(each);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用 <code>ExecutionContextService#getJobShardingContext(...)</code> 方法，获取<strong>当前</strong>作业服务器分片上下文。</p></li></ul><p><strong>获取当前作业服务器分片上下文</strong></p><p>调用 <code>ExecutionContextService#getJobShardingContext(...)</code> 方法，获取<strong>当前</strong>作业服务器分片上下文：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ExecutionContextService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> ShardingContexts <span class="title">getJobShardingContext</span><span class="params">(<span class="keyword">final</span> List&lt;Integer&gt; shardingItems)</span> </span>&#123;</div><div class="line">   LiteJobConfiguration liteJobConfig = configService.load(<span class="keyword">false</span>);</div><div class="line">   <span class="comment">// 移除 正在运行中的作业分片项</span></div><div class="line">   removeRunningIfMonitorExecution(liteJobConfig.isMonitorExecution(), shardingItems);</div><div class="line">   <span class="comment">//</span></div><div class="line">   <span class="keyword">if</span> (shardingItems.isEmpty()) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ShardingContexts(buildTaskId(liteJobConfig, shardingItems), liteJobConfig.getJobName(), liteJobConfig.getTypeConfig().getCoreConfig().getShardingTotalCount(), </div><div class="line">               liteJobConfig.getTypeConfig().getCoreConfig().getJobParameter(), Collections.&lt;Integer, String&gt;emptyMap());</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 解析分片参数</span></div><div class="line">   Map&lt;Integer, String&gt; shardingItemParameterMap = <span class="keyword">new</span> ShardingItemParameters(liteJobConfig.getTypeConfig().getCoreConfig().getShardingItemParameters()).getMap();</div><div class="line">   <span class="comment">// 创建 分片上下文集合</span></div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ShardingContexts(buildTaskId(liteJobConfig, shardingItems), <span class="comment">//</span></div><div class="line">           liteJobConfig.getJobName(), liteJobConfig.getTypeConfig().getCoreConfig().getShardingTotalCount(),</div><div class="line">           liteJobConfig.getTypeConfig().getCoreConfig().getJobParameter(),</div><div class="line">           getAssignedShardingItemParameterMap(shardingItems, shardingItemParameterMap)); <span class="comment">// 获得当前作业节点的分片参数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>#removeRunningIfMonitorExecution()</code> 方法，移除正在运行中的作业分片项。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeRunningIfMonitorExecution</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> monitorExecution, <span class="keyword">final</span> List&lt;Integer&gt; shardingItems)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (!monitorExecution) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   List&lt;Integer&gt; runningShardingItems = <span class="keyword">new</span> ArrayList&lt;&gt;(shardingItems.size());</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> each : shardingItems) &#123;</div><div class="line">       <span class="keyword">if</span> (isRunning(each)) &#123;</div><div class="line">           runningShardingItems.add(each); <span class="comment">// /$&#123;JOB_NAME&#125;/sharding/$&#123;ITEM_ID&#125;/running</span></div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   shardingItems.removeAll(runningShardingItems);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> shardingItem)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> jobNodeStorage.isJobNodeExisted(ShardingNode.getRunningNode(shardingItem));</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>使用 ShardingItemParameters 解析作业分片参数。例如作业分片参数( <code>JobCoreConfiguration.shardingItemParameters=&quot;0=Beijing,1=Shanghai,2=Guangzhou&quot;</code> ) 解析结果：<br>  <img src="http://www.iocoder.cn/images/Elastic-Job/2017_10_31/04.png" alt=""></p><ul><li>ShardingItemParameters 代码清晰易懂，点击<a href="https://github.com/dangdangdotcom/elastic-job/blob/fd45d3799565f69c6b604db83f78629d8c9a70cd/elastic-job-common/elastic-job-common-core/src/main/java/com/dangdang/ddframe/job/util/config/ShardingItemParameters.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a>直接查看。</li></ul></li><li><p>调用 <code>#buildTaskId(...)</code> 方法，创建作业任务ID( <code>ShardingContexts.taskId</code> )：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">buildTaskId</span><span class="params">(<span class="keyword">final</span> LiteJobConfiguration liteJobConfig, <span class="keyword">final</span> List&lt;Integer&gt; shardingItems)</span> </span>&#123;</div><div class="line">   JobInstance jobInstance = JobRegistry.getInstance().getJobInstance(jobName);</div><div class="line">   <span class="keyword">return</span> Joiner.on(<span class="string">"@-@"</span>).join(liteJobConfig.getJobName(), Joiner.on(<span class="string">","</span>).join(shardingItems), <span class="string">"READY"</span>, </div><div class="line">           <span class="keyword">null</span> == jobInstance.getJobInstanceId() ? <span class="string">"127.0.0.1@-@1"</span> : jobInstance.getJobInstanceId()); </div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>taskId</code> = <code>${JOB_NAME}</code> + <code>@-@</code> + <code>${SHARDING_ITEMS}</code> + <code>@-@</code> + <code>READY</code> + <code>@-@</code> + <code>${IP}</code> + <code>@-@</code> + <code>${PID}</code>。例如：<code>javaSimpleJob@-@0,1,2@-@READY@-@192.168.3.2@-@38330</code>。</li></ul></li><li><p>调用 <code>#getAssignedShardingItemParameterMap(...)</code> 方法，获得当前作业节点的分片参数。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">private</span> Map&lt;Integer, String&gt; <span class="title">getAssignedShardingItemParameterMap</span><span class="params">(<span class="keyword">final</span> List&lt;Integer&gt; shardingItems, <span class="keyword">final</span> Map&lt;Integer, String&gt; shardingItemParameterMap)</span> </span>&#123;</div><div class="line">       Map&lt;Integer, String&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;(shardingItemParameterMap.size(), <span class="number">1</span>);</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> each : shardingItems) &#123;</div><div class="line">           result.put(each, shardingItemParameterMap.get(each));</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    ```    </div><div class="line"></div><div class="line">* ShardingContexts，分片上下文集合。</div><div class="line">    ```Java</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingContexts</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4585977349142082152L</span>;</div><div class="line">        </div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 作业任务ID.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String taskId;</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 作业名称.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String jobName;</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 分片总数.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> shardingTotalCount;</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 作业自定义参数.</span></div><div class="line"><span class="comment">         * 可以配置多个相同的作业, 但是用不同的参数作为不同的调度实例.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String jobParameter;</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 分配于本作业实例的分片项和参数的Map.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, String&gt; shardingItemParameters;</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 作业事件采样统计数.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> jobEventSamplingCount;</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 当前作业事件采样统计数.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="meta">@Setter</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> currentJobEventSamplingCount;</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 是否允许可以发送作业事件.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="meta">@Setter</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> allowSendJobEvent = <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><ul><li><code>jobEventSamplingCount</code>，<code>currentJobEventSamplingCount</code> 在 Elastic-Job-Lite 暂未还使用，在 Elastic-Job-Cloud 使用。</li></ul></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>旁白君：小伙伴，更新了干货嘛，双击 666。<br>芋道君：那必须的嘛，而且这么勤快更新！是不是应该分享一波朋友圈。</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_10_31/05.png" alt=""></p><p>道友，赶紧上车，分享一波朋友圈！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. 作业分片条件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;
      
    
    </summary>
    
      <category term="Elastic-Job-Lite" scheme="http://www.iocoder.cn/categories/Elastic-Job-Lite/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Lite 源码分析 —— 作业分片策略</title>
    <link href="http://www.iocoder.cn/Elastic-Job/job-sharding-strategy/"/>
    <id>http://www.iocoder.cn/Elastic-Job/job-sharding-strategy/</id>
    <published>2017-10-25T16:00:00.000Z</published>
    <updated>2017-09-06T10:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p><ul><li><a href="#">1. 概述</a></li><li><a href="#">2. 自带作业分片策略</a><ul><li><a href="#">2.1 AverageAllocationJobShardingStrategy</a></li><li><a href="#">2.2 OdevitySortByNameJobShardingStrategy</a></li><li><a href="#">2.3 RotateServerByNameJobShardingStrategy</a></li></ul></li><li><a href="#">3. 自定义作业分片策略</a></li><li><a href="#">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Lite 作业分片策略</strong>。</p><p>涉及到主要类的类图如下( <a href="http://www.iocoder.cn/images/Elastic-Job/2017_10_26/01.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_10_26/01.png" alt=""></p><blockquote><p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p></blockquote><h1 id="2-自带作业分片策略"><a href="#2-自带作业分片策略" class="headerlink" title="2. 自带作业分片策略"></a>2. 自带作业分片策略</h1><p>JobShardingStrategy，作业分片策略<strong>接口</strong>。分片策略通过实现接口的 <code>#sharding(...)</code> 方法提供作业分片的<strong>计算</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JobShardingStrategy</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 作业分片.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> jobInstances 所有参与分片的单元列表</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> jobName 作业名称</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> shardingTotalCount 分片总数</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 分片结果</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    Map&lt;JobInstance, List&lt;Integer&gt;&gt; sharding(List&lt;JobInstance&gt; jobInstances, String jobName, <span class="keyword">int</span> shardingTotalCount);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Elastic-Job-Lite 提供三种自带的作业分片策略：</p><ul><li>AverageAllocationJobShardingStrategy：基于平均分配算法的分片策略。</li><li>OdevitySortByNameJobShardingStrategy：根据作业名的哈希值奇偶数决定IP升降序算法的分片策略。</li><li>RotateServerByNameJobShardingStrategy：根据作业名的哈希值对作业节点列表进行轮转的分片策略。</li></ul><h2 id="2-1-AverageAllocationJobShardingStrategy"><a href="#2-1-AverageAllocationJobShardingStrategy" class="headerlink" title="2.1 AverageAllocationJobShardingStrategy"></a>2.1 AverageAllocationJobShardingStrategy</h2><p>AverageAllocationJobShardingStrategy，基于平均分配算法的分片策略。<strong>Elastic-Job-Lite 默认的作业分片策略</strong>。</p><blockquote><p>如果分片不能整除，则不能整除的多余分片将依次追加到序号小的作业节点。如：<br>如果有3台作业节点，分成9片，则每台作业节点分到的分片是：1=[0,1,2], 2=[3,4,5], 3=[6,7,8]<br>如果有3台作业节点，分成8片，则每台作业节点分到的分片是：1=[0,1,6], 2=[2,3,7], 3=[4,5]<br>如果有3台作业节点，分成10片，则每台作业节点分到的分片是：1=[0,1,2,9], 2=[3,4,5], 3=[6,7,8]  </p></blockquote><p>代码实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AverageAllocationJobShardingStrategy</span> <span class="keyword">implements</span> <span class="title">JobShardingStrategy</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Map&lt;JobInstance, List&lt;Integer&gt;&gt; sharding(<span class="keyword">final</span> List&lt;JobInstance&gt; jobInstances, <span class="keyword">final</span> String jobName, <span class="keyword">final</span> <span class="keyword">int</span> shardingTotalCount) &#123;</div><div class="line">        <span class="comment">// 不存在 作业运行实例</span></div><div class="line">        <span class="keyword">if</span> (jobInstances.isEmpty()) &#123;</div><div class="line">            <span class="keyword">return</span> Collections.emptyMap();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 分配能被整除的部分</span></div><div class="line">        Map&lt;JobInstance, List&lt;Integer&gt;&gt; result = shardingAliquot(jobInstances, shardingTotalCount);</div><div class="line">        <span class="comment">// 分配不能被整除的部分</span></div><div class="line">        addAliquant(jobInstances, shardingTotalCount, result);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>#shardingAliquot(...)</code> 方法分配能<strong>被整除</strong>的部分。能整除的咱就不举例子。如果有 3 台作业节点，分成 8 片，被整除的部分是前 6 片 [0, 1, 2, 3, 4, 5]，调用该方法结果：1=[0,1], 2=[2,3], 3=[4,5]。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> Map&lt;JobInstance, List&lt;Integer&gt;&gt; shardingAliquot(<span class="keyword">final</span> List&lt;JobInstance&gt; shardingUnits, <span class="keyword">final</span> <span class="keyword">int</span> shardingTotalCount) &#123;</div><div class="line">   Map&lt;JobInstance, List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(shardingTotalCount, <span class="number">1</span>);</div><div class="line">   <span class="keyword">int</span> itemCountPerSharding = shardingTotalCount / shardingUnits.size(); <span class="comment">// 每个作业运行实例分配的平均分片数</span></div><div class="line">   <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">   <span class="keyword">for</span> (JobInstance each : shardingUnits) &#123;</div><div class="line">       List&lt;Integer&gt; shardingItems = <span class="keyword">new</span> ArrayList&lt;&gt;(itemCountPerSharding + <span class="number">1</span>);</div><div class="line">       <span class="comment">// 顺序向下分配</span></div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = count * itemCountPerSharding; i &lt; (count + <span class="number">1</span>) * itemCountPerSharding; i++) &#123;</div><div class="line">           shardingItems.add(i);</div><div class="line">       &#125;</div><div class="line">       result.put(each, shardingItems);</div><div class="line">       count++;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用 <code>#addAliquant(...)</code> 方法分配能<strong>不被整除</strong>的部分。继续上面的例子。不能被整除的部分是后 2 片 [6, 7]，调用该方法结果：1=[0,1] + <strong>[6]</strong>, 2=[2,3] + <strong>[7]</strong>, 3=[4,5]。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addAliquant</span><span class="params">(<span class="keyword">final</span> List&lt;JobInstance&gt; shardingUnits, <span class="keyword">final</span> <span class="keyword">int</span> shardingTotalCount, <span class="keyword">final</span> Map&lt;JobInstance, List&lt;Integer&gt;&gt; shardingResults)</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> aliquant = shardingTotalCount % shardingUnits.size(); <span class="comment">// 余数</span></div><div class="line">   <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">   <span class="keyword">for</span> (Map.Entry&lt;JobInstance, List&lt;Integer&gt;&gt; entry : shardingResults.entrySet()) &#123;</div><div class="line">       <span class="keyword">if</span> (count &lt; aliquant) &#123;</div><div class="line">           entry.getValue().add(shardingTotalCount / shardingUnits.size() * shardingUnits.size() + count);</div><div class="line">       &#125;</div><div class="line">       count++;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p><strong>如何实现主备</strong></p><p>通过作业配置设置总分片数为 1 ( <code>JobCoreConfiguration.shardingTotalCount = 1</code> )，只有一个作业分片能够分配到作业分片项，从而达到<strong>一主N备</strong>。</p><h2 id="2-2-OdevitySortByNameJobShardingStrategy"><a href="#2-2-OdevitySortByNameJobShardingStrategy" class="headerlink" title="2.2 OdevitySortByNameJobShardingStrategy"></a>2.2 OdevitySortByNameJobShardingStrategy</h2><p>OdevitySortByNameJobShardingStrategy，根据作业名的哈希值奇偶数决定IP升降序算法的分片策略。</p><blockquote><p>作业名的哈希值为奇数则IP <strong>降序</strong>.<br>作业名的哈希值为偶数则IP <strong>升序</strong>.<br>用于不同的作业平均分配负载至不同的作业节点.<br>如:   </p><ol><li>如果有3台作业节点, 分成2片, 作业名称的哈希值为奇数, 则每台作业节点分到的分片是: 1=[ ], 2=[1], 3=[0].  </li><li>如果有3台作业节点, 分成2片, 作业名称的哈希值为偶数, 则每台作业节点分到的分片是: 1=[0], 2=[1], 3=[ ].</li></ol></blockquote><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> Map&lt;JobInstance, List&lt;Integer&gt;&gt; sharding(<span class="keyword">final</span> List&lt;JobInstance&gt; jobInstances, <span class="keyword">final</span> String jobName, <span class="keyword">final</span> <span class="keyword">int</span> shardingTotalCount) &#123;</div><div class="line">   <span class="keyword">long</span> jobNameHash = jobName.hashCode();</div><div class="line">   <span class="keyword">if</span> (<span class="number">0</span> == jobNameHash % <span class="number">2</span>) &#123;</div><div class="line">       Collections.reverse(jobInstances);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> averageAllocationJobShardingStrategy.sharding(jobInstances, jobName, shardingTotalCount);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>从实现代码上，仿佛和 IP 升降序没什么关系？答案在传递进来的参数 <code>jobInstances</code>。<code>jobInstances</code> 已经是按照 IP 进行<strong>降序</strong>的数组。所以当判断到作业名的哈希值为偶数时，进行数组反转( <code>Collections#reverse(...)</code> )实现按照 IP <strong>升序</strong>。下面看下为什么说<code>jobInstances</code> 已经按照 IP 进行<strong>降序</strong>：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ZookeeperRegistryCenter.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getChildrenKeys</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       List&lt;String&gt; result = client.getChildren().forPath(key);</div><div class="line">       Collections.sort(result, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</div><div class="line">           </div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">final</span> String o1, <span class="keyword">final</span> String o2)</span> </span>&#123;</div><div class="line">               <span class="keyword">return</span> o2.compareTo(o1);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">       <span class="keyword">return</span> result;</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       RegExceptionHandler.handleException(ex);</div><div class="line">       <span class="keyword">return</span> Collections.emptyList();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用 <code>AverageAllocationJobShardingStrategy#sharding(...)</code> 方法完成最终作业分片计算。</p></li></ul><h2 id="2-3-RotateServerByNameJobShardingStrategy"><a href="#2-3-RotateServerByNameJobShardingStrategy" class="headerlink" title="2.3 RotateServerByNameJobShardingStrategy"></a>2.3 RotateServerByNameJobShardingStrategy</h2><p>RotateServerByNameJobShardingStrategy，根据作业名的哈希值对作业节点列表进行<strong>轮转</strong>的分片策略。这里的<strong>轮转</strong>怎么定义呢？如果有 3 台作业节点，顺序为 [0, 1, 2]，如果作业名的哈希值根据作业分片总数取模为 1, 作业节点顺序变为 [1, 2, 0]。</p><p><strong>分片的目的</strong>，是将作业的负载合理的分配到不同的作业节点上，要避免分片策略总是让固定的作业节点负载特别大，其它工作节点负载特别小。这个也是为什么<strong>官方</strong>对比 RotateServerByNameJobShardingStrategy、AverageAllocationJobShardingStrategy 如下：</p><blockquote><p>AverageAllocationJobShardingStrategy的缺点是，一旦分片数小于作业作业节点数，作业将永远分配至IP地址靠前的作业节点，导致IP地址靠后的作业节点空闲。如：<br>OdevitySortByNameJobShardingStrategy则可以根据作业名称重新分配作业节点负载。<br>如果有3台作业节点，分成2片，作业名称的哈希值为奇数，则每台作业节点分到的分片是：1=[0], 2=[1], 3=[]<br>如果有3台作业节点，分成2片，作业名称的哈希值为偶数，则每台作业节点分到的分片是：3=[0], 2=[1], 1=[]  </p></blockquote><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RotateServerByNameJobShardingStrategy</span> <span class="keyword">implements</span> <span class="title">JobShardingStrategy</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> AverageAllocationJobShardingStrategy averageAllocationJobShardingStrategy = <span class="keyword">new</span> AverageAllocationJobShardingStrategy();</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Map&lt;JobInstance, List&lt;Integer&gt;&gt; sharding(<span class="keyword">final</span> List&lt;JobInstance&gt; jobInstances, <span class="keyword">final</span> String jobName, <span class="keyword">final</span> <span class="keyword">int</span> shardingTotalCount) &#123;</div><div class="line">        <span class="keyword">return</span> averageAllocationJobShardingStrategy.sharding(rotateServerList(jobInstances, jobName), jobName, shardingTotalCount);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> List&lt;JobInstance&gt; <span class="title">rotateServerList</span><span class="params">(<span class="keyword">final</span> List&lt;JobInstance&gt; shardingUnits, <span class="keyword">final</span> String jobName)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> shardingUnitsSize = shardingUnits.size();</div><div class="line">        <span class="keyword">int</span> offset = Math.abs(jobName.hashCode()) % shardingUnitsSize; <span class="comment">// 轮转开始位置</span></div><div class="line">        <span class="keyword">if</span> (<span class="number">0</span> == offset) &#123;</div><div class="line">            <span class="keyword">return</span> shardingUnits;</div><div class="line">        &#125;</div><div class="line">        List&lt;JobInstance&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(shardingUnitsSize);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shardingUnitsSize; i++) &#123;</div><div class="line">            <span class="keyword">int</span> index = (i + offset) % shardingUnitsSize;</div><div class="line">            result.add(shardingUnits.get(index));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>#rotateServerList(...)</code> 实现作业节点数组<strong>轮转</strong>。</li><li>调用 <code>AverageAllocationJobShardingStrategy#sharding(...)</code> 方法完成最终作业分片计算。</li></ul><h1 id="3-自定义作业分片策略"><a href="#3-自定义作业分片策略" class="headerlink" title="3. 自定义作业分片策略"></a>3. 自定义作业分片策略</h1><p>可能在你的业务场景下，需要实现自定义的作业分片策略。通过定义类实现 JobShardingStrategy 接口即可：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OOXXShardingStrategy</span> <span class="keyword">implements</span> <span class="title">JobShardingStrategy</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Map&lt;JobInstance, List&lt;Integer&gt;&gt; sharding(<span class="keyword">final</span> List&lt;JobInstance&gt; jobInstances, <span class="keyword">final</span> String jobName, <span class="keyword">final</span> <span class="keyword">int</span> shardingTotalCount) &#123;</div><div class="line">        <span class="comment">// 实现逻辑</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>实现后，配置实现类的<strong>全路径</strong>到 Lite作业配置( LiteJobConfiguration )的 <code>jobShardingStrategyClass</code> 属性。</p><p>作业进行分片计算时，作业分片策略工厂( JobShardingStrategyFactory ) 会创建作业分片策略实例：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobShardingStrategyFactory</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获取作业分片策略实例.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> jobShardingStrategyClassName 作业分片策略类名</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 作业分片策略实例</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JobShardingStrategy <span class="title">getStrategy</span><span class="params">(<span class="keyword">final</span> String jobShardingStrategyClassName)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (Strings.isNullOrEmpty(jobShardingStrategyClassName)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AverageAllocationJobShardingStrategy();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Class&lt;?&gt; jobShardingStrategyClass = Class.forName(jobShardingStrategyClassName);</div><div class="line">            <span class="keyword">if</span> (!JobShardingStrategy.class.isAssignableFrom(jobShardingStrategyClass)) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> JobConfigurationException(<span class="string">"Class '%s' is not job strategy class"</span>, jobShardingStrategyClassName);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> (JobShardingStrategy) jobShardingStrategyClass.newInstance();</div><div class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> ClassNotFoundException | InstantiationException | IllegalAccessException ex) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JobConfigurationException(<span class="string">"Sharding strategy class '%s' config error, message details are '%s'"</span>, jobShardingStrategyClassName, ex.getMessage());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>旁白君：雾草，刚夸奖你，就又开始水更。<br>芋道君：咳咳咳，作业分片策略炒鸡重要的好不好！嘿嘿嘿，为<a href="http://www.iocoder.cn/Elastic-Job/job-sharding/?self">《Elastic-Job-Lite 源码分析 —— 作业分片》</a>做个铺垫嘛。</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_10_26/02.png" alt=""></p><p>道友，赶紧上车，分享一波朋友圈！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. 自带作业分片策略&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;
      
    
    </summary>
    
      <category term="Elastic-Job-Lite" scheme="http://www.iocoder.cn/categories/Elastic-Job-Lite/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Lite 源码分析 —— 主节点选举</title>
    <link href="http://www.iocoder.cn/Elastic-Job/election/"/>
    <id>http://www.iocoder.cn/Elastic-Job/election/</id>
    <published>2017-10-20T16:00:00.000Z</published>
    <updated>2017-09-06T10:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p><ul><li><a href="">1. 概述</a></li><li><a href="">2. 为什么需要选举主节点</a></li><li><a href="">3. 选举主节点</a></li><li><a href="">4. 删除主节点</a></li><li><a href="">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Lite 主节点选举</strong>。</p><p>建议前置阅读：</p><ul><li><a href="http://www.iocoder.cn/Elastic-Job/reg-center-zookeeper/?self">《Elastic-Job-Lite 源码分析 —— 注册中心》</a></li><li><a href="http://www.iocoder.cn/Elastic-Job/job-storage/?self">《Elastic-Job-Lite 源码分析 —— 作业数据存储》</a></li><li><a href="http://www.iocoder.cn/Elastic-Job/reg-center-zookeeper-listener/?self">《Elastic-Job-Lite 源码分析 —— 注册中心监听器》</a></li></ul><p>涉及到主要类的类图如下( <a href="http://www.iocoder.cn/images/Elastic-Job/2017_10_21/01.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_10_21/01.png" alt=""></p><ul><li>粉色的类在 <code>com.dangdang.ddframe.job.lite.internal.election</code> 包下，实现了 Elastic-Job-Lite 主节点选举。</li></ul><blockquote><p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p></blockquote><h1 id="2-为什么需要选举主节点"><a href="#2-为什么需要选举主节点" class="headerlink" title="2. 为什么需要选举主节点"></a>2. 为什么需要选举主节点</h1><p>首先我们来看一段<strong>官方</strong>对 Elastic-Job-Lite 的介绍：</p><blockquote><p>Elastic-Job-Lite 定位为轻量级无中心化解决方案，使用 jar 包的形式提供分布式任务的协调服务。</p></blockquote><p><strong>无中心化</strong>，意味着 Elastic-Job-Lite 不存在<strong>一个中心</strong>执行一些操作，例如：分配作业分片项。Elastic-Job-Lite 选举主节点，通过主节点进行作业分片项分配。目前，必须在主节点执行的操作有：分配作业分片项，调解分布式作业不一致状态。</p><p>另外，主节点的选举是以<strong>作业为维度</strong>。例如：有一个 Elastic-Job-Lite 集群有三个作业节点 <code>A</code>、<code>B</code>、<code>C</code>，存在两个作业 <code>a</code>、<code>b</code>，可能 <code>a</code> 作业的主节点是 <code>C</code>，<code>b</code> 作业的主节点是 <code>A</code>。</p><h1 id="3-选举主节点"><a href="#3-选举主节点" class="headerlink" title="3. 选举主节点"></a>3. 选举主节点</h1><p>调用 <code>LeaderService#electLeader()</code> 选举主节点。</p><p>大体流程如下( <a href="http://www.iocoder.cn/images/Elastic-Job/2017_10_21/02.png">打开大图</a> )：<br><img src="http://www.iocoder.cn/images/Elastic-Job/2017_10_21/02.png" alt=""></p><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LeaderService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 选举主节点.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">electLeader</span><span class="params">()</span> </span>&#123;</div><div class="line">   log.debug(<span class="string">"Elect a new leader now."</span>);</div><div class="line">   jobNodeStorage.executeInLeader(LeaderNode.LATCH, <span class="keyword">new</span> LeaderElectionExecutionCallback());</div><div class="line">   log.debug(<span class="string">"Leader election completed."</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// JobNodeStorage.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeInLeader</span><span class="params">(<span class="keyword">final</span> String latchNode, <span class="keyword">final</span> LeaderExecutionCallback callback)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> (LeaderLatch latch = <span class="keyword">new</span> LeaderLatch(getClient(), jobNodePath.getFullPath(latchNode))) &#123;</div><div class="line">       latch.start();</div><div class="line">       latch.await();</div><div class="line">       callback.execute();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       handleException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// LeaderElectionExecutionCallback.java</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LeaderElectionExecutionCallback</span> <span class="keyword">implements</span> <span class="title">LeaderExecutionCallback</span> </span>&#123;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (!hasLeader()) &#123; <span class="comment">// 当前无主节点</span></div><div class="line">           jobNodeStorage.fillEphemeralJobNode(LeaderNode.INSTANCE, JobRegistry.getInstance().getJobInstance(jobName).getJobInstanceId());</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>使用 Curator LeaderLatch 分布式锁，<strong>保证同一时间有且仅有一个工作节点</strong>能够调用 <code>LeaderElectionExecutionCallback#execute()</code> 方法执行主节点设置。Curator LeaderLatch 在<a href="http://www.iocoder.cn/Elastic-Job/reg-center-zookeeper/?self">《Elastic-Job-Lite 源码分析 —— 注册中心》「3.1 在主节点执行操作」</a>有详细解析。</li><li><p>在 <code>LeaderElectionExecutionCallback#execute()</code> 为什么要调用 <code>#hasLeader()</code> 呢？LeaderLatch <strong>只保证同一时间有且仅有一个工作节点</strong>，在获得分布式锁的工作节点结束逻辑后，第二个工作节点会开始逻辑，如果不判断当前是否有主节点，原来的主节点会被覆盖。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LeaderService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 判断是否已经有主节点.</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * <span class="doctag">@return</span> 是否已经有主节点</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasLeader</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> jobNodeStorage.isJobNodeExisted(LeaderNode.INSTANCE);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>选举成功后，Zookeeper 存储<strong>作业</strong>的主节点：<code>/${JOB_NAME}/leader/electron/instance</code> 为当前节点。该节点为<strong>临时</strong>节点。</p>  <figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 7] get /elastic-job-example-lite-java/javaSimpleJob/leader/election/instance</div><div class="line">192.168.16.137@-@82496</div></pre></td></tr></table></figure></li></ul><p><strong>选举主节点时机</strong></p><p><strong>第一种</strong>，注册作业启动信息时。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 注册作业启动信息.</span></div><div class="line"><span class="comment">* </span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> enabled 作业是否启用</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStartUpInfo</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> enabled)</span> </span>&#123;</div><div class="line">   <span class="comment">// .... 省略部分方法</span></div><div class="line">   <span class="comment">// 选举 主节点</span></div><div class="line">   leaderService.electLeader();</div><div class="line">   <span class="comment">// .... 省略部分方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>新的作业启动时，即能保证选举出主节点。<ul><li>当该作业<strong>不存在</strong>主节点时，当前作业节点<strong>成为</strong>主节点。</li><li>当该作业<strong>存在</strong>主节点，当前作业节主节点<strong>不变</strong>。</li></ul></li></ul><p><strong>第二种</strong>，节点数据发生变化时。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LeaderElectionJobListener</span> <span class="keyword">extends</span> <span class="title">AbstractJobListener</span> </span>&#123;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String data)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (!JobRegistry.getInstance().isShutdown(jobName) &amp;&amp; (isActiveElection(path, data) || isPassiveElection(path, eventType))) &#123;</div><div class="line">           leaderService.electLeader();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>符合重新选举主节点分成两种情况。</li><li><p><strong>主动</strong>选举 <code>#isActiveElection(...)</code></p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isActiveElection</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> String data)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> !leaderService.hasLeader() <span class="comment">// 不存在主节点</span></div><div class="line">          &amp;&amp; isLocalServerEnabled(path, data); <span class="comment">// 开启作业</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLocalServerEnabled</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> String data)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> serverNode.isLocalServerPath(path) </div><div class="line">       &amp;&amp; !ServerStatus.DISABLED.name().equals(data);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>当作业被禁用( <code>LiteJobConfiguration.disabled = true</code> )时，作业是不存在主节点的。那有同学就有疑问了？<code>LeaderService#electLeader()</code> 没做这个限制呀，作业<strong>注册作业启动信息时</strong>也进行了选举。在「4. 删除主节点」小结，我们会解开这个答案。这里大家先记住这个结论。</li><li>根据上面我们说的结论，这里就很好理解了，<code>#isActiveElection()</code> 方法判断了两个条件：( 1 ) 不存在主节点；( 2 ) 开启作业，不再禁用，因此需要进行主节点选举落。</li><li>这里判断开启作业的方法 <code>#isLocalServerEnabled(...)</code> 有点特殊，它不是通过作业节点是否处于开启状态，而是该数据不是将作业节点更新成关闭状态。举个例子：作业节点处于<strong>禁用</strong>状态，使用<strong>运维平台</strong>设置作业节点开启，会进行主节点选举；作业节点处于<strong>开启</strong>状态，使用<strong>运维平台</strong>设置作业节点禁用，不会进行主节点选举。</li></ul></li><li><p><strong>被动</strong>选举 <code>#isPassiveElection(...)</code></p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPassiveElection</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> isLeaderCrashed(path, eventType) <span class="comment">// 主节点 Crashed</span></div><div class="line">          &amp;&amp; serverService.isAvailableServer(JobRegistry.getInstance().getJobInstance(jobName).getIp()); <span class="comment">// 当前节点正在运行中（未挂掉）</span></div><div class="line">&#125;</div><div class="line">   </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLeaderCrashed</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> leaderNode.isLeaderInstancePath(path) &amp;&amp; Type.NODE_REMOVED == eventType;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>当主节点因为各种情况( 「4. 删除主节点」会列举 )被删除，需要重新进行选举。对的，<strong>必须主节点被删除后才可以重新进行选举</strong>。</li><li><code>#isPassiveElection(...)</code> 方法判断了两个条件：( 1 ) 原主节点被删除；( 2 ) 当前节点正在运行中（未挂掉），可以参加主节点选举。</li><li><code>#isLeaderCrashed(...)</code> 方法虽然命名带有 <code>Crashed</code> 英文，实际主作业节点<strong>正常</strong>退出也符合<strong>被动</strong>选举条件。</li></ul></li></ul><p><strong>等待主节点选举完成</strong></p><p>必须在主节点执行的操作，执行之前，需要判断当前节点是否为主节点。如果主节点已经选举好，可以直接进行判断。但是，不排除主节点还没选举到，因而需要阻塞等待到主节点选举完成后才能进行判断。</p><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LeaderService.java</span></div><div class="line">    </div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 判断当前节点是否是主节点.</span></div><div class="line"><span class="comment">* </span></div><div class="line"><span class="comment">* 如果主节点正在选举中而导致取不到主节点, 则阻塞至主节点选举完成再返回.</span></div><div class="line"><span class="comment">* </span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 当前节点是否是主节点</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeaderUntilBlock</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 不存在主节点 &amp;&amp; 有可用的服务器节点</span></div><div class="line">   <span class="keyword">while</span> (!hasLeader() &amp;&amp; serverService.hasAvailableServers()) &#123;</div><div class="line">       log.info(<span class="string">"Leader is electing, waiting for &#123;&#125; ms"</span>, <span class="number">100</span>);</div><div class="line">       BlockUtils.waitingShortTime();</div><div class="line">       <span class="keyword">if</span> (!JobRegistry.getInstance().isShutdown(jobName)</div><div class="line">               &amp;&amp; serverService.isAvailableServer(JobRegistry.getInstance().getJobInstance(jobName).getIp())) &#123; <span class="comment">// 当前服务器节点可用</span></div><div class="line">           electLeader();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 返回当前节点是否是主节点</span></div><div class="line">   <span class="keyword">return</span> isLeader();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>BlockUtils#waitingShortTime()</code> 方法，选举不到主节点进行等待，避免不间断、无间隔的进行主节点选举。</li></ul><h1 id="4-删除主节点"><a href="#4-删除主节点" class="headerlink" title="4. 删除主节点"></a>4. 删除主节点</h1><p>有主节点的选举，必然有主节点的删除，否则怎么进行<strong>重新选举</strong>。</p><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LeaderService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 删除主节点供重新选举.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeLeader</span><span class="params">()</span> </span>&#123;</div><div class="line">   jobNodeStorage.removeJobNodeIfExisted(LeaderNode.INSTANCE);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>删除主节点时机</strong></p><p><strong>第一种</strong>，主节点进程<strong>正常</strong>关闭时。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobShutdownHookPlugin</span> <span class="keyword">extends</span> <span class="title">ShutdownHookPlugin</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line">        CoordinatorRegistryCenter regCenter = JobRegistry.getInstance().getRegCenter(jobName);</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == regCenter) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        LeaderService leaderService = <span class="keyword">new</span> LeaderService(regCenter, jobName);</div><div class="line">        <span class="keyword">if</span> (leaderService.isLeader()) &#123;</div><div class="line">            leaderService.removeLeader(); <span class="comment">// 移除主节点</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">new</span> InstanceService(regCenter, jobName).removeInstance();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>这个比较好理解，退出进程，若该进程为主节点，需要将自己移除。</li></ul><p><strong>第二种</strong>，主节点进程 CRASHED 时。</p><p><code>${JOB_NAME}/leader/electron/instance</code> 是<strong>临时</strong>节点，主节点进程 CRASHED 后，超过最大会话时间，Zookeeper 自动进行删除，触发重新选举逻辑。</p><p><strong>第三种</strong>，作业被<strong>禁用</strong>时。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LeaderAbdicationJobListener</span> <span class="keyword">extends</span> <span class="title">AbstractJobListener</span> </span>&#123;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String data)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (leaderService.isLeader() &amp;&amp; isLocalServerDisabled(path, data)) &#123;</div><div class="line">           leaderService.removeLeader();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLocalServerDisabled</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> String data)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> serverNode.isLocalServerPath(path) &amp;&amp; ServerStatus.DISABLED.name().equals(data);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>这里就解答上面我们遗留的疑问。被禁用的作业<strong>注册作业启动信息时</strong>即使进行了主节点选举，也会被该监听器处理，移除该选举的主节点。</li></ul><p><strong>第四种</strong>，主节点进程<strong>远程</strong>关闭。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// InstanceShutdownStatusJobListener.java</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">InstanceShutdownStatusJobListener</span> <span class="keyword">extends</span> <span class="title">AbstractJobListener</span> </span>&#123;</div><div class="line">        </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String data)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (!JobRegistry.getInstance().isShutdown(jobName)</div><div class="line">               &amp;&amp; !JobRegistry.getInstance().getJobScheduleController(jobName).isPaused() <span class="comment">// 作业未暂停调度</span></div><div class="line">               &amp;&amp; isRemoveInstance(path, eventType) <span class="comment">// 移除【运行实例】事件</span></div><div class="line">               &amp;&amp; !isReconnectedRegistryCenter()) &#123; <span class="comment">// 运行实例被移除</span></div><div class="line">           schedulerFacade.shutdownInstance();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRemoveInstance</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> instanceNode.isLocalInstancePath(path) &amp;&amp; Type.NODE_REMOVED == eventType;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isReconnectedRegistryCenter</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> instanceService.isLocalJobInstanceExisted();</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// SchedulerFacade.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 终止作业调度.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdownInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (leaderService.isLeader()) &#123;</div><div class="line">       leaderService.removeLeader(); <span class="comment">// 移除主节点</span></div><div class="line">   &#125;</div><div class="line">   monitorService.close();</div><div class="line">   <span class="keyword">if</span> (reconcileService.isRunning()) &#123;</div><div class="line">       reconcileService.stopAsync();</div><div class="line">   &#125;</div><div class="line">   JobRegistry.getInstance().shutdown(jobName);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>远程</strong>关闭作业节点有两种方式：<ul><li>zkClient 发起命令：<code>rmr /${NAMESPACE}/${JOB_NAME}/instances/${JOB_INSTANCE_ID}</code>。</li><li>运维平台发起 <code>Shutdown</code> 操作。<code>Shutdown</code> 操作实质上就是第一种。<br>  <img src="http://www.iocoder.cn/images/Elastic-Job/2017_10_21/04.png" alt=""></li></ul></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>旁白君：哎哟，这次竟然分享了点干货 😈<br>芋道君：嘿呀嘿呀，必须的啊，虽然有点焦头烂额啦。  </p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_10_21/03.png" alt=""></p><p>道友，赶紧上车，分享一波朋友圈！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;2. 为什么需要选举主节点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&quot;
      
    
    </summary>
    
      <category term="Elastic-Job-Lite" scheme="http://www.iocoder.cn/categories/Elastic-Job-Lite/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Lite 源码分析 —— 注册中心监听器</title>
    <link href="http://www.iocoder.cn/Elastic-Job/reg-center-zookeeper-listener/"/>
    <id>http://www.iocoder.cn/Elastic-Job/reg-center-zookeeper-listener/</id>
    <published>2017-10-13T16:00:00.000Z</published>
    <updated>2017-09-06T10:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p><ul><li><a href="#">1. 概述</a></li><li><a href="#">2. ListenerManager</a></li><li><a href="#">3. AbstractListenerManager</a></li><li><a href="#">4. AbstractJobListener</a></li><li><a href="#">5. RegistryCenterConnectionStateListener</a></li><li><a href="#">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Lite 注册中心监听器</strong>。</p><p>建议前置阅读：</p><ul><li><a href="http://www.iocoder.cn/Elastic-Job/reg-center-zookeeper/?self">《Elastic-Job-Lite 源码分析 —— 注册中心》</a></li></ul><p>涉及到主要类的类图如下( <a href="http://www.iocoder.cn/images/Elastic-Job/2017_10_14/01.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_10_14/01.png" alt=""></p><blockquote><p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p></blockquote><h1 id="2-ListenerManager"><a href="#2-ListenerManager" class="headerlink" title="2. ListenerManager"></a>2. ListenerManager</h1><p>ListenerManager，作业注册中心的监听器管理者。管理者<strong>两类</strong>组件：</p><ul><li>监听管理器</li><li>注册中心连接状态监听器</li></ul><p>其中<strong>监听管理器</strong>管理着自己的作业注册中心监听器。</p><p>一起从代码层面看看：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerManager</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobNodeStorage jobNodeStorage;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ElectionListenerManager electionListenerManager;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ShardingListenerManager shardingListenerManager;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FailoverListenerManager failoverListenerManager;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MonitorExecutionListenerManager monitorExecutionListenerManager;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ShutdownListenerManager shutdownListenerManager;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TriggerListenerManager triggerListenerManager;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RescheduleListenerManager rescheduleListenerManager;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> GuaranteeListenerManager guaranteeListenerManager;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RegistryCenterConnectionStateListener regCenterConnectionStateListener;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>第一类：<code>electionListenerManager</code> / <code>shardingListenerManager</code> / <code>failoverListenerManager</code> / <code>MonitorExecutionListenerManager</code> / <code>shutdownListenerManager</code> / <code>triggerListenerManager</code> / <code>rescheduleListenerManager</code> / <code>guaranteeListenerManager</code> 是不同服务的<strong>监听管理器</strong>，都继承<strong>作业注册中心的监听器管理者的抽象类</strong>( AbstractListenerManager )。我们以下一篇文章会涉及到的<strong>分片监听管理器</strong>( ShardingListenerManager ) 来瞅瞅内部整体实现：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingListenerManager</span> <span class="keyword">extends</span> <span class="title">AbstractListenerManager</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">        addDataListener(<span class="keyword">new</span> ShardingTotalCountChangedJobListener());</div><div class="line">        addDataListener(<span class="keyword">new</span> ListenServersChangedJobListener());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ShardingTotalCountChangedJobListener</span> <span class="keyword">extends</span> <span class="title">AbstractJobListener</span> </span>&#123;</div><div class="line">        <span class="comment">// .... 省略方法</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ListenServersChangedJobListener</span> <span class="keyword">extends</span> <span class="title">AbstractJobListener</span> </span>&#123;</div><div class="line">        <span class="comment">// .... 省略方法</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>ShardingListenerManager 内部管理了 ShardingTotalCountChangedJobListener / ListenServersChangedJobListener 两个作业注册中心监听器。具体作业注册中心监听器是什么，有什么用途，下文会详细解析。</li></ul></li><li>第二类：<code>regCenterConnectionStateListener</code> 是注册中心连接状态监听器。下文也会详细解析。</li></ul><p>在<a href="http://www.iocoder.cn/Elastic-Job/job-init?self">《Elastic-Job-Lite 源码分析 —— 作业初始化》「3.2.4」注册作业启动信息</a>，我们看到作业初始化时，会开启所有注册中心监听器：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SchedulerFacade.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 注册作业启动信息.</span></div><div class="line"><span class="comment">* </span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> enabled 作业是否启用</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStartUpInfo</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> enabled)</span> </span>&#123;</div><div class="line">   <span class="comment">// 开启 所有监听器</span></div><div class="line">   listenerManager.startAllListeners();</div><div class="line">   <span class="comment">// .... 省略方法</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ListenerManager.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 开启所有监听器.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startAllListeners</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 开启 不同服务监听管理器</span></div><div class="line">   electionListenerManager.start();</div><div class="line">   shardingListenerManager.start();</div><div class="line">   failoverListenerManager.start();</div><div class="line">   monitorExecutionListenerManager.start();</div><div class="line">   shutdownListenerManager.start();</div><div class="line">   triggerListenerManager.start();</div><div class="line">   rescheduleListenerManager.start();</div><div class="line">   guaranteeListenerManager.start();</div><div class="line">   <span class="comment">// 开启 注册中心连接状态监听器</span></div><div class="line">   jobNodeStorage.addConnectionStateListener(regCenterConnectionStateListener);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="3-AbstractListenerManager"><a href="#3-AbstractListenerManager" class="headerlink" title="3. AbstractListenerManager"></a>3. AbstractListenerManager</h1><p>AbstractListenerManager，作业注册中心的监听器管理者的<strong>抽象类</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractListenerManager</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobNodeStorage jobNodeStorage;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractListenerManager</span><span class="params">(<span class="keyword">final</span> CoordinatorRegistryCenter regCenter, <span class="keyword">final</span> String jobName)</span> </span>&#123;</div><div class="line">        jobNodeStorage = <span class="keyword">new</span> JobNodeStorage(regCenter, jobName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 开启监听器.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 添加注册中心监听器</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> listener 注册中心监听器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addDataListener</span><span class="params">(<span class="keyword">final</span> TreeCacheListener listener)</span> </span>&#123;</div><div class="line">        jobNodeStorage.addDataListener(listener);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>#addDataListener()</code>，将作业注册中心的监听器添加到注册中心 TreeCache 的监听者里。<code>JobNodeStorage#addDataListener(...)</code> 在<a href="http://www.iocoder.cn/Elastic-Job/reg-center-zookeeper/?self">《Elastic-Job-Lite 源码分析 —— 作业初始化》「2.2」缓存</a>已经详细解析。</li><li><p>子类实现 <code>#start()</code> 方法实现监听器初始化。目前所有子类的实现都是将自己管理的注册中心监听器调用 <code>#addDataListener(...)</code>，还是以 ShardingListenerManager 举例子：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingListenerManager</span> <span class="keyword">extends</span> <span class="title">AbstractListenerManager</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">        addDataListener(<span class="keyword">new</span> ShardingTotalCountChangedJobListener());</div><div class="line">        addDataListener(<span class="keyword">new</span> ListenServersChangedJobListener());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h1 id="4-AbstractJobListener"><a href="#4-AbstractJobListener" class="headerlink" title="4. AbstractJobListener"></a>4. AbstractJobListener</h1><p>AbstractJobListener，作业注册中心的监听器<strong>抽象类</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractJobListener</span> <span class="keyword">implements</span> <span class="title">TreeCacheListener</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(<span class="keyword">final</span> CuratorFramework client, <span class="keyword">final</span> TreeCacheEvent event)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        ChildData childData = event.getData();</div><div class="line">        <span class="comment">// 忽略掉非数据变化的事件，例如 event.type 为 CONNECTION_SUSPENDED、CONNECTION_RECONNECTED、CONNECTION_LOST、INITIALIZED 事件</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == childData) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        String path = childData.getPath();</div><div class="line">        <span class="keyword">if</span> (path.isEmpty()) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        dataChanged(path, event.getType(), <span class="keyword">null</span> == childData.getData() ? <span class="string">""</span> : <span class="keyword">new</span> String(childData.getData(), Charsets.UTF_8));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 节点数据变化</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> path 节点路径</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> eventType 事件类型</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> data 数据</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String data)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>作业注册中心的监听器<strong>实现类</strong>实现 <code>#dataChanged(...)</code>，对节点数据变化进行处理。</li><li><code>#childEvent(...)</code> 屏蔽掉非节点数据变化事件，例如：CONNECTION_SUSPENDED、CONNECTION_RECONNECTED、CONNECTION_LOST、INITIALIZED 事件，只处理 NODE_ADDED、NODE_UPDATED、NODE_REMOVED 事件。</li></ul><p>我们再拿 ShardingListenerManager 举例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingListenerManager</span> <span class="keyword">extends</span> <span class="title">AbstractListenerManager</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ShardingTotalCountChangedJobListener</span> <span class="keyword">extends</span> <span class="title">AbstractJobListener</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String data)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (configNode.isConfigPath(path) &amp;&amp; <span class="number">0</span> != JobRegistry.getInstance().getCurrentShardingTotalCount(jobName)) &#123;</div><div class="line">                <span class="keyword">int</span> newShardingTotalCount = LiteJobConfigurationGsonFactory.fromJson(data).getTypeConfig().getCoreConfig().getShardingTotalCount();</div><div class="line">                <span class="keyword">if</span> (newShardingTotalCount != JobRegistry.getInstance().getCurrentShardingTotalCount(jobName)) &#123;</div><div class="line">                    shardingService.setReshardingFlag();</div><div class="line">                    JobRegistry.getInstance().setCurrentShardingTotalCount(jobName, newShardingTotalCount);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ListenServersChangedJobListener</span> <span class="keyword">extends</span> <span class="title">AbstractJobListener</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String data)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (!JobRegistry.getInstance().isShutdown(jobName) &amp;&amp; (isInstanceChange(eventType, path) || isServerChange(path))) &#123;</div><div class="line">                shardingService.setReshardingFlag();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isInstanceChange</span><span class="params">(<span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String path)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> instanceNode.isInstancePath(path) &amp;&amp; Type.NODE_UPDATED != eventType;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isServerChange</span><span class="params">(<span class="keyword">final</span> String path)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> serverNode.isServerPath(path);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>在<a href="http://www.iocoder.cn/Elastic-Job/job-sharding/?self">《Elastic-Job-Lite 源码解析 —— 任务分片》</a>详细解析。</li></ul><h1 id="5-RegistryCenterConnectionStateListener"><a href="#5-RegistryCenterConnectionStateListener" class="headerlink" title="5. RegistryCenterConnectionStateListener"></a>5. RegistryCenterConnectionStateListener</h1><p>RegistryCenterConnectionStateListener，实现 Curator ConnectionStateListener 接口，注册中心连接状态监听器。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RegistryCenterConnectionStateListener</span> <span class="keyword">implements</span> <span class="title">ConnectionStateListener</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(<span class="keyword">final</span> CuratorFramework client, <span class="keyword">final</span> ConnectionState newState)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (JobRegistry.getInstance().isShutdown(jobName)) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        JobScheduleController jobScheduleController = JobRegistry.getInstance().getJobScheduleController(jobName);</div><div class="line">        <span class="keyword">if</span> (ConnectionState.SUSPENDED == newState || ConnectionState.LOST == newState) &#123; <span class="comment">// Zookeeper 连接终端 或 连接丢失</span></div><div class="line">            <span class="comment">// 暂停作业调度</span></div><div class="line">            jobScheduleController.pauseJob();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ConnectionState.RECONNECTED == newState) &#123; <span class="comment">// Zookeeper 重新连上</span></div><div class="line">            <span class="comment">// 持久化作业服务器上线信息</span></div><div class="line">            serverService.persistOnline(serverService.isEnableServer(JobRegistry.getInstance().getJobInstance(jobName).getIp()));</div><div class="line">            <span class="comment">// 持久化作业运行实例上线相关信息</span></div><div class="line">            instanceService.persistOnline();</div><div class="line">            <span class="comment">// 清除本地分配的作业分片项运行中的标记</span></div><div class="line">            executionService.clearRunningInfo(shardingService.getLocalShardingItems());</div><div class="line">            <span class="comment">// 恢复作业调度</span></div><div class="line">            jobScheduleController.resumeJob();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>当注册中心连接 SUSPENDED 或 LOST 时，暂停<strong>本地</strong>作业调度：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobScheduleController.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">pauseJob</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">if</span> (!scheduler.isShutdown()) &#123;</div><div class="line">           scheduler.pauseAll();</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SchedulerException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>当注册中心重新连接成功( RECONNECTED )，恢复<strong>本地</strong>作业调度：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 恢复作业.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">resumeJob</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">if</span> (!scheduler.isShutdown()) &#123;</div><div class="line">          scheduler.resumeAll();</div><div class="line">      &#125;</div><div class="line">  &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SchedulerException ex) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(ex);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>旁白君：芋道君，你又水更了！<br>芋道君：是是是，是是是！</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_10_14/02.png" alt=""></p><p>道友，赶紧上车，分享一波朋友圈！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. ListenerManager&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a 
      
    
    </summary>
    
      <category term="Elastic-Job-Lite" scheme="http://www.iocoder.cn/categories/Elastic-Job-Lite/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Lite 源码分析 —— 作业数据存储</title>
    <link href="http://www.iocoder.cn/Elastic-Job/job-storage/"/>
    <id>http://www.iocoder.cn/Elastic-Job/job-storage/</id>
    <published>2017-10-06T16:00:00.000Z</published>
    <updated>2017-09-06T10:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p><ul><li><a href="#1-%E6%A6%82%E8%BF%B0">1. 概述</a></li><li><a href="#2-jobnodepath">2. JobNodePath</a></li><li><a href="#3-jobnodestorage">3. JobNodeStorage</a></li><li><a href="#4-configurationnode">4. ConfigurationNode</a></li><li><a href="#5-servernode">5. ServerNode</a></li><li><a href="#6-instancenode">6. InstanceNode</a></li><li><a href="#7-shardingnode">7. ShardingNode</a></li><li><a href="#8-leadernode">8. LeaderNode</a></li><li><a href="#9-failovernode">9. FailoverNode</a></li><li><a href="#10-guaranteenode">10. GuaranteeNode</a></li><li><a href="#666-%E5%BD%A9%E8%9B%8B">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Lite 作业数据存储</strong>。</p><p>涉及到主要类的类图如下( <a href="http://www.iocoder.cn/images/Elastic-Job/2017_10_07/01.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_10_07/01.png" alt=""></p><blockquote><p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p></blockquote><h1 id="2-JobNodePath"><a href="#2-JobNodePath" class="headerlink" title="2. JobNodePath"></a>2. JobNodePath</h1><p>JobNodePath，作业节点路径类。<strong>作业节点是在普通的节点前加上作业名称的前缀</strong>。</p><p>在 Zookeeper 看一个作业的数据存储：</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 65] ls /elastic-job-example-lite-java/javaSimpleJob</div><div class="line">[leader, servers, config, instances, sharding]</div></pre></td></tr></table></figure><ul><li><code>elastic-job-example-lite-java</code>：作业节点集群名，使用 <code>ZookeeperConfiguration.namespace</code> 属性配置。</li><li><code>javaSimpleJob</code>：作业名字，使用 <code>JobCoreConfiguration.jobName</code> 属性配置。</li><li><code>config</code> / <code>servers</code> / <code>instances</code> / <code>sharding</code> / <code>leader</code>：不同服务的数据存储节点路径。</li></ul><p>JobNodePath，注释很易懂，点击<a href="https://github.com/dangdangdotcom/elastic-job/blob/7dc099541a16de49f024fc59e46377a726be7f6b/elastic-job-lite/elastic-job-lite-core/src/main/java/com/dangdang/ddframe/job/lite/internal/storage/JobNodePath.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a>查看。这里我们梳理下 JobNodePath 和<strong>其它节点路径类</strong>的关系：</p><table><thead><tr><th style="text-align:left">Zookeeper 路径</th><th style="text-align:left">JobNodePath 静态属性</th><th style="text-align:left">JobNodePath 方法</th><th style="text-align:left">节点路径类</th></tr></thead><tbody><tr><td style="text-align:left"><code>config</code></td><td style="text-align:left">CONFIG_NODE</td><td style="text-align:left"><code>#getConfigNodePath()</code></td><td style="text-align:left">ConfigurationNode</td></tr><tr><td style="text-align:left"><code>servers</code></td><td style="text-align:left">SERVERS_NODE</td><td style="text-align:left"><code>#getServerNodePath()</code></td><td style="text-align:left">ServerNode</td></tr><tr><td style="text-align:left"><code>instances</code></td><td style="text-align:left">INSTANCES_NODE</td><td style="text-align:left"><code>#getInstancesNodePath()</code></td><td style="text-align:left">InstanceNode</td></tr><tr><td style="text-align:left"><code>sharding</code></td><td style="text-align:left">SHARDING_NODE</td><td style="text-align:left"><code>#getShardingNodePath()</code></td><td style="text-align:left">ShardingNode</td></tr><tr><td style="text-align:left"><code>leader</code></td><td style="text-align:left">/</td><td style="text-align:left"><code>#getFullPath(node)</code></td><td style="text-align:left">LeaderNode</td></tr><tr><td style="text-align:left"><code>leader/failover</code></td><td style="text-align:left">/</td><td style="text-align:left"><code>#getFullPath(node)</code></td><td style="text-align:left">FailoverNode</td></tr><tr><td style="text-align:left"><code>guarantee</code></td><td style="text-align:left">/</td><td style="text-align:left"><code>#getFullPath(node)</code></td><td style="text-align:left">GuaranteeNode</td></tr></tbody></table><h1 id="3-JobNodeStorage"><a href="#3-JobNodeStorage" class="headerlink" title="3. JobNodeStorage"></a>3. JobNodeStorage</h1><p>JobNodeStorage，作业节点数据访问类。</p><p>Elastic-Job-Lite 使用<strong>注册中心</strong>存储作业节点数据，JobNodeStorage 对注册中心提供的方法做下简单的封装提供调用。举个例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobNodeStorage.java</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> CoordinatorRegistryCenter regCenter;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> JobNodePath jobNodePath;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 判断作业节点是否存在.</span></div><div class="line"><span class="comment">* </span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> node 作业节点名称</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 作业节点是否存在</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isJobNodeExisted</span><span class="params">(<span class="keyword">final</span> String node)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> regCenter.isExisted(jobNodePath.getFullPath(node));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// JobNodePath.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获取节点全路径.</span></div><div class="line"><span class="comment">* </span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> node 节点名称</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 节点全路径</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFullPath</span><span class="params">(<span class="keyword">final</span> String node)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> String.format(<span class="string">"/%s/%s"</span>, jobName, node);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>传递的参数 <code>node</code> 只是简单的<strong>作业节点名称</strong>，通过调用 <code>JobNodePath#getFullPath(...)</code> 方法获取节点全路径。</li><li>其它方法类似，有兴趣的同学点击<a href="https://github.com/dangdangdotcom/elastic-job/blob/7dc099541a16de49f024fc59e46377a726be7f6b/elastic-job-lite/elastic-job-lite-core/src/main/java/com/dangdang/ddframe/job/lite/internal/storage/JobNodePath.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a>查看。</li></ul><h1 id="4-ConfigurationNode"><a href="#4-ConfigurationNode" class="headerlink" title="4. ConfigurationNode"></a>4. ConfigurationNode</h1><p>ConfigurationNode，配置节点路径。</p><p>在 Zookeeper 看一个作业的<strong>配置</strong>节点数据存储：</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 67] get /elastic-job-example-lite-java/javaSimpleJob/config</div><div class="line">&#123;<span class="string">"jobName"</span>:<span class="string">"javaSimpleJob"</span>,<span class="string">"jobClass"</span>:<span class="string">"com.dangdang.ddframe.job.example.job.simple.JavaSimpleJob"</span>,<span class="string">"jobType"</span>:<span class="string">"SIMPLE"</span>,<span class="string">"cron"</span>:<span class="string">"0/5 * * * * ?"</span>,<span class="string">"shardingTotalCount"</span>:3,<span class="string">"shardingItemParameters"</span>:<span class="string">"0\u003dBeijing,1\u003dShanghai,2\u003dGuangzhou"</span>,<span class="string">"jobParameter"</span>:<span class="string">""</span>,<span class="string">"failover"</span>:<span class="literal">true</span>,<span class="string">"misfire"</span>:<span class="literal">true</span>,<span class="string">"description"</span>:<span class="string">""</span>,<span class="string">"jobProperties"</span>:&#123;<span class="string">"job_exception_handler"</span>:<span class="string">"com.dangdang.ddframe.job.executor.handler.impl.DefaultJobExceptionHandler"</span>,<span class="string">"executor_service_handler"</span>:<span class="string">"com.dangdang.ddframe.job.executor.handler.impl.DefaultExecutorServiceHandler"</span>&#125;,<span class="string">"monitorExecution"</span>:<span class="literal">true</span>,<span class="string">"maxTimeDiffSeconds"</span>:-1,<span class="string">"monitorPort"</span>:-1,<span class="string">"jobShardingStrategyClass"</span>:<span class="string">""</span>,<span class="string">"reconcileIntervalMinutes"</span>:10,<span class="string">"disabled"</span>:<span class="literal">false</span>,<span class="string">"overwrite"</span>:<span class="literal">true</span>&#125;</div></pre></td></tr></table></figure><ul><li><code>/config</code> 是<strong>持久</strong>节点，存储Lite作业配置( LiteJobConfiguration ) JSON化字符串。</li></ul><p>ConfigurationNode 代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationNode</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ROOT = <span class="string">"config"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>ConfigurationNode 如何读取、存储，在<a href="http://www.iocoder.cn/Elastic-Job/job-config/?self">《Elastic-Job-Lite 源码分析 —— 作业配置》的「3.」作业配置服务</a>已经详细解析。</p><h1 id="5-ServerNode"><a href="#5-ServerNode" class="headerlink" title="5. ServerNode"></a>5. ServerNode</h1><p>ServerNode，服务器节点路径。</p><p>在 Zookeeper 看一个作业的<strong>服务器</strong>节点数据存储： </p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 72] ls /elastic-job-example-lite-java/javaSimpleJob/servers</div><div class="line">[192.168.16.164, 169.254.93.156, 192.168.252.57, 192.168.16.137, 192.168.3.2, 192.168.43.31]</div><div class="line">[zk: localhost:2181(CONNECTED) 73] get /elastic-job-example-lite-java/javaSimpleJob/servers/192.168.16.164</div></pre></td></tr></table></figure><ul><li><code>/servers/</code> 目录下以 <code>IP</code> 为数据节点路径存储每个服务器节点。如果<strong>相同IP</strong>服务器有多个服务器节点，只存储一个 <code>IP</code> 数据节点。</li><li><code>/servers/${IP}</code> 是<strong>持久</strong>节点，不存储任何信息，只是空串( <code>&quot;&quot;</code>);</li></ul><p>ServerNode 代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerNode</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 服务器信息根节点.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROOT = <span class="string">"servers"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVERS = ROOT + <span class="string">"/%s"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>ServerNode 如何存储，在<a href="http://www.iocoder.cn/Elastic-Job/job-init/?self">《Elastic-Job-Lite 源码分析 —— 作业初始化》的「3.2.4」注册作业启动信息</a>已经详细解析。</p><h1 id="6-InstanceNode"><a href="#6-InstanceNode" class="headerlink" title="6. InstanceNode"></a>6. InstanceNode</h1><p>InstanceNode，运行实例节点路径。</p><p>在 Zookeeper 看一个作业的<strong>运行实例</strong>节点数据存储： </p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 81] ls /elastic-job-example-lite-java/javaSimpleJob/instances</div><div class="line">[192.168.16.137@-@56010]</div><div class="line">[zk: localhost:2181(CONNECTED) 82] get /elastic-job-example-lite-java/javaSimpleJob/instances</div></pre></td></tr></table></figure><ul><li><code>/instances</code> 目录下以作业实例主键( <code>JOB_INSTANCE_ID</code> ) 为数据节点路径存储每个运行实例节点。</li><li><code>/instances/${JOB_INSTANCE_ID}</code> 是<strong>临时</strong>节点，不存储任何信息，只是空串( <code>&quot;&quot;</code>);</li><li><p><code>JOB_INSTANCE_ID</code> 生成方式：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobInstance.java</span></div><div class="line"></div><div class="line">jobInstanceId = IpUtils.getIp()</div><div class="line">                + DELIMITER</div><div class="line">                + ManagementFactory.getRuntimeMXBean().getName().split(<span class="string">"@"</span>)[<span class="number">0</span>]; <span class="comment">// PID</span></div></pre></td></tr></table></figure></li></ul><p>InstanceNode 代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceNode</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 运行实例信息根节点.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROOT = <span class="string">"instances"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String INSTANCES = ROOT + <span class="string">"/%s"</span>;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获取当前运行实例节点路径</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 当前运行实例节点路径</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">String <span class="title">getLocalInstanceNode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> String.format(INSTANCES, JobRegistry.getInstance().getJobInstance(jobName).getJobInstanceId());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>InstanceNode 如何存储，在<a href="http://www.iocoder.cn/Elastic-Job/job-init/?self">《Elastic-Job-Lite 源码分析 —— 作业初始化》的「3.2.4」注册作业启动信息</a>已经详细解析。</p><h1 id="7-ShardingNode"><a href="#7-ShardingNode" class="headerlink" title="7. ShardingNode"></a>7. ShardingNode</h1><p>ShardingNode，分片节点路径。</p><p>在 Zookeeper 看一个作业的<strong>分片</strong>节点数据存储： </p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 1] ls /elastic-job-example-lite-java/javaSimpleJob/sharding</div><div class="line">[0, 1, 2]</div><div class="line">[zk: localhost:2181(CONNECTED) 2] ls /elastic-job-example-lite-java/javaSimpleJob/sharding/0</div><div class="line">[running, instance, misfire]</div><div class="line">[zk: localhost:2181(CONNECTED) 3] get /elastic-job-example-lite-java/javaSimpleJob/sharding/0/instance</div><div class="line">192.168.16.137@-@56010</div></pre></td></tr></table></figure><ul><li><code>/sharding/${ITEM_ID}</code> 目录下以作业分片项序号( <code>ITEM_ID</code> ) 为数据节点路径存储作业分片项的 <code>instance</code> / <code>running</code> / <code>misfire</code> / <code>disable</code> <strong>数据节点</strong>信息。</li><li><code>/sharding/${ITEM_ID}/instance</code> 是<strong>临时</strong>节点，存储该作业分片项<strong>分配到的作业实例主键</strong>( <code>JOB_INSTANCE_ID</code> )。在<a href="http://www.iocoder.cn/Elastic-Job/job-sharding/?self">《Elastic-Job-Lite 源码分析 —— 作业分片》</a>详细解析。</li><li><code>/sharding/${ITEM_ID}/running</code> 是<strong>临时</strong>节点，当该作业分片项<strong>正在运行</strong>，存储空串( <code>&quot;&quot;</code> )；当该作业分片项<strong>不在运行</strong>，移除该数据节点。<a href="http://www.iocoder.cn/Elastic-Job/job-init/?self">《Elastic-Job-Lite 源码分析 —— 作业执行》的「4.6」执行普通触发的作业</a>已经详细解析。</li><li><code>/sharding/${ITEM_ID}/misfire</code> 是<strong>永久节点</strong>，当该作业分片项<strong>被错过执行</strong>，存储空串( <code>&quot;&quot;</code> )；当该作业分片项重新执行，移除该数据节点。<a href="http://www.iocoder.cn/Elastic-Job/job-init/?self">《Elastic-Job-Lite 源码分析 —— 作业执行》的「4.7」执行被错过触发的作业</a>已经详细解析。</li><li><code>/sharding/${ITEM_ID}/disable</code> 是<strong>永久节点</strong>，当该作业分片项<strong>被禁用</strong>，存储空串( <code>&quot;&quot;</code> )；当该作业分片项<strong>被开启</strong>，移除数据节点。</li></ul><p>ShardingNode，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingNode</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 执行状态根节点.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROOT = <span class="string">"sharding"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String INSTANCE_APPENDIX = <span class="string">"instance"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INSTANCE = ROOT + <span class="string">"/%s/"</span> + INSTANCE_APPENDIX;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String RUNNING_APPENDIX = <span class="string">"running"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String RUNNING = ROOT + <span class="string">"/%s/"</span> + RUNNING_APPENDIX;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String MISFIRE = ROOT + <span class="string">"/%s/misfire"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DISABLED = ROOT + <span class="string">"/%s/disabled"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String LEADER_ROOT = LeaderNode.ROOT + <span class="string">"/"</span> + ROOT;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String NECESSARY = LEADER_ROOT + <span class="string">"/necessary"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String PROCESSING = LEADER_ROOT + <span class="string">"/processing"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>LEADER_ROOT / NECESSARY / PROCESSING 放在「4.7」<strong>LeaderNode</strong> 解析。</li></ul><h1 id="8-LeaderNode"><a href="#8-LeaderNode" class="headerlink" title="8. LeaderNode"></a>8. LeaderNode</h1><p>LeaderNode，主节点路径。</p><p>在 <code>leader</code> 目录下一共有三个存储子节点：</p><ul><li><code>election</code>：主节点选举。</li><li><code>sharding</code>：作业分片项分配。</li><li><code>failover</code>：作业失效转移。</li></ul><p><strong>主节点选举</strong></p><p>在 Zookeeper 看一个作业的 <strong><code>leader/election</code></strong> 节点数据存储： </p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 1] ls /elastic-job-example-lite-java/javaSimpleJob/leader/election</div><div class="line">[latch, instance]</div><div class="line">[zk: localhost:2181(CONNECTED) 2] get /elastic-job-example-lite-java/javaSimpleJob/leader/election/instance</div><div class="line">192.168.16.137@-@1910</div></pre></td></tr></table></figure><ul><li><code>/leader/election/instance</code> 是<strong>临时</strong>节点，当作业集群完成选举后，存储主作业实例主键( <code>JOB_INSTANCE_ID</code> )。</li><li><code>/leader/election/latch</code> 主节点选举分布式锁，是 Apache Curator 针对 Zookeeper 实现的<strong>分布式锁</strong>的一种，笔者暂未了解存储形式，无法解释。在<a href="http://www.iocoder.cn/Elastic-Job/reg-center-zookeeper/?self">《Elastic-Job-Lite 源码分析 —— 注册中心》的「3.1」在主节点执行操作</a>进行了简单解析。</li></ul><p><strong>作业分片项分配</strong></p><p>在 Zookeeper 看一个作业的 <strong><code>leader/sharding</code></strong> 节点数据存储： </p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 1] ls /elastic-job-example-lite-java/javaSimpleJob/leader/sharding</div><div class="line">[necessary, processing]</div><div class="line">[zk: localhost:2181(CONNECTED) 2] 个get /elastic-job-example-lite-java/javaSimpleJob/leader/sharding</div><div class="line"></div><div class="line">[zk: localhost:2181(CONNECTED) 3] 个get /elastic-job-example-lite-java/javaSimpleJob/leader/processing</div></pre></td></tr></table></figure><ul><li><code>/leader/sharding/necessary</code> 是<strong>永久节点</strong>，当<strong>相同作业</strong>有新的作业节点加入或者移除时，存储空串( <code>&quot;&quot;</code> )，标记需要进行作业分片项重新分配；当重新分配完成后，移除该数据节点。</li><li><code>/leader/sharding/processing</code> 是<strong>临时节点</strong>，当开始重新分配作业分片项时，存储空串( <code>&quot;&quot;</code> )，标记正在进行重新分配；当重新分配完成后，移除该数据节点。</li><li>当且仅当作业节点为主节点时，才可以执行作业分片项分配，<a href="http://www.iocoder.cn/Elastic-Job/job-sharding/?self">《Elastic-Job-Lite 源码分析 —— 作业分片》</a>详细解析。</li></ul><p><strong>作业失效转移</strong></p><p>作业失效转移数据节点在 FailoverNode，放在「9」<strong>FailoverNode</strong> 解析。</p><p>这里大家可能会和我一样比较疑惑，为什么 <code>/leader/failover</code> 放在 <code>/leader</code> 目录下，而不独立成为一个根目录？经过确认，<strong>作业失效转移</strong> 设计到分布式锁，统一存储在 <code>/leader</code> 目录下。</p><hr><p>LeaderNode，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaderNode</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 主节点根路径.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROOT = <span class="string">"leader"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ELECTION_ROOT = ROOT + <span class="string">"/election"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String INSTANCE = ELECTION_ROOT + <span class="string">"/instance"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String  LATCH = ELECTION_ROOT + <span class="string">"/latch"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="9-FailoverNode"><a href="#9-FailoverNode" class="headerlink" title="9. FailoverNode"></a>9. FailoverNode</h1><p>FailoverNode，失效转移节点路径。</p><p>在 Zookeeper 看一个作业的<strong>失效转移</strong>节点数据存储： </p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">2</span>] ls /elastic-job-example-lite-java/javaSimpleJob/leader/failover</div><div class="line">[latch, items]</div><div class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">4</span>] ls /elastic-job-example-lite-java/javaSimpleJob/leader/failover/items</div><div class="line">[<span class="number">0</span>]</div></pre></td></tr></table></figure><ul><li><code>/leader/failover/latch</code> 作业失效转移分布式锁，和 <code>/leader/failover/latch</code> 是一致的。</li><li><code>/leader/items/${ITEM_ID}</code> 是<strong>永久节点</strong>，当某台作业节点 CRASH 时，其分配的作业分片项标记需要进行失效转移，存储其分配的作业分片项的 <code>/leader/items/${ITEM_ID}</code> 为空串( <code>&quot;&quot;</code> )；当失效转移标记，移除 <code>/leader/items/${ITEM_ID}</code>，存储 <code>/sharding/${ITEM_ID}/failover</code> 为空串( <code>&quot;&quot;</code> )，<strong>临时</strong>节点，需要进行失效转移执行。<a href="http://www.iocoder.cn/Elastic-Job/job-failover/?self">《Elastic-Job-Lite 源码分析 —— 作业失效转移》</a>详细解析。</li></ul><p>FailoverNode 代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FailoverNode</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String FAILOVER = <span class="string">"failover"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String LEADER_ROOT = LeaderNode.ROOT + <span class="string">"/"</span> + FAILOVER;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ITEMS_ROOT = LEADER_ROOT + <span class="string">"/items"</span>;</div><div class="line">        </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ITEMS = ITEMS_ROOT + <span class="string">"/%s"</span>;</div><div class="line">        </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String LATCH = LEADER_ROOT + <span class="string">"/latch"</span>;</div><div class="line">        </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXECUTION_FAILOVER = ShardingNode.ROOT + <span class="string">"/%s/"</span> + FAILOVER;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">getItemsNode</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> item)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> String.format(ITEMS, item);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">getExecutionFailoverNode</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> item)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> String.format(EXECUTION_FAILOVER, item);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="10-GuaranteeNode"><a href="#10-GuaranteeNode" class="headerlink" title="10. GuaranteeNode"></a>10. GuaranteeNode</h1><p>GuaranteeNode，保证分布式任务全部开始和结束状态节点路径。在<a href="http://www.iocoder.cn/Elastic-Job/job-listener/?self">《Elastic-Job-Lite 源码分析 —— 作业监听器》</a>详细解析。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>旁白君：芋道君，你又水更了！<br>芋道君：屁屁屁，劳资怼死你！如下是作业数据存储整理，哼哼哈兮！</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_10_07/02.png" alt=""></p><p>道友，赶紧上车，分享一波朋友圈！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-%E6%A6%82%E8%BF%B0&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-jobnodepath&quot;&gt;2.
      
    
    </summary>
    
      <category term="Elastic-Job-Lite" scheme="http://www.iocoder.cn/categories/Elastic-Job-Lite/"/>
    
    
  </entry>
  
</feed>
