<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>芋艿V的博客</title>
  <subtitle>愿编码半生，如老友相伴！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.yunai.me/"/>
  <updated>2017-08-25T07:55:04.000Z</updated>
  <id>http://www.yunai.me/</id>
  
  <author>
    <name>王文斌</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Elastic-Job-Lite 源码分析 —— 作业分片（编辑中）</title>
    <link href="http://www.yunai.me/Elastic-Job/job-sharding/"/>
    <id>http://www.yunai.me/Elastic-Job/job-sharding/</id>
    <published>2017-10-30T16:00:00.000Z</published>
    <updated>2017-08-25T07:55:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p>
<p>占位编辑
你懂的</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;占位编辑
你懂的&lt;/p&gt;

    
    </summary>
    
      <category term="Elastic-Job" scheme="http://www.yunai.me/categories/Elastic-Job/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Lite 源码分析 —— 作业分片策略</title>
    <link href="http://www.yunai.me/Elastic-Job/job-sharding-strategy/"/>
    <id>http://www.yunai.me/Elastic-Job/job-sharding-strategy/</id>
    <published>2017-10-25T16:00:00.000Z</published>
    <updated>2017-08-25T07:59:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. 自带作业分片策略</a>
<ul>
<li><a href="#">2.1 AverageAllocationJobShardingStrategy</a></li>
<li><a href="#">2.2 OdevitySortByNameJobShardingStrategy</a></li>
<li><a href="#">2.3 RotateServerByNameJobShardingStrategy</a></li>
</ul>
</li>
<li><a href="#">3. 自定义作业分片策略</a></li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<h1>1. 概述</h1>
<p>本文主要分享 <strong>Elastic-Job-Lite 作业分片策略</strong>。</p>
<p>涉及到主要类的类图如下( <a href="http://www.yunai.me/images/Elastic-Job/2017_10_26/01.png">打开大图</a> )：</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_10_26/01.png" alt=""></p>
<h1>2. 自带作业分片策略</h1>
<p>JobShardingStrategy，作业分片策略<strong>接口</strong>。分片策略通过实现接口的 <code>#sharding(...)</code> 方法提供作业分片的<strong>计算</strong>。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JobShardingStrategy</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业分片.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> jobInstances 所有参与分片的单元列表</div><div class="line">     * <span class="doctag">@param</span> jobName 作业名称</div><div class="line">     * <span class="doctag">@param</span> shardingTotalCount 分片总数</div><div class="line">     * <span class="doctag">@return</span> 分片结果</div><div class="line">     */</div><div class="line">    Map&lt;JobInstance, List&lt;Integer&gt;&gt; sharding(List&lt;JobInstance&gt; jobInstances, String jobName, <span class="keyword">int</span> shardingTotalCount);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Elastic-Job-Lite 提供三种自带的作业分片策略：</p>
<ul>
<li>AverageAllocationJobShardingStrategy：基于平均分配算法的分片策略。</li>
<li>OdevitySortByNameJobShardingStrategy：根据作业名的哈希值奇偶数决定IP升降序算法的分片策略。</li>
<li>RotateServerByNameJobShardingStrategy：根据作业名的哈希值对作业节点列表进行轮转的分片策略。</li>
</ul>
<h2>2.1 AverageAllocationJobShardingStrategy</h2>
<p>AverageAllocationJobShardingStrategy，基于平均分配算法的分片策略。<strong>Elastic-Job-Lite 默认的作业分片策略</strong>。</p>
<blockquote>
<p>如果分片不能整除，则不能整除的多余分片将依次追加到序号小的作业节点。如：<br>
如果有3台作业节点，分成9片，则每台作业节点分到的分片是：1=[0,1,2], 2=[3,4,5], 3=[6,7,8]<br>
如果有3台作业节点，分成8片，则每台作业节点分到的分片是：1=[0,1,6], 2=[2,3,7], 3=[4,5]<br>
如果有3台作业节点，分成10片，则每台作业节点分到的分片是：1=[0,1,2,9], 2=[3,4,5], 3=[6,7,8]</p>
</blockquote>
<p>代码实现如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AverageAllocationJobShardingStrategy</span> <span class="keyword">implements</span> <span class="title">JobShardingStrategy</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Map&lt;JobInstance, List&lt;Integer&gt;&gt; sharding(<span class="keyword">final</span> List&lt;JobInstance&gt; jobInstances, <span class="keyword">final</span> String jobName, <span class="keyword">final</span> <span class="keyword">int</span> shardingTotalCount) &#123;</div><div class="line">        <span class="comment">// 不存在 作业运行实例</span></div><div class="line">        <span class="keyword">if</span> (jobInstances.isEmpty()) &#123;</div><div class="line">            <span class="keyword">return</span> Collections.emptyMap();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 分配能被整除的部分</span></div><div class="line">        Map&lt;JobInstance, List&lt;Integer&gt;&gt; result = shardingAliquot(jobInstances, shardingTotalCount);</div><div class="line">        <span class="comment">// 分配不能被整除的部分</span></div><div class="line">        addAliquant(jobInstances, shardingTotalCount, result);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>调用 <code>#shardingAliquot(...)</code> 方法分配能<strong>被整除</strong>的部分。能整除的咱就不举例子。如果有 3 台作业节点，分成 8 片，被整除的部分是前 6 片 [0, 1, 2, 3, 4, 5]，调用该方法结果：1=[0,1], 2=[2,3], 3=[4,5]。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> Map&lt;JobInstance, List&lt;Integer&gt;&gt; shardingAliquot(<span class="keyword">final</span> List&lt;JobInstance&gt; shardingUnits, <span class="keyword">final</span> <span class="keyword">int</span> shardingTotalCount) &#123;</div><div class="line">   Map&lt;JobInstance, List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(shardingTotalCount, <span class="number">1</span>);</div><div class="line">   <span class="keyword">int</span> itemCountPerSharding = shardingTotalCount / shardingUnits.size(); <span class="comment">// 每个作业运行实例分配的平均分片数</span></div><div class="line">   <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">   <span class="keyword">for</span> (JobInstance each : shardingUnits) &#123;</div><div class="line">       List&lt;Integer&gt; shardingItems = <span class="keyword">new</span> ArrayList&lt;&gt;(itemCountPerSharding + <span class="number">1</span>);</div><div class="line">       <span class="comment">// 顺序向下分配</span></div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = count * itemCountPerSharding; i &lt; (count + <span class="number">1</span>) * itemCountPerSharding; i++) &#123;</div><div class="line">           shardingItems.add(i);</div><div class="line">       &#125;</div><div class="line">       result.put(each, shardingItems);</div><div class="line">       count++;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>调用 <code>#addAliquant(...)</code> 方法分配能<strong>不被整除</strong>的部分。继续上面的例子。不能被整除的部分是后 2 片 [6, 7]，调用该方法结果：1=[0,1] + <strong>[6]</strong>, 2=[2,3] + <strong>[7]</strong>, 3=[4,5]。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addAliquant</span><span class="params">(<span class="keyword">final</span> List&lt;JobInstance&gt; shardingUnits, <span class="keyword">final</span> <span class="keyword">int</span> shardingTotalCount, <span class="keyword">final</span> Map&lt;JobInstance, List&lt;Integer&gt;&gt; shardingResults)</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> aliquant = shardingTotalCount % shardingUnits.size(); <span class="comment">// 余数</span></div><div class="line">   <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">   <span class="keyword">for</span> (Map.Entry&lt;JobInstance, List&lt;Integer&gt;&gt; entry : shardingResults.entrySet()) &#123;</div><div class="line">       <span class="keyword">if</span> (count &lt; aliquant) &#123;</div><div class="line">           entry.getValue().add(shardingTotalCount / shardingUnits.size() * shardingUnits.size() + count);</div><div class="line">       &#125;</div><div class="line">       count++;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
</ul>
<p><strong>如何实现主备</strong></p>
<p>通过作业配置设置总分片数为 1 ( <code>JobCoreConfiguration.shardingTotalCount = 1</code> )，只有一个作业分片能够分配到作业分片项，从而达到<strong>一主N备</strong>。</p>
<h2>2.2 OdevitySortByNameJobShardingStrategy</h2>
<p>OdevitySortByNameJobShardingStrategy，根据作业名的哈希值奇偶数决定IP升降序算法的分片策略。</p>
<blockquote>
<p>作业名的哈希值为奇数则IP <strong>降序</strong>.<br>
作业名的哈希值为偶数则IP <strong>升序</strong>.<br>
用于不同的作业平均分配负载至不同的作业节点.<br>
如:</p>
<ol>
<li>如果有3台作业节点, 分成2片, 作业名称的哈希值为奇数, 则每台作业节点分到的分片是: 1=[ ], 2=[1], 3=[0].</li>
<li>如果有3台作业节点, 分成2片, 作业名称的哈希值为偶数, 则每台作业节点分到的分片是: 1=[0], 2=[1], 3=[ ].</li>
</ol>
</blockquote>
<p>实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> Map&lt;JobInstance, List&lt;Integer&gt;&gt; sharding(<span class="keyword">final</span> List&lt;JobInstance&gt; jobInstances, <span class="keyword">final</span> String jobName, <span class="keyword">final</span> <span class="keyword">int</span> shardingTotalCount) &#123;</div><div class="line">   <span class="keyword">long</span> jobNameHash = jobName.hashCode();</div><div class="line">   <span class="keyword">if</span> (<span class="number">0</span> == jobNameHash % <span class="number">2</span>) &#123;</div><div class="line">       Collections.reverse(jobInstances);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> averageAllocationJobShardingStrategy.sharding(jobInstances, jobName, shardingTotalCount);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>从实现代码上，仿佛和 IP 升降序没什么关系？答案在传递进来的参数 <code>jobInstances</code>。<code>jobInstances</code> 已经是按照 IP 进行<strong>降序</strong>的数组。所以当判断到作业名的哈希值为偶数时，进行数组反转( <code>Collections#reverse(...)</code> )实现按照 IP <strong>升序</strong>。下面看下为什么说<code>jobInstances</code> 已经按照 IP 进行<strong>降序</strong>：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ZookeeperRegistryCenter.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getChildrenKeys</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       List&lt;String&gt; result = client.getChildren().forPath(key);</div><div class="line">       Collections.sort(result, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</div><div class="line">           </div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">final</span> String o1, <span class="keyword">final</span> String o2)</span> </span>&#123;</div><div class="line">               <span class="keyword">return</span> o2.compareTo(o1);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">       <span class="keyword">return</span> result;</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       RegExceptionHandler.handleException(ex);</div><div class="line">       <span class="keyword">return</span> Collections.emptyList();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>调用 <code>AverageAllocationJobShardingStrategy#sharding(...)</code> 方法完成最终作业分片计算。</p>
</li>
</ul>
<h2>2.3 RotateServerByNameJobShardingStrategy</h2>
<p>RotateServerByNameJobShardingStrategy，根据作业名的哈希值对作业节点列表进行<strong>轮转</strong>的分片策略。这里的<strong>轮转</strong>怎么定义呢？如果有 3 台作业节点，顺序为 [0, 1, 2]，如果作业名的哈希值根据作业分片总数取模为 1, 作业节点顺序变为 [1, 2, 0]。</p>
<p><strong>分片的目的</strong>，是将作业的负载合理的分配到不同的作业节点上，要避免分片策略总是让固定的作业节点负载特别大，其它工作节点负载特别小。这个也是为什么<strong>官方</strong>对比 RotateServerByNameJobShardingStrategy、AverageAllocationJobShardingStrategy 如下：</p>
<blockquote>
<p>AverageAllocationJobShardingStrategy的缺点是，一旦分片数小于作业作业节点数，作业将永远分配至IP地址靠前的作业节点，导致IP地址靠后的作业节点空闲。如：<br>
OdevitySortByNameJobShardingStrategy则可以根据作业名称重新分配作业节点负载。<br>
如果有3台作业节点，分成2片，作业名称的哈希值为奇数，则每台作业节点分到的分片是：1=[0], 2=[1], 3=[]<br>
如果有3台作业节点，分成2片，作业名称的哈希值为偶数，则每台作业节点分到的分片是：3=[0], 2=[1], 1=[]</p>
</blockquote>
<p>实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RotateServerByNameJobShardingStrategy</span> <span class="keyword">implements</span> <span class="title">JobShardingStrategy</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> AverageAllocationJobShardingStrategy averageAllocationJobShardingStrategy = <span class="keyword">new</span> AverageAllocationJobShardingStrategy();</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Map&lt;JobInstance, List&lt;Integer&gt;&gt; sharding(<span class="keyword">final</span> List&lt;JobInstance&gt; jobInstances, <span class="keyword">final</span> String jobName, <span class="keyword">final</span> <span class="keyword">int</span> shardingTotalCount) &#123;</div><div class="line">        <span class="keyword">return</span> averageAllocationJobShardingStrategy.sharding(rotateServerList(jobInstances, jobName), jobName, shardingTotalCount);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> List&lt;JobInstance&gt; <span class="title">rotateServerList</span><span class="params">(<span class="keyword">final</span> List&lt;JobInstance&gt; shardingUnits, <span class="keyword">final</span> String jobName)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> shardingUnitsSize = shardingUnits.size();</div><div class="line">        <span class="keyword">int</span> offset = Math.abs(jobName.hashCode()) % shardingUnitsSize; <span class="comment">// 轮转开始位置</span></div><div class="line">        <span class="keyword">if</span> (<span class="number">0</span> == offset) &#123;</div><div class="line">            <span class="keyword">return</span> shardingUnits;</div><div class="line">        &#125;</div><div class="line">        List&lt;JobInstance&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(shardingUnitsSize);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shardingUnitsSize; i++) &#123;</div><div class="line">            <span class="keyword">int</span> index = (i + offset) % shardingUnitsSize;</div><div class="line">            result.add(shardingUnits.get(index));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>调用 <code>#rotateServerList(...)</code> 实现作业节点数组<strong>轮转</strong>。</li>
<li>调用 <code>AverageAllocationJobShardingStrategy#sharding(...)</code> 方法完成最终作业分片计算。</li>
</ul>
<h1>3. 自定义作业分片策略</h1>
<p>可能在你的业务场景下，需要实现自定义的作业分片策略。通过定义类实现 JobShardingStrategy 接口即可：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OOXXShardingStrategy</span> <span class="keyword">implements</span> <span class="title">JobShardingStrategy</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Map&lt;JobInstance, List&lt;Integer&gt;&gt; sharding(<span class="keyword">final</span> List&lt;JobInstance&gt; jobInstances, <span class="keyword">final</span> String jobName, <span class="keyword">final</span> <span class="keyword">int</span> shardingTotalCount) &#123;</div><div class="line">        <span class="comment">// 实现逻辑</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实现后，配置实现类的<strong>全路径</strong>到 Lite作业配置( LiteJobConfiguration )的 <code>jobShardingStrategyClass</code> 属性。</p>
<p>作业进行分片计算时，作业分片策略工厂( JobShardingStrategyFactory ) 会创建作业分片策略实例：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobShardingStrategyFactory</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取作业分片策略实例.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> jobShardingStrategyClassName 作业分片策略类名</div><div class="line">     * <span class="doctag">@return</span> 作业分片策略实例</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JobShardingStrategy <span class="title">getStrategy</span><span class="params">(<span class="keyword">final</span> String jobShardingStrategyClassName)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (Strings.isNullOrEmpty(jobShardingStrategyClassName)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AverageAllocationJobShardingStrategy();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Class&lt;?&gt; jobShardingStrategyClass = Class.forName(jobShardingStrategyClassName);</div><div class="line">            <span class="keyword">if</span> (!JobShardingStrategy.class.isAssignableFrom(jobShardingStrategyClass)) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> JobConfigurationException(<span class="string">"Class '%s' is not job strategy class"</span>, jobShardingStrategyClassName);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> (JobShardingStrategy) jobShardingStrategyClass.newInstance();</div><div class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> ClassNotFoundException | InstantiationException | IllegalAccessException ex) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JobConfigurationException(<span class="string">"Sharding strategy class '%s' config error, message details are '%s'"</span>, jobShardingStrategyClassName, ex.getMessage());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>666. 彩蛋</h1>
<p>旁白君：雾草，刚夸奖你，就又开始水更。<br>
芋道君：咳咳咳，作业分片策略炒鸡重要的好不好！嘿嘿嘿，为<a href="http://www.yunai.me/Elastic-Job/ob-sharding/?self">《Elastic-Job-Lite 源码分析 —— 作业分片》</a>做个铺垫嘛。</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_10_26/02.png" alt=""></p>
<p>道友，赶紧上车，分享一波朋友圈！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. 自带作业分片策略&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#
    
    </summary>
    
      <category term="Elastic-Job" scheme="http://www.yunai.me/categories/Elastic-Job/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Lite 源码分析 —— 主节点选举</title>
    <link href="http://www.yunai.me/Elastic-Job/election/"/>
    <id>http://www.yunai.me/Elastic-Job/election/</id>
    <published>2017-10-20T16:00:00.000Z</published>
    <updated>2017-08-24T20:16:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p>
<ul>
<li><a href="">1. 概述</a></li>
<li><a href="">2. 为什么需要选举主节点</a></li>
<li><a href="">3. 选举主节点</a></li>
<li><a href="">4. 删除主节点</a></li>
<li><a href="">666. 彩蛋</a></li>
</ul>
<hr>
<h1>1. 概述</h1>
<p>本文主要分享 <strong>Elastic-Job-Lite 主节点选举</strong>。</p>
<p>建议前置阅读：</p>
<ul>
<li><a href="http://www.yunai.me/Elastic-Job/reg-center-zookeeper/?self">《Elastic-Job-Lite 源码分析 —— 注册中心》</a></li>
<li><a href="http://www.yunai.me/Elastic-Job/job-storage/?self">《Elastic-Job-Lite 源码分析 —— 作业数据存储》</a></li>
<li><a href="http://www.yunai.me/Elastic-Job/reg-center-zookeeper-listener/?self">《Elastic-Job-Lite 源码分析 —— 注册中心监听器》</a></li>
</ul>
<p>涉及到主要类的类图如下( <a href="http://www.yunai.me/images/Elastic-Job/2017_10_21/01.png">打开大图</a> )：</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_10_21/01.png" alt=""></p>
<ul>
<li>粉色的类在 <code>com.dangdang.ddframe.job.lite.internal.election</code> 包下，实现了 Elastic-Job-Lite 主节点选举。</li>
</ul>
<blockquote>
<p>你行好事会因为得到赞赏而愉悦<br>
同理，开源项目贡献者会因为 Star 而更加有动力<br>
为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p>
</blockquote>
<h1>2. 为什么需要选举主节点</h1>
<p>首先我们来看一段<strong>官方</strong>对 Elastic-Job-Lite 的介绍：</p>
<blockquote>
<p>Elastic-Job-Lite 定位为轻量级无中心化解决方案，使用 jar 包的形式提供分布式任务的协调服务。</p>
</blockquote>
<p><strong>无中心化</strong>，意味着 Elastic-Job-Lite 不存在<strong>一个中心</strong>执行一些操作，例如：分配作业分片项。Elastic-Job-Lite 选举主节点，通过主节点进行作业分片项分配。目前，必须在主节点执行的操作有：分配作业分片项，调解分布式作业不一致状态。</p>
<p>另外，主节点的选举是以<strong>作业为维度</strong>。例如：有一个 Elastic-Job-Lite 集群有三个作业节点 <code>A</code>、<code>B</code>、<code>C</code>，存在两个作业 <code>a</code>、<code>b</code>，可能 <code>a</code> 作业的主节点是 <code>C</code>，<code>b</code> 作业的主节点是 <code>A</code>。</p>
<h1>3. 选举主节点</h1>
<p>调用 <code>LeaderService#electLeader()</code> 选举主节点。</p>
<p>大体流程如下( <a href="http://www.yunai.me/images/Elastic-Job/2017_10_21/02.png">打开大图</a> )：
<img src="http://www.yunai.me/images/Elastic-Job/2017_10_21/02.png" alt=""></p>
<p>实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LeaderService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 选举主节点.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">electLeader</span><span class="params">()</span> </span>&#123;</div><div class="line">   log.debug(<span class="string">"Elect a new leader now."</span>);</div><div class="line">   jobNodeStorage.executeInLeader(LeaderNode.LATCH, <span class="keyword">new</span> LeaderElectionExecutionCallback());</div><div class="line">   log.debug(<span class="string">"Leader election completed."</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// JobNodeStorage.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeInLeader</span><span class="params">(<span class="keyword">final</span> String latchNode, <span class="keyword">final</span> LeaderExecutionCallback callback)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> (LeaderLatch latch = <span class="keyword">new</span> LeaderLatch(getClient(), jobNodePath.getFullPath(latchNode))) &#123;</div><div class="line">       latch.start();</div><div class="line">       latch.await();</div><div class="line">       callback.execute();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       handleException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// LeaderElectionExecutionCallback.java</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LeaderElectionExecutionCallback</span> <span class="keyword">implements</span> <span class="title">LeaderExecutionCallback</span> </span>&#123;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (!hasLeader()) &#123; <span class="comment">// 当前无主节点</span></div><div class="line">           jobNodeStorage.fillEphemeralJobNode(LeaderNode.INSTANCE, JobRegistry.getInstance().getJobInstance(jobName).getJobInstanceId());</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>使用 Curator LeaderLatch 分布式锁，<strong>保证同一时间有且仅有一个工作节点</strong>能够调用 <code>LeaderElectionExecutionCallback#execute()</code> 方法执行主节点设置。Curator LeaderLatch 在<a href="http://www.yunai.me/Elastic-Job/reg-center-zookeeper/?self">《Elastic-Job-Lite 源码分析 —— 注册中心》「3.1 在主节点执行操作」</a>有详细解析。</p>
</li>
<li>
<p>在 <code>LeaderElectionExecutionCallback#execute()</code> 为什么要调用 <code>#hasLeader()</code> 呢？LeaderLatch <strong>只保证同一时间有且仅有一个工作节点</strong>，在获得分布式锁的工作节点结束逻辑后，第二个工作节点会开始逻辑，如果不判断当前是否有主节点，原来的主节点会被覆盖。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LeaderService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 判断是否已经有主节点.</div><div class="line"> * </div><div class="line"> * <span class="doctag">@return</span> 是否已经有主节点</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasLeader</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> jobNodeStorage.isJobNodeExisted(LeaderNode.INSTANCE);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>选举成功后，Zookeeper 存储<strong>作业</strong>的主节点：<code>/${JOB_NAME}/leader/electron/instance</code> 为当前节点。该节点为<strong>临时</strong>节点。</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 7] get /elastic-job-example-lite-java/javaSimpleJob/leader/election/instance</div><div class="line">192.168.16.137@-@82496</div></pre></td></tr></table></figure></p>
</li>
</ul>
<p><strong>选举主节点时机</strong></p>
<p><strong>第一种</strong>，注册作业启动信息时。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 注册作业启动信息.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> enabled 作业是否启用</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStartUpInfo</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> enabled)</span> </span>&#123;</div><div class="line">   <span class="comment">// .... 省略部分方法</span></div><div class="line">   <span class="comment">// 选举 主节点</span></div><div class="line">   leaderService.electLeader();</div><div class="line">   <span class="comment">// .... 省略部分方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>新的作业启动时，即能保证选举出主节点。
<ul>
<li>当该作业<strong>不存在</strong>主节点时，当前作业节点<strong>成为</strong>主节点。</li>
<li>当该作业<strong>存在</strong>主节点，当前作业节主节点<strong>不变</strong>。</li>
</ul>
</li>
</ul>
<p><strong>第二种</strong>，节点数据发生变化时。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LeaderElectionJobListener</span> <span class="keyword">extends</span> <span class="title">AbstractJobListener</span> </span>&#123;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String data)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (!JobRegistry.getInstance().isShutdown(jobName) &amp;&amp; (isActiveElection(path, data) || isPassiveElection(path, eventType))) &#123;</div><div class="line">           leaderService.electLeader();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>符合重新选举主节点分成两种情况。</p>
</li>
<li>
<p><strong>主动</strong>选举 <code>#isActiveElection(...)</code></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isActiveElection</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> String data)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> !leaderService.hasLeader() <span class="comment">// 不存在主节点</span></div><div class="line">          &amp;&amp; isLocalServerEnabled(path, data); <span class="comment">// 开启作业</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLocalServerEnabled</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> String data)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> serverNode.isLocalServerPath(path) </div><div class="line">       &amp;&amp; !ServerStatus.DISABLED.name().equals(data);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>当作业被禁用( <code>LiteJobConfiguration.disabled = true</code> )时，作业是不存在主节点的。那有同学就有疑问了？<code>LeaderService#electLeader()</code> 没做这个限制呀，作业<strong>注册作业启动信息时</strong>也进行了选举。在「4. 删除主节点」小结，我们会解开这个答案。这里大家先记住这个结论。</li>
<li>根据上面我们说的结论，这里就很好理解了，<code>#isActiveElection()</code> 方法判断了两个条件：( 1 ) 不存在主节点；( 2 ) 开启作业，不再禁用，因此需要进行主节点选举落。</li>
<li>这里判断开启作业的方法 <code>#isLocalServerEnabled(...)</code> 有点特殊，它不是通过作业节点是否处于开启状态，而是该数据不是将作业节点更新成关闭状态。举个例子：作业节点处于<strong>禁用</strong>状态，使用<strong>运维平台</strong>设置作业节点开启，会进行主节点选举；作业节点处于<strong>开启</strong>状态，使用<strong>运维平台</strong>设置作业节点禁用，不会进行主节点选举。</li>
</ul>
</li>
<li>
<p><strong>被动</strong>选举 <code>#isPassiveElection(...)</code></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPassiveElection</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> isLeaderCrashed(path, eventType) <span class="comment">// 主节点 Crashed</span></div><div class="line">          &amp;&amp; serverService.isAvailableServer(JobRegistry.getInstance().getJobInstance(jobName).getIp()); <span class="comment">// 当前节点正在运行中（未挂掉）</span></div><div class="line">&#125;</div><div class="line">   </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLeaderCrashed</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> leaderNode.isLeaderInstancePath(path) &amp;&amp; Type.NODE_REMOVED == eventType;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>当主节点因为各种情况( 「4. 删除主节点」会列举 )被删除，需要重新进行选举。对的，<strong>必须主节点被删除后才可以重新进行选举</strong>。</li>
<li><code>#isPassiveElection(...)</code> 方法判断了两个条件：( 1 ) 原主节点被删除；( 2 ) 当前节点正在运行中（未挂掉），可以参加主节点选举。</li>
<li><code>#isLeaderCrashed(...)</code> 方法虽然命名带有 <code>Crashed</code> 英文，实际主作业节点<strong>正常</strong>退出也符合<strong>被动</strong>选举条件。</li>
</ul>
</li>
</ul>
<p><strong>等待主节点选举完成</strong></p>
<p>必须在主节点执行的操作，执行之前，需要判断当前节点是否为主节点。如果主节点已经选举好，可以直接进行判断。但是，不排除主节点还没选举到，因而需要阻塞等待到主节点选举完成后才能进行判断。</p>
<p>实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LeaderService.java</span></div><div class="line">    </div><div class="line"><span class="comment">/**</span></div><div class="line">* 判断当前节点是否是主节点.</div><div class="line">* </div><div class="line">* 如果主节点正在选举中而导致取不到主节点, 则阻塞至主节点选举完成再返回.</div><div class="line">* </div><div class="line">* <span class="doctag">@return</span> 当前节点是否是主节点</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeaderUntilBlock</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 不存在主节点 &amp;&amp; 有可用的服务器节点</span></div><div class="line">   <span class="keyword">while</span> (!hasLeader() &amp;&amp; serverService.hasAvailableServers()) &#123;</div><div class="line">       log.info(<span class="string">"Leader is electing, waiting for &#123;&#125; ms"</span>, <span class="number">100</span>);</div><div class="line">       BlockUtils.waitingShortTime();</div><div class="line">       <span class="keyword">if</span> (!JobRegistry.getInstance().isShutdown(jobName)</div><div class="line">               &amp;&amp; serverService.isAvailableServer(JobRegistry.getInstance().getJobInstance(jobName).getIp())) &#123; <span class="comment">// 当前服务器节点可用</span></div><div class="line">           electLeader();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 返回当前节点是否是主节点</span></div><div class="line">   <span class="keyword">return</span> isLeader();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>TODO</li>
</ul>
<h1>4. 删除主节点</h1>
<p>有主节点的选举，必然有主节点的删除，否则怎么进行<strong>重新选举</strong>。</p>
<p>实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LeaderService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 删除主节点供重新选举.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeLeader</span><span class="params">()</span> </span>&#123;</div><div class="line">   jobNodeStorage.removeJobNodeIfExisted(LeaderNode.INSTANCE);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>删除主节点时机</strong></p>
<p><strong>第一种</strong>，主节点进程<strong>正常</strong>关闭时。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobShutdownHookPlugin</span> <span class="keyword">extends</span> <span class="title">ShutdownHookPlugin</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line">        CoordinatorRegistryCenter regCenter = JobRegistry.getInstance().getRegCenter(jobName);</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == regCenter) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        LeaderService leaderService = <span class="keyword">new</span> LeaderService(regCenter, jobName);</div><div class="line">        <span class="keyword">if</span> (leaderService.isLeader()) &#123;</div><div class="line">            leaderService.removeLeader(); <span class="comment">// 移除主节点</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">new</span> InstanceService(regCenter, jobName).removeInstance();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>这个比较好理解，退出进程，若该进程为主节点，需要将自己移除。</li>
</ul>
<p><strong>第二种</strong>，主节点进程 CRASHED 时。</p>
<p><code>${JOB_NAME}/leader/electron/instance</code> 是<strong>临时</strong>节点，主节点进程 CRASHED 后，超过最大会话时间，Zookeeper 自动进行删除，触发重新选举逻辑。</p>
<p><strong>第三种</strong>，作业被<strong>禁用</strong>时。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LeaderAbdicationJobListener</span> <span class="keyword">extends</span> <span class="title">AbstractJobListener</span> </span>&#123;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String data)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (leaderService.isLeader() &amp;&amp; isLocalServerDisabled(path, data)) &#123;</div><div class="line">           leaderService.removeLeader();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLocalServerDisabled</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> String data)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> serverNode.isLocalServerPath(path) &amp;&amp; ServerStatus.DISABLED.name().equals(data);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>这里就解答上面我们遗留的疑问。被禁用的作业<strong>注册作业启动信息时</strong>即使进行了主节点选举，也会被该监听器处理，移除该选举的主节点。</li>
</ul>
<p><strong>第四种</strong>，主节点进程<strong>远程</strong>关闭。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// InstanceShutdownStatusJobListener.java</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">InstanceShutdownStatusJobListener</span> <span class="keyword">extends</span> <span class="title">AbstractJobListener</span> </span>&#123;</div><div class="line">        </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String data)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (!JobRegistry.getInstance().isShutdown(jobName)</div><div class="line">               &amp;&amp; !JobRegistry.getInstance().getJobScheduleController(jobName).isPaused() <span class="comment">// 作业未暂停调度</span></div><div class="line">               &amp;&amp; isRemoveInstance(path, eventType) <span class="comment">// 移除【运行实例】事件</span></div><div class="line">               &amp;&amp; !isReconnectedRegistryCenter()) &#123; <span class="comment">// 运行实例被移除</span></div><div class="line">           schedulerFacade.shutdownInstance();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRemoveInstance</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> instanceNode.isLocalInstancePath(path) &amp;&amp; Type.NODE_REMOVED == eventType;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isReconnectedRegistryCenter</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> instanceService.isLocalJobInstanceExisted();</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// SchedulerFacade.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 终止作业调度.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdownInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (leaderService.isLeader()) &#123;</div><div class="line">       leaderService.removeLeader(); <span class="comment">// 移除主节点</span></div><div class="line">   &#125;</div><div class="line">   monitorService.close();</div><div class="line">   <span class="keyword">if</span> (reconcileService.isRunning()) &#123;</div><div class="line">       reconcileService.stopAsync();</div><div class="line">   &#125;</div><div class="line">   JobRegistry.getInstance().shutdown(jobName);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><strong>远程</strong>关闭作业节点有两种方式：
<ul>
<li>zkClient 发起命令：<code>rmr /${NAMESPACE}/${JOB_NAME}/instances/${JOB_INSTANCE_ID}</code>。</li>
<li>运维平台发起 <code>Shutdown</code> 操作。<code>Shutdown</code> 操作实质上就是第一种。
<img src="http://www.yunai.me/images/Elastic-Job/2017_10_21/04.png" alt=""></li>
</ul>
</li>
</ul>
<h1>666. 彩蛋</h1>
<p>旁白君：哎哟，这次竟然分享了点干货 😈<br>
芋道君：嘿呀嘿呀，必须的啊，虽然有点焦头烂额啦。</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_10_21/03.png" alt=""></p>
<p>道友，赶紧上车，分享一波朋友圈！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;2. 为什么需要选举主节点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&quot;
    
    </summary>
    
      <category term="Elastic-Job" scheme="http://www.yunai.me/categories/Elastic-Job/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Lite 源码分析 —— 注册中心监听器</title>
    <link href="http://www.yunai.me/Elastic-Job/reg-center-zookeeper-listener/"/>
    <id>http://www.yunai.me/Elastic-Job/reg-center-zookeeper-listener/</id>
    <published>2017-10-13T16:00:00.000Z</published>
    <updated>2017-08-25T07:46:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. ListenerManager</a></li>
<li><a href="#">3. AbstractListenerManager</a></li>
<li><a href="#">4. AbstractJobListener</a></li>
<li><a href="#">5. RegistryCenterConnectionStateListener</a></li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<h1>1. 概述</h1>
<p>本文主要分享 <strong>Elastic-Job-Lite 注册中心监听器</strong>。</p>
<p>建议前置阅读：</p>
<ul>
<li><a href="http://www.yunai.me/Elastic-Job/reg-center-zookeeper/?self">《Elastic-Job-Lite 源码分析 —— 注册中心》</a></li>
</ul>
<p>涉及到主要类的类图如下( <a href="http://www.yunai.me/images/Elastic-Job/2017_10_14/01.png">打开大图</a> )：</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_10_14/01.png" alt=""></p>
<blockquote>
<p>你行好事会因为得到赞赏而愉悦<br>
同理，开源项目贡献者会因为 Star 而更加有动力<br>
为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p>
</blockquote>
<h1>2. ListenerManager</h1>
<p>ListenerManager，作业注册中心的监听器管理者。管理者<strong>两类</strong>组件：</p>
<ul>
<li>监听管理器</li>
<li>注册中心连接状态监听器</li>
</ul>
<p>其中<strong>监听管理器</strong>管理着自己的作业注册中心监听器。</p>
<p>一起从代码层面看看：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerManager</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobNodeStorage jobNodeStorage;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ElectionListenerManager electionListenerManager;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ShardingListenerManager shardingListenerManager;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FailoverListenerManager failoverListenerManager;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MonitorExecutionListenerManager monitorExecutionListenerManager;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ShutdownListenerManager shutdownListenerManager;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TriggerListenerManager triggerListenerManager;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RescheduleListenerManager rescheduleListenerManager;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> GuaranteeListenerManager guaranteeListenerManager;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RegistryCenterConnectionStateListener regCenterConnectionStateListener;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>第一类：<code>electionListenerManager</code> / <code>shardingListenerManager</code> / <code>failoverListenerManager</code> / <code>MonitorExecutionListenerManager</code> / <code>shutdownListenerManager</code> / <code>triggerListenerManager</code> / <code>rescheduleListenerManager</code> / <code>guaranteeListenerManager</code> 是不同服务的<strong>监听管理器</strong>，都继承<strong>作业注册中心的监听器管理者的抽象类</strong>( AbstractListenerManager )。我们以下一篇文章会涉及到的<strong>分片监听管理器</strong>( ShardingListenerManager ) 来瞅瞅内部整体实现：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingListenerManager</span> <span class="keyword">extends</span> <span class="title">AbstractListenerManager</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">        addDataListener(<span class="keyword">new</span> ShardingTotalCountChangedJobListener());</div><div class="line">        addDataListener(<span class="keyword">new</span> ListenServersChangedJobListener());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ShardingTotalCountChangedJobListener</span> <span class="keyword">extends</span> <span class="title">AbstractJobListener</span> </span>&#123;</div><div class="line">        <span class="comment">// .... 省略方法</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ListenServersChangedJobListener</span> <span class="keyword">extends</span> <span class="title">AbstractJobListener</span> </span>&#123;</div><div class="line">        <span class="comment">// .... 省略方法</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>ShardingListenerManager 内部管理了 ShardingTotalCountChangedJobListener / ListenServersChangedJobListener 两个作业注册中心监听器。具体作业注册中心监听器是什么，有什么用途，下文会详细解析。</li>
</ul>
</li>
<li>
<p>第二类：<code>regCenterConnectionStateListener</code> 是注册中心连接状态监听器。下文也会详细解析。</p>
</li>
</ul>
<p>在<a href="http://www.yunai.me/Elastic-Job/job-init?self">《Elastic-Job-Lite 源码分析 —— 作业初始化》「3.2.4」注册作业启动信息</a>，我们看到作业初始化时，会开启所有注册中心监听器：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SchedulerFacade.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 注册作业启动信息.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> enabled 作业是否启用</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStartUpInfo</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> enabled)</span> </span>&#123;</div><div class="line">   <span class="comment">// 开启 所有监听器</span></div><div class="line">   listenerManager.startAllListeners();</div><div class="line">   <span class="comment">// .... 省略方法</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ListenerManager.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 开启所有监听器.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startAllListeners</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 开启 不同服务监听管理器</span></div><div class="line">   electionListenerManager.start();</div><div class="line">   shardingListenerManager.start();</div><div class="line">   failoverListenerManager.start();</div><div class="line">   monitorExecutionListenerManager.start();</div><div class="line">   shutdownListenerManager.start();</div><div class="line">   triggerListenerManager.start();</div><div class="line">   rescheduleListenerManager.start();</div><div class="line">   guaranteeListenerManager.start();</div><div class="line">   <span class="comment">// 开启 注册中心连接状态监听器</span></div><div class="line">   jobNodeStorage.addConnectionStateListener(regCenterConnectionStateListener);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>3. AbstractListenerManager</h1>
<p>AbstractListenerManager，作业注册中心的监听器管理者的<strong>抽象类</strong>。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractListenerManager</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobNodeStorage jobNodeStorage;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractListenerManager</span><span class="params">(<span class="keyword">final</span> CoordinatorRegistryCenter regCenter, <span class="keyword">final</span> String jobName)</span> </span>&#123;</div><div class="line">        jobNodeStorage = <span class="keyword">new</span> JobNodeStorage(regCenter, jobName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 开启监听器.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 添加注册中心监听器</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> listener 注册中心监听器</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addDataListener</span><span class="params">(<span class="keyword">final</span> TreeCacheListener listener)</span> </span>&#123;</div><div class="line">        jobNodeStorage.addDataListener(listener);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p><code>#addDataListener()</code>，将作业注册中心的监听器添加到注册中心 TreeCache 的监听者里。<code>JobNodeStorage#addDataListener(...)</code> 在<a href="http://www.yunai.me/Elastic-Job/reg-center-zookeeper/?self">《Elastic-Job-Lite 源码分析 —— 作业初始化》「2.2」缓存</a>已经详细解析。</p>
</li>
<li>
<p>子类实现 <code>#start()</code> 方法实现监听器初始化。目前所有子类的实现都是将自己管理的注册中心监听器调用 <code>#addDataListener(...)</code>，还是以 ShardingListenerManager 举例子：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingListenerManager</span> <span class="keyword">extends</span> <span class="title">AbstractListenerManager</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">        addDataListener(<span class="keyword">new</span> ShardingTotalCountChangedJobListener());</div><div class="line">        addDataListener(<span class="keyword">new</span> ListenServersChangedJobListener());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
</ul>
<h1>4. AbstractJobListener</h1>
<p>AbstractJobListener，作业注册中心的监听器<strong>抽象类</strong>。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractJobListener</span> <span class="keyword">implements</span> <span class="title">TreeCacheListener</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(<span class="keyword">final</span> CuratorFramework client, <span class="keyword">final</span> TreeCacheEvent event)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        ChildData childData = event.getData();</div><div class="line">        <span class="comment">// 忽略掉非数据变化的事件，例如 event.type 为 CONNECTION_SUSPENDED、CONNECTION_RECONNECTED、CONNECTION_LOST、INITIALIZED 事件</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == childData) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        String path = childData.getPath();</div><div class="line">        <span class="keyword">if</span> (path.isEmpty()) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        dataChanged(path, event.getType(), <span class="keyword">null</span> == childData.getData() ? <span class="string">""</span> : <span class="keyword">new</span> String(childData.getData(), Charsets.UTF_8));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 节点数据变化</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> path 节点路径</div><div class="line">     * <span class="doctag">@param</span> eventType 事件类型</div><div class="line">     * <span class="doctag">@param</span> data 数据</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String data)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>作业注册中心的监听器<strong>实现类</strong>实现 <code>#dataChanged(...)</code>，对节点数据变化进行处理。</li>
<li><code>#childEvent(...)</code> 屏蔽掉非节点数据变化事件，例如：CONNECTION_SUSPENDED、CONNECTION_RECONNECTED、CONNECTION_LOST、INITIALIZED 事件，只处理 NODE_ADDED、NODE_UPDATED、NODE_REMOVED 事件。</li>
</ul>
<p>我们再拿 ShardingListenerManager 举例子：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingListenerManager</span> <span class="keyword">extends</span> <span class="title">AbstractListenerManager</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ShardingTotalCountChangedJobListener</span> <span class="keyword">extends</span> <span class="title">AbstractJobListener</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String data)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (configNode.isConfigPath(path) &amp;&amp; <span class="number">0</span> != JobRegistry.getInstance().getCurrentShardingTotalCount(jobName)) &#123;</div><div class="line">                <span class="keyword">int</span> newShardingTotalCount = LiteJobConfigurationGsonFactory.fromJson(data).getTypeConfig().getCoreConfig().getShardingTotalCount();</div><div class="line">                <span class="keyword">if</span> (newShardingTotalCount != JobRegistry.getInstance().getCurrentShardingTotalCount(jobName)) &#123;</div><div class="line">                    shardingService.setReshardingFlag();</div><div class="line">                    JobRegistry.getInstance().setCurrentShardingTotalCount(jobName, newShardingTotalCount);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ListenServersChangedJobListener</span> <span class="keyword">extends</span> <span class="title">AbstractJobListener</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String data)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (!JobRegistry.getInstance().isShutdown(jobName) &amp;&amp; (isInstanceChange(eventType, path) || isServerChange(path))) &#123;</div><div class="line">                shardingService.setReshardingFlag();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isInstanceChange</span><span class="params">(<span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String path)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> instanceNode.isInstancePath(path) &amp;&amp; Type.NODE_UPDATED != eventType;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isServerChange</span><span class="params">(<span class="keyword">final</span> String path)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> serverNode.isServerPath(path);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>在<a href="http://www.yunai.me/Elastic-Job/ob-sharding/?self">《Elastic-Job-Lite 源码解析 —— 任务分片》</a>详细解析。</li>
</ul>
<h1>5. RegistryCenterConnectionStateListener</h1>
<p>RegistryCenterConnectionStateListener，实现 Curator ConnectionStateListener 接口，注册中心连接状态监听器。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RegistryCenterConnectionStateListener</span> <span class="keyword">implements</span> <span class="title">ConnectionStateListener</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(<span class="keyword">final</span> CuratorFramework client, <span class="keyword">final</span> ConnectionState newState)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (JobRegistry.getInstance().isShutdown(jobName)) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        JobScheduleController jobScheduleController = JobRegistry.getInstance().getJobScheduleController(jobName);</div><div class="line">        <span class="keyword">if</span> (ConnectionState.SUSPENDED == newState || ConnectionState.LOST == newState) &#123; <span class="comment">// Zookeeper 连接终端 或 连接丢失</span></div><div class="line">            <span class="comment">// 暂停作业调度</span></div><div class="line">            jobScheduleController.pauseJob();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ConnectionState.RECONNECTED == newState) &#123; <span class="comment">// Zookeeper 重新连上</span></div><div class="line">            <span class="comment">// 持久化作业服务器上线信息</span></div><div class="line">            serverService.persistOnline(serverService.isEnableServer(JobRegistry.getInstance().getJobInstance(jobName).getIp()));</div><div class="line">            <span class="comment">// 持久化作业运行实例上线相关信息</span></div><div class="line">            instanceService.persistOnline();</div><div class="line">            <span class="comment">// 清除本地分配的作业分片项运行中的标记</span></div><div class="line">            executionService.clearRunningInfo(shardingService.getLocalShardingItems());</div><div class="line">            <span class="comment">// 恢复作业调度</span></div><div class="line">            jobScheduleController.resumeJob();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>当注册中心连接 SUSPENDED 或 LOST 时，暂停<strong>本地</strong>作业调度：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobScheduleController.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">pauseJob</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">if</span> (!scheduler.isShutdown()) &#123;</div><div class="line">           scheduler.pauseAll();</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SchedulerException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>当注册中心重新连接成功( RECONNECTED )，恢复<strong>本地</strong>作业调度：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 恢复作业.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">resumeJob</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">if</span> (!scheduler.isShutdown()) &#123;</div><div class="line">          scheduler.resumeAll();</div><div class="line">      &#125;</div><div class="line">  &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SchedulerException ex) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(ex);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
</ul>
<h1>666. 彩蛋</h1>
<p>旁白君：芋道君，你又水更了！<br>
芋道君：是是是，是是是！</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_10_14/02.png" alt=""></p>
<p>道友，赶紧上车，分享一波朋友圈！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. ListenerManager&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a 
    
    </summary>
    
      <category term="Elastic-Job" scheme="http://www.yunai.me/categories/Elastic-Job/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Lite 源码分析 —— 作业数据存储</title>
    <link href="http://www.yunai.me/Elastic-Job/job-storage/"/>
    <id>http://www.yunai.me/Elastic-Job/job-storage/</id>
    <published>2017-10-06T16:00:00.000Z</published>
    <updated>2017-08-25T07:51:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p>
<ul>
<li><a href="#1-%E6%A6%82%E8%BF%B0">1. 概述</a></li>
<li><a href="#2-jobnodepath">2. JobNodePath</a></li>
<li><a href="#3-jobnodestorage">3. JobNodeStorage</a></li>
<li><a href="#4-configurationnode">4. ConfigurationNode</a></li>
<li><a href="#5-servernode">5. ServerNode</a></li>
<li><a href="#6-instancenode">6. InstanceNode</a></li>
<li><a href="#7-shardingnode">7. ShardingNode</a></li>
<li><a href="#8-leadernode">8. LeaderNode</a></li>
<li><a href="#9-failovernode">9. FailoverNode</a></li>
<li><a href="#10-guaranteenode">10. GuaranteeNode</a></li>
<li><a href="#666-%E5%BD%A9%E8%9B%8B">666. 彩蛋</a></li>
</ul>
<hr>
<h1>1. 概述</h1>
<p>本文主要分享 <strong>Elastic-Job-Lite 作业数据存储</strong>。</p>
<p>涉及到主要类的类图如下( <a href="http://www.yunai.me/images/Elastic-Job/2017_10_07/01.png">打开大图</a> )：</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_10_07/01.png" alt=""></p>
<blockquote>
<p>你行好事会因为得到赞赏而愉悦<br>
同理，开源项目贡献者会因为 Star 而更加有动力<br>
为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p>
</blockquote>
<h1>2. JobNodePath</h1>
<p>JobNodePath，作业节点路径类。<strong>作业节点是在普通的节点前加上作业名称的前缀</strong>。</p>
<p>在 Zookeeper 看一个作业的数据存储：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 65] ls /elastic-job-example-lite-java/javaSimpleJob</div><div class="line">[leader, servers, config, instances, sharding]</div></pre></td></tr></table></figure></p>
<ul>
<li><code>elastic-job-example-lite-java</code>：作业节点集群名，使用 <code>ZookeeperConfiguration.namespace</code> 属性配置。</li>
<li><code>javaSimpleJob</code>：作业名字，使用 <code>JobCoreConfiguration.jobName</code> 属性配置。</li>
<li><code>config</code> / <code>servers</code> / <code>instances</code> / <code>sharding</code> / <code>leader</code>：不同服务的数据存储节点路径。</li>
</ul>
<p>JobNodePath，注释很易懂，点击<a href="https://github.com/dangdangdotcom/elastic-job/blob/7dc099541a16de49f024fc59e46377a726be7f6b/elastic-job-lite/elastic-job-lite-core/src/main/java/com/dangdang/ddframe/job/lite/internal/storage/JobNodePath.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a>查看。这里我们梳理下 JobNodePath 和<strong>其它节点路径类</strong>的关系：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Zookeeper 路径</th>
<th style="text-align:left">JobNodePath 静态属性</th>
<th style="text-align:left">JobNodePath 方法</th>
<th style="text-align:left">节点路径类</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>config</code></td>
<td style="text-align:left">CONFIG_NODE</td>
<td style="text-align:left"><code>#getConfigNodePath()</code></td>
<td style="text-align:left">ConfigurationNode</td>
</tr>
<tr>
<td style="text-align:left"><code>servers</code></td>
<td style="text-align:left">SERVERS_NODE</td>
<td style="text-align:left"><code>#getServerNodePath()</code></td>
<td style="text-align:left">ServerNode</td>
</tr>
<tr>
<td style="text-align:left"><code>instances</code></td>
<td style="text-align:left">INSTANCES_NODE</td>
<td style="text-align:left"><code>#getInstancesNodePath()</code></td>
<td style="text-align:left">InstanceNode</td>
</tr>
<tr>
<td style="text-align:left"><code>sharding</code></td>
<td style="text-align:left">SHARDING_NODE</td>
<td style="text-align:left"><code>#getShardingNodePath()</code></td>
<td style="text-align:left">ShardingNode</td>
</tr>
<tr>
<td style="text-align:left"><code>leader</code></td>
<td style="text-align:left">/</td>
<td style="text-align:left"><code>#getFullPath(node)</code></td>
<td style="text-align:left">LeaderNode</td>
</tr>
<tr>
<td style="text-align:left"><code>leader/failover</code></td>
<td style="text-align:left">/</td>
<td style="text-align:left"><code>#getFullPath(node)</code></td>
<td style="text-align:left">FailoverNode</td>
</tr>
<tr>
<td style="text-align:left"><code>guarantee</code></td>
<td style="text-align:left">/</td>
<td style="text-align:left"><code>#getFullPath(node)</code></td>
<td style="text-align:left">GuaranteeNode</td>
</tr>
</tbody>
</table>
<h1>3. JobNodeStorage</h1>
<p>JobNodeStorage，作业节点数据访问类。</p>
<p>Elastic-Job-Lite 使用<strong>注册中心</strong>存储作业节点数据，JobNodeStorage 对注册中心提供的方法做下简单的封装提供调用。举个例子：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobNodeStorage.java</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> CoordinatorRegistryCenter regCenter;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> JobNodePath jobNodePath;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 判断作业节点是否存在.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> node 作业节点名称</div><div class="line">* <span class="doctag">@return</span> 作业节点是否存在</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isJobNodeExisted</span><span class="params">(<span class="keyword">final</span> String node)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> regCenter.isExisted(jobNodePath.getFullPath(node));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// JobNodePath.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 获取节点全路径.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> node 节点名称</div><div class="line">* <span class="doctag">@return</span> 节点全路径</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFullPath</span><span class="params">(<span class="keyword">final</span> String node)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> String.format(<span class="string">"/%s/%s"</span>, jobName, node);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>传递的参数 <code>node</code> 只是简单的<strong>作业节点名称</strong>，通过调用 <code>JobNodePath#getFullPath(...)</code> 方法获取节点全路径。</li>
<li>其它方法类似，有兴趣的同学点击<a href="https://github.com/dangdangdotcom/elastic-job/blob/7dc099541a16de49f024fc59e46377a726be7f6b/elastic-job-lite/elastic-job-lite-core/src/main/java/com/dangdang/ddframe/job/lite/internal/storage/JobNodePath.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a>查看。</li>
</ul>
<h1>4. ConfigurationNode</h1>
<p>ConfigurationNode，配置节点路径。</p>
<p>在 Zookeeper 看一个作业的<strong>配置</strong>节点数据存储：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 67] get /elastic-job-example-lite-java/javaSimpleJob/config</div><div class="line">&#123;<span class="string">"jobName"</span>:<span class="string">"javaSimpleJob"</span>,<span class="string">"jobClass"</span>:<span class="string">"com.dangdang.ddframe.job.example.job.simple.JavaSimpleJob"</span>,<span class="string">"jobType"</span>:<span class="string">"SIMPLE"</span>,<span class="string">"cron"</span>:<span class="string">"0/5 * * * * ?"</span>,<span class="string">"shardingTotalCount"</span>:3,<span class="string">"shardingItemParameters"</span>:<span class="string">"0\u003dBeijing,1\u003dShanghai,2\u003dGuangzhou"</span>,<span class="string">"jobParameter"</span>:<span class="string">""</span>,<span class="string">"failover"</span>:<span class="literal">true</span>,<span class="string">"misfire"</span>:<span class="literal">true</span>,<span class="string">"description"</span>:<span class="string">""</span>,<span class="string">"jobProperties"</span>:&#123;<span class="string">"job_exception_handler"</span>:<span class="string">"com.dangdang.ddframe.job.executor.handler.impl.DefaultJobExceptionHandler"</span>,<span class="string">"executor_service_handler"</span>:<span class="string">"com.dangdang.ddframe.job.executor.handler.impl.DefaultExecutorServiceHandler"</span>&#125;,<span class="string">"monitorExecution"</span>:<span class="literal">true</span>,<span class="string">"maxTimeDiffSeconds"</span>:-1,<span class="string">"monitorPort"</span>:-1,<span class="string">"jobShardingStrategyClass"</span>:<span class="string">""</span>,<span class="string">"reconcileIntervalMinutes"</span>:10,<span class="string">"disabled"</span>:<span class="literal">false</span>,<span class="string">"overwrite"</span>:<span class="literal">true</span>&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>/config</code> 是<strong>持久</strong>节点，存储Lite作业配置( LiteJobConfiguration ) JSON化字符串。</li>
</ul>
<p>ConfigurationNode 代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationNode</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ROOT = <span class="string">"config"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ConfigurationNode 如何读取、存储，在<a href="http://www.yunai.me/Elastic-Job/job-config/?self">《Elastic-Job-Lite 源码分析 —— 作业配置》的「3.」作业配置服务</a>已经详细解析。</p>
<h1>5. ServerNode</h1>
<p>ServerNode，服务器节点路径。</p>
<p>在 Zookeeper 看一个作业的<strong>服务器</strong>节点数据存储：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 72] ls /elastic-job-example-lite-java/javaSimpleJob/servers</div><div class="line">[192.168.16.164, 169.254.93.156, 192.168.252.57, 192.168.16.137, 192.168.3.2, 192.168.43.31]</div><div class="line">[zk: localhost:2181(CONNECTED) 73] get /elastic-job-example-lite-java/javaSimpleJob/servers/192.168.16.164</div></pre></td></tr></table></figure></p>
<ul>
<li><code>/servers/</code> 目录下以 <code>IP</code> 为数据节点路径存储每个服务器节点。如果<strong>相同IP</strong>服务器有多个服务器节点，只存储一个 <code>IP</code> 数据节点。</li>
<li><code>/servers/${IP}</code> 是<strong>持久</strong>节点，不存储任何信息，只是空串( <code>&quot;&quot;</code>);</li>
</ul>
<p>ServerNode 代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerNode</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 服务器信息根节点.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROOT = <span class="string">"servers"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVERS = ROOT + <span class="string">"/%s"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ServerNode 如何存储，在<a href="http://www.yunai.me/Elastic-Job/job-init/?self">《Elastic-Job-Lite 源码分析 —— 作业初始化》的「3.2.4」注册作业启动信息</a>已经详细解析。</p>
<h1>6. InstanceNode</h1>
<p>InstanceNode，运行实例节点路径。</p>
<p>在 Zookeeper 看一个作业的<strong>运行实例</strong>节点数据存储：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 81] ls /elastic-job-example-lite-java/javaSimpleJob/instances</div><div class="line">[192.168.16.137@-@56010]</div><div class="line">[zk: localhost:2181(CONNECTED) 82] get /elastic-job-example-lite-java/javaSimpleJob/instances</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p><code>/instances</code> 目录下以作业实例主键( <code>JOB_INSTANCE_ID</code> ) 为数据节点路径存储每个运行实例节点。</p>
</li>
<li>
<p><code>/instances/${JOB_INSTANCE_ID}</code> 是<strong>临时</strong>节点，不存储任何信息，只是空串( <code>&quot;&quot;</code>);</p>
</li>
<li>
<p><code>JOB_INSTANCE_ID</code> 生成方式：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobInstance.java</span></div><div class="line"></div><div class="line">jobInstanceId = IpUtils.getIp()</div><div class="line">                + DELIMITER</div><div class="line">                + ManagementFactory.getRuntimeMXBean().getName().split(<span class="string">"@"</span>)[<span class="number">0</span>]; <span class="comment">// PID</span></div></pre></td></tr></table></figure></p>
</li>
</ul>
<p>InstanceNode 代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceNode</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 运行实例信息根节点.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROOT = <span class="string">"instances"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String INSTANCES = ROOT + <span class="string">"/%s"</span>;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取当前运行实例节点路径</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> 当前运行实例节点路径</div><div class="line">     */</div><div class="line">    <span class="function">String <span class="title">getLocalInstanceNode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> String.format(INSTANCES, JobRegistry.getInstance().getJobInstance(jobName).getJobInstanceId());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>InstanceNode 如何存储，在<a href="http://www.yunai.me/Elastic-Job/job-init/?self">《Elastic-Job-Lite 源码分析 —— 作业初始化》的「3.2.4」注册作业启动信息</a>已经详细解析。</p>
<h1>7. ShardingNode</h1>
<p>ShardingNode，分片节点路径。</p>
<p>在 Zookeeper 看一个作业的<strong>分片</strong>节点数据存储：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 1] ls /elastic-job-example-lite-java/javaSimpleJob/sharding</div><div class="line">[0, 1, 2]</div><div class="line">[zk: localhost:2181(CONNECTED) 2] ls /elastic-job-example-lite-java/javaSimpleJob/sharding/0</div><div class="line">[running, instance, misfire]</div><div class="line">[zk: localhost:2181(CONNECTED) 3] get /elastic-job-example-lite-java/javaSimpleJob/sharding/0/instance</div><div class="line">192.168.16.137@-@56010</div></pre></td></tr></table></figure></p>
<ul>
<li><code>/sharding/${ITEM_ID}</code> 目录下以作业分片项序号( <code>ITEM_ID</code> ) 为数据节点路径存储作业分片项的 <code>instance</code> / <code>running</code> / <code>misfire</code> / <code>disable</code> <strong>数据节点</strong>信息。</li>
<li><code>/sharding/${ITEM_ID}/instance</code> 是<strong>临时</strong>节点，存储该作业分片项<strong>分配到的作业实例主键</strong>( <code>JOB_INSTANCE_ID</code> )。在<a href="http://www.yunai.me/Elastic-Job/ob-sharding/?self">《Elastic-Job-Lite 源码分析 —— 作业分片》</a>详细解析。</li>
<li><code>/sharding/${ITEM_ID}/running</code> 是<strong>临时</strong>节点，当该作业分片项<strong>正在运行</strong>，存储空串( <code>&quot;&quot;</code> )；当该作业分片项<strong>不在运行</strong>，移除该数据节点。<a href="http://www.yunai.me/Elastic-Job/job-init/?self">《Elastic-Job-Lite 源码分析 —— 作业执行》的「4.6」执行普通触发的作业</a>已经详细解析。</li>
<li><code>/sharding/${ITEM_ID}/misfire</code> 是<strong>永久节点</strong>，当该作业分片项<strong>被错过执行</strong>，存储空串( <code>&quot;&quot;</code> )；当该作业分片项重新执行，移除该数据节点。<a href="http://www.yunai.me/Elastic-Job/job-init/?self">《Elastic-Job-Lite 源码分析 —— 作业执行》的「4.7」执行被错过触发的作业</a>已经详细解析。</li>
<li><code>/sharding/${ITEM_ID}/disable</code> 是<strong>永久节点</strong>，当该作业分片项<strong>被禁用</strong>，存储空串( <code>&quot;&quot;</code> )；当该作业分片项<strong>被开启</strong>，移除数据节点。</li>
</ul>
<p>ShardingNode，代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingNode</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 执行状态根节点.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROOT = <span class="string">"sharding"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String INSTANCE_APPENDIX = <span class="string">"instance"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INSTANCE = ROOT + <span class="string">"/%s/"</span> + INSTANCE_APPENDIX;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String RUNNING_APPENDIX = <span class="string">"running"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String RUNNING = ROOT + <span class="string">"/%s/"</span> + RUNNING_APPENDIX;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String MISFIRE = ROOT + <span class="string">"/%s/misfire"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DISABLED = ROOT + <span class="string">"/%s/disabled"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String LEADER_ROOT = LeaderNode.ROOT + <span class="string">"/"</span> + ROOT;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String NECESSARY = LEADER_ROOT + <span class="string">"/necessary"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String PROCESSING = LEADER_ROOT + <span class="string">"/processing"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>LEADER_ROOT / NECESSARY / PROCESSING 放在「4.7」<strong>LeaderNode</strong> 解析。</li>
</ul>
<h1>8. LeaderNode</h1>
<p>LeaderNode，主节点路径。</p>
<p>在 <code>leader</code> 目录下一共有三个存储子节点：</p>
<ul>
<li><code>election</code>：主节点选举。</li>
<li><code>sharding</code>：作业分片项分配。</li>
<li><code>failover</code>：作业失效转移。</li>
</ul>
<p><strong>主节点选举</strong></p>
<p>在 Zookeeper 看一个作业的 <strong><code>leader/election</code></strong> 节点数据存储：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 1] ls /elastic-job-example-lite-java/javaSimpleJob/leader/election</div><div class="line">[latch, instance]</div><div class="line">[zk: localhost:2181(CONNECTED) 2] get /elastic-job-example-lite-java/javaSimpleJob/leader/election/instance</div><div class="line">192.168.16.137@-@1910</div></pre></td></tr></table></figure></p>
<ul>
<li><code>/leader/election/instance</code> 是<strong>临时</strong>节点，当作业集群完成选举后，存储主作业实例主键( <code>JOB_INSTANCE_ID</code> )。</li>
<li><code>/leader/election/latch</code> 主节点选举分布式锁，是 Apache Curator 针对 Zookeeper 实现的<strong>分布式锁</strong>的一种，笔者暂未了解存储形式，无法解释。在<a href="http://www.yunai.me/Elastic-Job/reg-center-zookeeper/?self">《Elastic-Job-Lite 源码分析 —— 注册中心》的「3.1」在主节点执行操作</a>进行了简单解析。</li>
</ul>
<p><strong>作业分片项分配</strong></p>
<p>在 Zookeeper 看一个作业的 <strong><code>leader/sharding</code></strong> 节点数据存储：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 1] ls /elastic-job-example-lite-java/javaSimpleJob/leader/sharding</div><div class="line">[necessary, processing]</div><div class="line">[zk: localhost:2181(CONNECTED) 2] 个get /elastic-job-example-lite-java/javaSimpleJob/leader/sharding</div><div class="line"></div><div class="line">[zk: localhost:2181(CONNECTED) 3] 个get /elastic-job-example-lite-java/javaSimpleJob/leader/processing</div></pre></td></tr></table></figure></p>
<ul>
<li><code>/leader/sharding/necessary</code> 是<strong>永久节点</strong>，当<strong>相同作业</strong>有新的作业节点加入或者移除时，存储空串( <code>&quot;&quot;</code> )，标记需要进行作业分片项重新分配；当重新分配完成后，移除该数据节点。</li>
<li><code>/leader/sharding/processing</code> 是<strong>临时节点</strong>，当开始重新分配作业分片项时，存储空串( <code>&quot;&quot;</code> )，标记正在进行重新分配；当重新分配完成后，移除该数据节点。</li>
<li>当且仅当作业节点为主节点时，才可以执行作业分片项分配，<a href="http://www.yunai.me/Elastic-Job/job-sharding/?self">《Elastic-Job-Lite 源码分析 —— 作业分片》</a>详细解析。</li>
</ul>
<p><strong>作业失效转移</strong></p>
<p>作业失效转移数据节点在 FailoverNode，放在「9」<strong>FailoverNode</strong> 解析。</p>
<p>这里大家可能会和我一样比较疑惑，为什么 <code>/leader/failover</code> 放在 <code>/leader</code> 目录下，而不独立成为一个根目录？经过确认，<strong>作业失效转移</strong> 设计到分布式锁，统一存储在 <code>/leader</code> 目录下。</p>
<hr>
<p>LeaderNode，代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaderNode</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 主节点根路径.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROOT = <span class="string">"leader"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ELECTION_ROOT = ROOT + <span class="string">"/election"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String INSTANCE = ELECTION_ROOT + <span class="string">"/instance"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String  LATCH = ELECTION_ROOT + <span class="string">"/latch"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>9. FailoverNode</h1>
<p>FailoverNode，失效转移节点路径。</p>
<p>在 Zookeeper 看一个作业的<strong>失效转移</strong>节点数据存储：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">2</span>] ls /elastic-job-example-lite-java/javaSimpleJob/leader/failover</div><div class="line">[latch, items]</div><div class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">4</span>] ls /elastic-job-example-lite-java/javaSimpleJob/leader/failover/items</div><div class="line">[<span class="number">0</span>]</div></pre></td></tr></table></figure></p>
<ul>
<li><code>/leader/failover/latch</code> 作业失效转移分布式锁，和 <code>/leader/failover/latch</code> 是一致的。</li>
<li><code>/leader/items/${ITEM_ID}</code> 是<strong>永久节点</strong>，当某台作业节点 CRASH 时，其分配的作业分片项标记需要进行失效转移，存储其分配的作业分片项的 <code>/leader/items/${ITEM_ID}</code> 为空串( <code>&quot;&quot;</code> )；当失效转移标记，移除 <code>/leader/items/${ITEM_ID}</code>，存储 <code>/sharding/${ITEM_ID}/failover</code> 为空串( <code>&quot;&quot;</code> )，<strong>临时</strong>节点，需要进行失效转移执行。<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31_bak.jpg">《Elastic-Job-Lite 源码分析 —— 作业失效转移》</a>详细解析。</li>
</ul>
<p>FailoverNode 代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FailoverNode</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String FAILOVER = <span class="string">"failover"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String LEADER_ROOT = LeaderNode.ROOT + <span class="string">"/"</span> + FAILOVER;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ITEMS_ROOT = LEADER_ROOT + <span class="string">"/items"</span>;</div><div class="line">        </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ITEMS = ITEMS_ROOT + <span class="string">"/%s"</span>;</div><div class="line">        </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String LATCH = LEADER_ROOT + <span class="string">"/latch"</span>;</div><div class="line">        </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXECUTION_FAILOVER = ShardingNode.ROOT + <span class="string">"/%s/"</span> + FAILOVER;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">getItemsNode</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> item)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> String.format(ITEMS, item);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">getExecutionFailoverNode</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> item)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> String.format(EXECUTION_FAILOVER, item);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>10. GuaranteeNode</h1>
<p>GuaranteeNode，保证分布式任务全部开始和结束状态节点路径。在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31_bak.jpg">《Elastic-Job-Lite 源码分析 —— 保证分布式任务全部开始和结束状态》</a>详细解析。</p>
<h1>666. 彩蛋</h1>
<p>旁白君：芋道君，你又水更了！<br>
芋道君：屁屁屁，劳资怼死你！如下是作业数据存储整理，哼哼哈兮！</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_10_07/02.png" alt=""></p>
<p>道友，赶紧上车，分享一波朋友圈！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-%E6%A6%82%E8%BF%B0&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-jobnodepath&quot;&gt;2.
    
    </summary>
    
      <category term="Elastic-Job" scheme="http://www.yunai.me/categories/Elastic-Job/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Lite 源码分析 —— 注册中心</title>
    <link href="http://www.yunai.me/Elastic-Job/reg-center-zookeeper/"/>
    <id>http://www.yunai.me/Elastic-Job/reg-center-zookeeper/</id>
    <published>2017-09-29T16:00:00.000Z</published>
    <updated>2017-08-25T07:44:29.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. 基于 Zookeeper 注册中心</a>
<ul>
<li><a href="#">2.1 初始化</a></li>
<li><a href="#">2.2 缓存</a></li>
<li><a href="#">2.3 关闭</a></li>
<li><a href="#">2.4 获得数据</a></li>
<li><a href="#">2.5 获得注册子节点</a></li>
<li><a href="#">2.6 存储注册数据</a></li>
<li><a href="#">2.7 存储顺序注册数据</a></li>
<li><a href="#">2.8 移除注册数据</a></li>
<li><a href="#">2.9 获取注册中心当前时间</a></li>
<li><a href="#">2.10 注册中心异常处理器</a></li>
</ul>
</li>
<li><a href="#">3. 作业节点数据访问类</a>
<ul>
<li><a href="#">3.1 在主节点执行操作</a></li>
<li><a href="#">3.2 在事务中执行操作</a></li>
</ul>
</li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<h1>1. 概述</h1>
<p>本文主要分享 <strong>Elastic-Job-Lite 注册中心</strong>。</p>
<p>涉及到主要类的类图如下( <a href="http://www.yunai.me/images/Elastic-Job/2017_09_30/01.png">打开大图</a> )：</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_09_30/01.png" alt=""></p>
<ul>
<li><strong>黄色</strong>的类在 <code>elastic-job-common-core</code> 项目里，为 Elastic-Job-Lite、Elastic-Job-Cloud <strong>公用</strong>注册中心类。</li>
<li>作业节点数据访问类( JobNodeStorage )的<strong>在主节点执行操作</strong>、<strong>在事务中执行操作</strong>两个方法和注册中心<strong>协调分布式服务</strong>有关系，从<a href="http://www.yunai.me/Elastic-Job/job-storage/?self">《Elastic-Job-Lite 源码解析 —— 作业数据存储》</a>摘出来，放本文解析。</li>
</ul>
<blockquote>
<p>你行好事会因为得到赞赏而愉悦<br>
同理，开源项目贡献者会因为 Star 而更加有动力<br>
为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p>
</blockquote>
<h1>2. 基于 Zookeeper 注册中心</h1>
<p>ZookeeperRegistryCenter，基于 Zookeeper 注册中心。从上面的类图可以看到，ZookeeperRegistryCenter 实现 CoordinatorRegistryCenter 接口，CoordinatorRegistryCenter 继承 RegistryCenter 接口。</p>
<ul>
<li>RegistryCenter，注册中心，定义了简单的增删改查注册数据和查询时间的接口方法。</li>
<li>CoordinatorRegistryCenter，用于协调分布式服务的注册中心，定义了持久节点、临时节点、持久顺序节点、临时顺序节点等<strong>目录服务</strong>接口方法，隐性的要求提供<strong>事务</strong>、<strong>分布式锁</strong>、<strong>数据订阅</strong>等特性。</li>
</ul>
<p>ZookeeperRegistryCenter 使用 <a href="https://curator.apache.org/" rel="external nofollow noopener noreferrer" target="_blank">Apache Curator</a> 进行 Zookeeper 注册中心。</p>
<h2>2.1 初始化</h2>
<p>ZookeeperConfiguration，基于 Zookeeper 的注册中心配置，注释完整，点击<a href="https://github.com/dangdangdotcom/elastic-job/blob/7dc099541a16de49f024fc59e46377a726be7f6b/elastic-job-common/elastic-job-common-core/src/main/java/com/dangdang/ddframe/job/reg/zookeeper/ZookeeperConfiguration.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a>直接查看。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">   log.debug(<span class="string">"Elastic job: zookeeper registry center init, server lists is: &#123;&#125;."</span>, zkConfig.getServerLists());</div><div class="line">   CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder()</div><div class="line">           .connectString(zkConfig.getServerLists())</div><div class="line">           .retryPolicy(<span class="keyword">new</span> ExponentialBackoffRetry(zkConfig.getBaseSleepTimeMilliseconds(), zkConfig.getMaxRetries(), zkConfig.getMaxSleepTimeMilliseconds()))</div><div class="line">           .namespace(zkConfig.getNamespace()); <span class="comment">// 命名空间</span></div><div class="line">   <span class="keyword">if</span> (<span class="number">0</span> != zkConfig.getSessionTimeoutMilliseconds()) &#123;</div><div class="line">       builder.sessionTimeoutMs(zkConfig.getSessionTimeoutMilliseconds()); <span class="comment">// 会话超时时间，默认 60 * 1000 毫秒</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (<span class="number">0</span> != zkConfig.getConnectionTimeoutMilliseconds()) &#123;</div><div class="line">       builder.connectionTimeoutMs(zkConfig.getConnectionTimeoutMilliseconds()); <span class="comment">// 连接超时时间，默认 15 * 1000 毫秒</span></div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 认证</span></div><div class="line">   <span class="keyword">if</span> (!Strings.isNullOrEmpty(zkConfig.getDigest())) &#123;</div><div class="line">       builder.authorization(<span class="string">"digest"</span>, zkConfig.getDigest().getBytes(Charsets.UTF_8))</div><div class="line">               .aclProvider(<span class="keyword">new</span> ACLProvider() &#123;</div><div class="line">               </div><div class="line">                   <span class="meta">@Override</span></div><div class="line">                   <span class="function"><span class="keyword">public</span> List&lt;ACL&gt; <span class="title">getDefaultAcl</span><span class="params">()</span> </span>&#123;</div><div class="line">                       <span class="keyword">return</span> ZooDefs.Ids.CREATOR_ALL_ACL;</div><div class="line">                   &#125;</div><div class="line">               </div><div class="line">                   <span class="meta">@Override</span></div><div class="line">                   <span class="function"><span class="keyword">public</span> List&lt;ACL&gt; <span class="title">getAclForPath</span><span class="params">(<span class="keyword">final</span> String path)</span> </span>&#123;</div><div class="line">                       <span class="keyword">return</span> ZooDefs.Ids.CREATOR_ALL_ACL;</div><div class="line">                   &#125;</div><div class="line">               &#125;);</div><div class="line">   &#125;</div><div class="line">   client = builder.build();</div><div class="line">   client.start();</div><div class="line">   <span class="comment">// 连接 Zookeeper</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">if</span> (!client.blockUntilConnected(zkConfig.getMaxSleepTimeMilliseconds() * zkConfig.getMaxRetries(), TimeUnit.MILLISECONDS)) &#123;</div><div class="line">           client.close();</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> KeeperException.OperationTimeoutException();</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       RegExceptionHandler.handleException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>ExponentialBackoffRetry，当 Zookeeper 失去链接后重新连接的<strong>一种</strong>策略：动态计算每次计算重连的间隔，时间间隔 = <code>baseSleepTimeMs * Math.max(1, random.nextInt(1 &lt;&lt; (retryCount + 1)))</code>。如果对其它重连策略感兴趣，可以看 <a href="https://github.com/apache/curator/blob/abaabb5f65c2161f77527165a15d2420f6c88219/curator-client/src/main/java/org/apache/curator/RetryPolicy.java" rel="external nofollow noopener noreferrer" target="_blank">RetryPolicy</a> 的实现类，本文就不展开了。</li>
<li><strong>相同</strong>的作业集群使用<strong>相同</strong>的 Zookeeper 命名空间( <code>ZookeeperConfiguration.namespace</code> )。</li>
</ul>
<h2>2.2 缓存</h2>
<p>通过 Curator TreeCache 实现监控整个树( Zookeeper目录 )的数据订阅和缓存，包括节点的状态，子节点的状态。</p>
<p><strong>初始化作业缓存</strong></p>
<p>作业初始化注册时，初始化缓存。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobRegistry.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerJob</span><span class="params">(<span class="keyword">final</span> String jobName, <span class="keyword">final</span> JobScheduleController jobScheduleController, <span class="keyword">final</span> CoordinatorRegistryCenter regCenter)</span> </span>&#123;</div><div class="line">   schedulerMap.put(jobName, jobScheduleController);</div><div class="line">   regCenterMap.put(jobName, regCenter);</div><div class="line">   <span class="comment">// 添加注册中心缓存</span></div><div class="line">   regCenter.addCacheData(<span class="string">"/"</span> + jobName);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">// ZookeeperRegistryCenter.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 缓存</div><div class="line">* key：/作业名/</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, TreeCache&gt; caches = <span class="keyword">new</span> HashMap&lt;&gt;();</div></pre></td></tr></table></figure></p>
<p><strong>作业服务订阅数据</strong></p>
<p>每个不同的服务，都会订阅数据实现功能逻辑。在后续不同服务的文章，我们会详细解析。🙂</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDataListener</span><span class="params">(<span class="keyword">final</span> TreeCacheListener listener)</span> </span>&#123;</div><div class="line">   TreeCache cache = (TreeCache) regCenter.getRawCache(<span class="string">"/"</span> + jobName);</div><div class="line">   cache.getListenable().addListener(listener);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>关闭作业缓存</strong></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evictCacheData</span><span class="params">(<span class="keyword">final</span> String cachePath)</span> </span>&#123;</div><div class="line">   TreeCache cache = caches.remove(cachePath + <span class="string">"/"</span>);</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != cache) &#123;</div><div class="line">       cache.close();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对 Curator TreeCache 感兴趣的同学，可以点击<a href="http://colobu.com/2014/12/15/zookeeper-recipes-by-example-5/" rel="external nofollow noopener noreferrer" target="_blank">链接</a>继续了解。</p>
<h2>2.3 关闭</h2>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (Entry&lt;String, TreeCache&gt; each : caches.entrySet()) &#123;</div><div class="line">       each.getValue().close();</div><div class="line">   &#125;</div><div class="line">   waitForCacheClose();</div><div class="line">   CloseableUtils.closeQuietly(client);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">/* TODO 等待500ms, cache先关闭再关闭client, 否则会抛异常</span></div><div class="line">* 因为异步处理, 可能会导致client先关闭而cache还未关闭结束.</div><div class="line">* 等待Curator新版本解决这个bug.</div><div class="line">* BUG地址：https://issues.apache.org/jira/browse/CURATOR-157</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">waitForCacheClose</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       Thread.sleep(<span class="number">500L</span>);</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> InterruptedException ex) &#123;</div><div class="line">       Thread.currentThread().interrupt();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>2.4 获得数据</h2>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</div><div class="line">   TreeCache cache = findTreeCache(key); <span class="comment">// 获取缓存</span></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> == cache) &#123;</div><div class="line">       <span class="keyword">return</span> getDirectly(key);</div><div class="line">   &#125;</div><div class="line">   ChildData resultInCache = cache.getCurrentData(key); <span class="comment">// 缓存中获取 value</span></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != resultInCache) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">null</span> == resultInCache.getData() ? <span class="keyword">null</span> : <span class="keyword">new</span> String(resultInCache.getData(), Charsets.UTF_8);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> getDirectly(key);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDirectly</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> String(client.getData().forPath(key), Charsets.UTF_8);</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       RegExceptionHandler.handleException(ex);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p><code>#get(...)</code> 先从 <strong>TreeCache缓存</strong> 获取，后从 Zookeeper 获取。</p>
</li>
<li>
<p><code>#getDirectly(...)</code> <strong>直接</strong>从 Zookeeper 获取。</p>
</li>
<li>
<p><code>#findTreeCache(...)</code> 代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> TreeCache <span class="title">findTreeCache</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (Entry&lt;String, TreeCache&gt; entry : caches.entrySet()) &#123;</div><div class="line">       <span class="keyword">if</span> (key.startsWith(entry.getKey())) &#123;</div><div class="line">           <span class="keyword">return</span> entry.getValue();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
</ul>
<h2>2.5 获得注册子节点</h2>
<p><strong>获取子节点名称集合(降序)</strong></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getChildrenKeys</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       List&lt;String&gt; result = client.getChildren().forPath(key);</div><div class="line">       Collections.sort(result, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</div><div class="line">           </div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">final</span> String o1, <span class="keyword">final</span> String o2)</span> </span>&#123;</div><div class="line">               <span class="keyword">return</span> o2.compareTo(o1);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">       <span class="keyword">return</span> result;</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       RegExceptionHandler.handleException(ex);</div><div class="line">       <span class="keyword">return</span> Collections.emptyList();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>获取子节点数量</strong></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumChildren</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       Stat stat = client.checkExists().forPath(key);</div><div class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> != stat) &#123;</div><div class="line">           <span class="keyword">return</span> stat.getNumChildren();</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       RegExceptionHandler.handleException(ex);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>2.6 存储注册数据</h2>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">persist</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> String value)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">if</span> (!isExisted(key)) &#123;</div><div class="line">           client.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(key, value.getBytes(Charsets.UTF_8));</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           update(key, value);</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       RegExceptionHandler.handleException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">persistEphemeral</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> String value)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">if</span> (isExisted(key)) &#123;</div><div class="line">           client.delete().deletingChildrenIfNeeded().forPath(key);</div><div class="line">       &#125;</div><div class="line">       client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(key, value.getBytes(Charsets.UTF_8));</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       RegExceptionHandler.handleException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p><code>#persist(...)</code> 存储<strong>持久</strong>节点数据。逻辑等价于 insertOrUpdate 操作。</p>
</li>
<li>
<p><code>persistEphemeral(...)</code> 存储<strong>临时</strong>节点数据。节点类型无法变更，因此如果数据已存在，需要先进行删除。</p>
</li>
<li>
<p><code>#isExisted(...)</code>、<code>#update(...)</code> 代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExisted</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">null</span> != client.checkExists().forPath(key);</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       RegExceptionHandler.handleException(ex);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">   </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> String value)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       client.inTransaction().check().forPath(key).and().setData().forPath(key, value.getBytes(Charsets.UTF_8)).and().commit();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       RegExceptionHandler.handleException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>#update(...)</code> 使用<strong>事务</strong>校验键( key )存在才进行更新。</li>
</ul>
</li>
</ul>
<h2>2.7 存储顺序注册数据</h2>
<p>实现逻辑和<strong>存储注册数据</strong>类似。Elastic-Job 未使用该方法，跳过。</p>
<h2>2.8 移除注册数据</h2>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       client.delete().deletingChildrenIfNeeded().forPath(key);</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       RegExceptionHandler.handleException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>2.9 获取注册中心当前时间</h2>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getRegistryCenterTime</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</div><div class="line">   <span class="keyword">long</span> result = <span class="number">0L</span>;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       persist(key, <span class="string">""</span>);</div><div class="line">       result = client.checkExists().forPath(key).getMtime();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       RegExceptionHandler.handleException(ex);</div><div class="line">   &#125;</div><div class="line">   Preconditions.checkState(<span class="number">0L</span> != result, <span class="string">"Cannot get registry center time."</span>);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>通过更新节点，获得该节点的最后更新时间( <code>mtime</code> )获得 Zookeeper 的时间。six six six。</li>
</ul>
<h2>2.10 注册中心异常处理器</h2>
<p>RegExceptionHandler，注册中心异常处理器。在上面的操作 Zookeeper 发生异常时，都会调用 <code>RegExceptionHandler.handleException(...)</code> 处理异常：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleException</span><span class="params">(<span class="keyword">final</span> Exception cause)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> == cause) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (isIgnoredException(cause) || <span class="keyword">null</span> != cause.getCause() &amp;&amp; isIgnoredException(cause.getCause())) &#123;</div><div class="line">       log.debug(<span class="string">"Elastic job: ignored exception for: &#123;&#125;"</span>, cause.getMessage());</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> InterruptedException) &#123;</div><div class="line">       Thread.currentThread().interrupt();</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RegException(cause);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isIgnoredException</span><span class="params">(<span class="keyword">final</span> Throwable cause)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> cause <span class="keyword">instanceof</span> ConnectionLossException || cause <span class="keyword">instanceof</span> NoNodeException || cause <span class="keyword">instanceof</span> NodeExistsException;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>部分异常会被无视，仅打印异常。例如调用 <code>#getDirectly(...)</code> 获得注册数据时，可能节点不存在，抛出 NodeExistsException，这种异常可以无视。</li>
</ul>
<h1>3. 作业节点数据访问类</h1>
<p>JobNodeStorage，作业节点数据访问类。</p>
<h2>3.1 在主节点执行操作</h2>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobNodeStorage.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 在主节点执行操作.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> latchNode 分布式锁使用的节点，例如：leader/election/latch</div><div class="line">* <span class="doctag">@param</span> callback 执行操作的回调</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeInLeader</span><span class="params">(<span class="keyword">final</span> String latchNode, <span class="keyword">final</span> LeaderExecutionCallback callback)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> (LeaderLatch latch = <span class="keyword">new</span> LeaderLatch(getClient(), jobNodePath.getFullPath(latchNode))) &#123;</div><div class="line">       latch.start();</div><div class="line">       latch.await();</div><div class="line">       callback.execute();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       handleException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="https://curator.apache.org/" rel="external nofollow noopener noreferrer" target="_blank">Apache Curator</a> 使用 Zookeeper 实现了两种分布式锁，LeaderLatch 是其中的一种。使用<strong>一个</strong> Zookeeper 节点路径创建<strong>一个</strong> LeaderLatch，<code>#start()</code> 后，调用 <code>#await()</code> 等待拿到这把<strong>锁</strong>。如果有多个线程执行了<strong>相同节点路径</strong>的 LeaderLatch 的 <code>#await()</code> 后，同一时刻有且仅有一个线程可以继续执行，其他线程需要等待。当该线程释放( <code>LeaderLatch#close()</code> )后，下一个线程可以拿到该<strong>锁</strong>继续执行。用 Java 并发包 Lock 举例子：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeInLeader</span><span class="params">(Lock lock)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        lock.lock();</div><div class="line">        <span class="comment">// doSomething();</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="https://github.com/Netflix/curator/wiki/Leader-Latch" rel="external nofollow noopener noreferrer" target="_blank">《官方文档 —— LeaderLatch》</a>，有兴趣的同学可以看看。在<a href="http://www.yunai.me/Elastic-Job/election/?self">《Elastic-Job-Lite 源码解析 —— 主节点选举》</a>中，我们会看到 <code>#executeInLeader(...)</code> 的使用。</p>
<p>另一种分布式锁实现，<a href="https://github.com/Netflix/curator/wiki/Leader-Election" rel="external nofollow noopener noreferrer" target="_blank">《官方文档 —— LeaderElection》</a>，有兴趣也可以看看。在 Elastic-Job-Cloud 中使用到了，后续进行解析。</p>
<h2>3.2 在事务中执行操作</h2>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobNodeStorage.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeInTransaction</span><span class="params">(<span class="keyword">final</span> TransactionExecutionCallback callback)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       CuratorTransactionFinal curatorTransactionFinal = getClient().inTransaction().check().forPath(<span class="string">"/"</span>).and();</div><div class="line">       callback.execute(curatorTransactionFinal);</div><div class="line">       curatorTransactionFinal.commit();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       RegExceptionHandler.handleException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>开启事务，执行 TransactionExecutionCallback 回调逻辑，提交事务。</li>
</ul>
<h1>666. 彩蛋</h1>
<p>旁白君：煞笔芋道君，又在水更<br>
芋道君：人艰不拆，好不好。</p>
<p>道友，赶紧上车，分享一波朋友圈！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. 基
    
    </summary>
    
      <category term="Elastic-Job" scheme="http://www.yunai.me/categories/Elastic-Job/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Lite 源码分析 —— 作业执行</title>
    <link href="http://www.yunai.me/Elastic-Job/job-execute/"/>
    <id>http://www.yunai.me/Elastic-Job/job-execute/</id>
    <published>2017-09-22T16:00:00.000Z</published>
    <updated>2017-08-25T07:42:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p>
<ul>
<li><a href="#1-%E6%A6%82%E8%BF%B0">1. 概述</a></li>
<li><a href="#2-lite%E8%B0%83%E5%BA%A6%E4%BD%9C%E4%B8%9A">2. Lite调度作业</a></li>
<li><a href="#3-%E6%89%A7%E8%A1%8C%E5%99%A8%E5%88%9B%E5%BB%BA">3. 执行器创建</a>
<ul>
<li><a href="#31-%E5%8A%A0%E8%BD%BD%E4%BD%9C%E4%B8%9A%E9%85%8D%E7%BD%AE">3.1 加载作业配置</a></li>
<li><a href="#32-%E8%8E%B7%E5%8F%96%E4%BD%9C%E4%B8%9A%E6%89%A7%E8%A1%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0">3.2 获取作业执行线程池</a></li>
<li><a href="#33-%E8%8E%B7%E5%8F%96%E4%BD%9C%E4%B8%9A%E5%BC%82%E5%B8%B8%E6%89%A7%E8%A1%8C%E5%99%A8">3.3 获取作业异常执行器</a></li>
</ul>
</li>
<li><a href="#4-%E6%89%A7%E8%A1%8C%E5%99%A8%E6%89%A7%E8%A1%8C">4. 执行器执行</a>
<ul>
<li><a href="#41-%E6%A3%80%E6%9F%A5%E4%BD%9C%E4%B8%9A%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83">4.1 检查作业执行环境</a></li>
<li><a href="#42-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E4%BD%9C%E4%B8%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%88%86%E7%89%87%E4%B8%8A%E4%B8%8B%E6%96%87">4.2 获取当前作业服务器的分片上下文</a></li>
<li><a href="#43-%E5%8F%91%E5%B8%83%E4%BD%9C%E4%B8%9A%E7%8A%B6%E6%80%81%E8%BF%BD%E8%B8%AA%E4%BA%8B%E4%BB%B6">4.3 发布作业状态追踪事件</a></li>
<li><a href="#44-%E8%B7%B3%E8%BF%87%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84%E8%A2%AB%E9%94%99%E8%BF%87%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BD%9C%E4%B8%9A">4.4 跳过正在运行中的被错过执行的作业</a></li>
<li><a href="#45-%E6%89%A7%E8%A1%8C%E4%BD%9C%E4%B8%9A%E6%89%A7%E8%A1%8C%E5%89%8D%E7%9A%84%E6%96%B9%E6%B3%95">4.5 执行作业执行前的方法</a></li>
<li><a href="#46-%E6%89%A7%E8%A1%8C%E6%99%AE%E9%80%9A%E8%A7%A6%E5%8F%91%E7%9A%84%E4%BD%9C%E4%B8%9A">4.6 执行普通触发的作业</a>
<ul>
<li><a href="#461-%E7%AE%80%E5%8D%95%E4%BD%9C%E4%B8%9A%E6%89%A7%E8%A1%8C%E5%99%A8">4.6.1 简单作业执行器</a></li>
<li><a href="#462-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%BD%9C%E4%B8%9A%E6%89%A7%E8%A1%8C%E5%99%A8">4.6.2 数据流作业执行器</a></li>
<li><a href="#463-%E8%84%9A%E6%9C%AC%E4%BD%9C%E4%B8%9A%E6%89%A7%E8%A1%8C%E5%99%A8">4.6.3 脚本作业执行器</a></li>
</ul>
</li>
<li><a href="#47-%E6%89%A7%E8%A1%8C%E8%A2%AB%E9%94%99%E8%BF%87%E8%A7%A6%E5%8F%91%E7%9A%84%E4%BD%9C%E4%B8%9A">4.7 执行被错过触发的作业</a></li>
<li><a href="#48-%E6%89%A7%E8%A1%8C%E4%BD%9C%E4%B8%9A%E5%A4%B1%E6%95%88%E8%BD%AC%E7%A7%BB">4.8 执行作业失效转移</a></li>
<li><a href="#49-%E6%89%A7%E8%A1%8C%E4%BD%9C%E4%B8%9A%E6%89%A7%E8%A1%8C%E5%90%8E%E7%9A%84%E6%96%B9%E6%B3%95">4.9 执行作业执行后的方法</a></li>
</ul>
</li>
<li><a href="#666-%E5%BD%A9%E8%9B%8B">666. 彩蛋</a></li>
</ul>
<hr>
<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<h1>1. 概述</h1>
<p>本文主要分享 <strong>Elastic-Job-Lite 作业执行</strong>。</p>
<p>涉及到主要类的类图如下( <a href="http://www.yunai.me/images/Elastic-Job/2017_09_23/01.png">打开大图</a> )：</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_09_23/01.png" alt=""></p>
<ul>
<li><strong>黄色</strong>的类在 <code>elastic-job-common-core</code> 项目里，为 Elastic-Job-Lite、Elastic-Job-Cloud <strong>公用</strong>作业执行类。</li>
</ul>
<blockquote>
<p>你行好事会因为得到赞赏而愉悦<br>
同理，开源项目贡献者会因为 Star 而更加有动力<br>
为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p>
</blockquote>
<h1>2. Lite调度作业</h1>
<p>Lite调度作业( LiteJob )，作业被调度后，调用 <code>#execute()</code> 执行作业。</p>
<p><strong>为什么是 LiteJob 作为入口呢？</strong></p>
<p>在<a href="http://www.yunai.me/Elastic-Job/job-init/?self">《Elastic-Job-Lite 源码分析 —— 作业初始化》的「3.2.3」创建作业调度控制器</a>里，我们可以看到 Quartz 的 JobDetail 创建代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">JobDetail result = JobBuilder.newJob(LiteJob.class).withIdentity(liteJobConfig.getJobName()).build();</div></pre></td></tr></table></figure></p>
<p><code>#newJob()</code> 里的参数是 LiteJob，因此，每次 Quartz 到达调度时间时，会创建该对象进行作业执行。</p>
<hr>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LiteJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Setter</span></div><div class="line">    <span class="keyword">private</span> ElasticJob elasticJob;</div><div class="line">    </div><div class="line">    <span class="meta">@Setter</span></div><div class="line">    <span class="keyword">private</span> JobFacade jobFacade;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</div><div class="line">        JobExecutorFactory.getJobExecutor(elasticJob, jobFacade).execute();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>LiteJob 通过 JobExecutorFactory 获得到作业执行器( AbstractElasticJobExecutor )，并进行执行：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobExecutorFactory</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取作业执行器.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> elasticJob 分布式弹性作业</div><div class="line">     * <span class="doctag">@param</span> jobFacade 作业内部服务门面服务</div><div class="line">     * <span class="doctag">@return</span> 作业执行器</div><div class="line">     */</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractElasticJobExecutor <span class="title">getJobExecutor</span><span class="params">(<span class="keyword">final</span> ElasticJob elasticJob, <span class="keyword">final</span> JobFacade jobFacade)</span> </span>&#123;</div><div class="line">        <span class="comment">// ScriptJob</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == elasticJob) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ScriptJobExecutor(jobFacade);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// SimpleJob</span></div><div class="line">        <span class="keyword">if</span> (elasticJob <span class="keyword">instanceof</span> SimpleJob) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleJobExecutor((SimpleJob) elasticJob, jobFacade);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// DataflowJob</span></div><div class="line">        <span class="keyword">if</span> (elasticJob <span class="keyword">instanceof</span> DataflowJob) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DataflowJobExecutor((DataflowJob) elasticJob, jobFacade);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> JobConfigurationException(<span class="string">"Cannot support job type '%s'"</span>, elasticJob.getClass().getCanonicalName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>JobExecutorFactory，作业执行器工厂，根据不同的作业类型，返回对应的<strong>作业执行器</strong>。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">作业</th>
<th style="text-align:left">作业接口</th>
<th style="text-align:left">执行器</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">简单作业</td>
<td style="text-align:left">SimpleJob</td>
<td style="text-align:left">SimpleJobExecutor</td>
</tr>
<tr>
<td style="text-align:left">数据流作业</td>
<td style="text-align:left">DataflowJob</td>
<td style="text-align:left">DataflowJobExecutor</td>
</tr>
<tr>
<td style="text-align:left">脚本作业</td>
<td style="text-align:left">ScriptJob</td>
<td style="text-align:left">ScriptJobExecutor</td>
</tr>
</tbody>
</table>
<h1>3. 执行器创建</h1>
<p>AbstractElasticJobExecutor，作业执行器抽象类。不同作业执行器都继承该类，创建的过程是一致的。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractElasticJobExecutor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业门面对象</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span>(AccessLevel.PROTECTED)</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobFacade jobFacade;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业配置</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span>(AccessLevel.PROTECTED)</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobRootConfiguration jobRootConfig;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业名称</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String jobName;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业执行线程池</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executorService;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业异常处理器</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobExceptionHandler jobExceptionHandler;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 分片错误信息集合</div><div class="line">     * key：分片序号</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, String&gt; itemErrorMessages;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractElasticJobExecutor</span><span class="params">(<span class="keyword">final</span> JobFacade jobFacade)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.jobFacade = jobFacade;</div><div class="line">        <span class="comment">// 加载 作业配置</span></div><div class="line">        jobRootConfig = jobFacade.loadJobRootConfiguration(<span class="keyword">true</span>);</div><div class="line">        jobName = jobRootConfig.getTypeConfig().getCoreConfig().getJobName();</div><div class="line">        <span class="comment">// 获取 作业执行线程池</span></div><div class="line">        executorService = ExecutorServiceHandlerRegistry.getExecutorServiceHandler(jobName, (ExecutorServiceHandler) getHandler(JobProperties.JobPropertiesEnum.EXECUTOR_SERVICE_HANDLER));</div><div class="line">        <span class="comment">// 获取 作业异常处理器</span></div><div class="line">        jobExceptionHandler = (JobExceptionHandler) getHandler(JobProperties.JobPropertiesEnum.JOB_EXCEPTION_HANDLER);</div><div class="line">        <span class="comment">// 设置 分片错误信息集合</span></div><div class="line">        itemErrorMessages = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(jobRootConfig.getTypeConfig().getCoreConfig().getShardingTotalCount(), <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// SimpleJobExecutor.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleJobExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractElasticJobExecutor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 简单作业实现</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SimpleJob simpleJob;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleJobExecutor</span><span class="params">(<span class="keyword">final</span> SimpleJob simpleJob, <span class="keyword">final</span> JobFacade jobFacade)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(jobFacade);</div><div class="line">        <span class="keyword">this</span>.simpleJob = simpleJob;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// DataflowJobExecutor.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DataflowJobExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractElasticJobExecutor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 数据流作业对象</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DataflowJob&lt;Object&gt; dataflowJob;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DataflowJobExecutor</span><span class="params">(<span class="keyword">final</span> DataflowJob&lt;Object&gt; dataflowJob, <span class="keyword">final</span> JobFacade jobFacade)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(jobFacade);</div><div class="line">        <span class="keyword">this</span>.dataflowJob = dataflowJob;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ScriptJobExecutor.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ScriptJobExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractElasticJobExecutor</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScriptJobExecutor</span><span class="params">(<span class="keyword">final</span> JobFacade jobFacade)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(jobFacade);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>3.1 加载作业配置</h2>
<p>从<strong>缓存</strong>中读取作业配置。在<a href="http://www.yunai.me/Elastic-Job/job-config/?self">《Elastic-Job-Lite 源码分析 —— 作业配置》的「3.1」读取作业配置</a> 已经解析。</p>
<h2>3.2 获取作业执行线程池</h2>
<p>作业每次执行时，可能分配到<strong>多个分片项</strong>，需要使用线程池实现<strong>并行</strong>执行。考虑到不同作业之间的隔离性，通过<strong>一个作业一个线程池</strong>实现。线程池服务处理器注册表( ExecutorServiceHandlerRegistry ) 获取作业线程池( <code>#getExecutorServiceHandler(....)</code> )代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorServiceHandlerRegistry</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 线程池集合</div><div class="line">     * key：作业名字</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, ExecutorService&gt; REGISTRY = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取线程池服务.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> jobName 作业名称</div><div class="line">     * <span class="doctag">@param</span> executorServiceHandler 线程池服务处理器</div><div class="line">     * <span class="doctag">@return</span> 线程池服务</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">getExecutorServiceHandler</span><span class="params">(<span class="keyword">final</span> String jobName, <span class="keyword">final</span> ExecutorServiceHandler executorServiceHandler)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!REGISTRY.containsKey(jobName)) &#123;</div><div class="line">            REGISTRY.put(jobName, executorServiceHandler.createExecutorService(jobName));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> REGISTRY.get(jobName);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ExecutorServiceHandlerRegistry 使用 ExecutorServiceHandler 创建线程池。ExecutorServiceHandler 本身是个<strong>接口</strong>，默认使用 DefaultExecutorServiceHandler 实现：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ExecutorServiceHandler.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorServiceHandler</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建线程池服务对象.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> jobName 作业名</div><div class="line">     * </div><div class="line">     * <span class="doctag">@return</span> 线程池服务对象</div><div class="line">     */</div><div class="line">    <span class="function">ExecutorService <span class="title">createExecutorService</span><span class="params">(<span class="keyword">final</span> String jobName)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// DefaultExecutorServiceHandler.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultExecutorServiceHandler</span> <span class="keyword">implements</span> <span class="title">ExecutorServiceHandler</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">createExecutorService</span><span class="params">(<span class="keyword">final</span> String jobName)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExecutorServiceObject(<span class="string">"inner-job-"</span> + jobName, Runtime.getRuntime().availableProcessors() * <span class="number">2</span>).createExecutorService();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>调用 ExecutorServiceObject 的 <code>#createExecutorService(....)</code> 方法创建线程池：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorServiceObject</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor threadPoolExecutor;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecutorServiceObject</span><span class="params">(<span class="keyword">final</span> String namingPattern, <span class="keyword">final</span> <span class="keyword">int</span> threadSize)</span> </span>&#123;</div><div class="line">        workQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class="line">        threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(threadSize, threadSize, <span class="number">5L</span>, TimeUnit.MINUTES, workQueue, </div><div class="line">                <span class="keyword">new</span> BasicThreadFactory.Builder().namingPattern(Joiner.on(<span class="string">"-"</span>).join(namingPattern, <span class="string">"%s"</span>)).build());</div><div class="line">        threadPoolExecutor.allowCoreThreadTimeOut(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建线程池服务对象.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> 线程池服务对象</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">createExecutorService</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> MoreExecutors.listeningDecorator(MoreExecutors.getExitingExecutorService(threadPoolExecutor));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>MoreExecutors#listeningDecorator(...)</code> 在<a href="http://www.yunai.me/Sharding-JDBC/sql-execute/?self">《Sharding-JDBC 源码分析 —— SQL 执行》</a> 已经解析。</li>
<li><code>MoreExecutors#getExitingExecutorService(...)</code> 方法逻辑：将 ThreadPoolExecutor 转换成 ExecutorService，并增加 JVM 关闭钩子，实现 <strong>120s</strong> 等待任务完成：</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">service.shutdown();</div><div class="line">service.awaitTermination(terminationTimeout, timeUnit);</div></pre></td></tr></table></figure></p>
</li>
</ul>
<p><strong>如何实现自定义 ExecutorServiceHandler ?</strong></p>
<p>先看下 AbstractElasticJobExecutor 是如何获得<strong>每个作业</strong>的 ExecutorServiceHandler ：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 获得【自定义】处理器</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> jobPropertiesEnum 作业属性枚举</div><div class="line">* <span class="doctag">@return</span> 处理器</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getHandler</span><span class="params">(<span class="keyword">final</span> JobProperties.JobPropertiesEnum jobPropertiesEnum)</span> </span>&#123;</div><div class="line">   String handlerClassName = jobRootConfig.getTypeConfig().getCoreConfig().getJobProperties().get(jobPropertiesEnum);</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       Class&lt;?&gt; handlerClass = Class.forName(handlerClassName);</div><div class="line">       <span class="keyword">if</span> (jobPropertiesEnum.getClassType().isAssignableFrom(handlerClass)) &#123; <span class="comment">// 必须是接口实现，才使用【自定义】</span></div><div class="line">           <span class="keyword">return</span> handlerClass.newInstance();</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> getDefaultHandler(jobPropertiesEnum, handlerClassName);</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> ReflectiveOperationException ex) &#123;</div><div class="line">       <span class="keyword">return</span> getDefaultHandler(jobPropertiesEnum, handlerClassName);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 获得【默认】处理器</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> jobPropertiesEnum 作业属性枚举</div><div class="line">* <span class="doctag">@param</span> handlerClassName 处理器类名</div><div class="line">* <span class="doctag">@return</span> 处理器</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getDefaultHandler</span><span class="params">(<span class="keyword">final</span> JobProperties.JobPropertiesEnum jobPropertiesEnum, <span class="keyword">final</span> String handlerClassName)</span> </span>&#123;</div><div class="line">   log.warn(<span class="string">"Cannot instantiation class '&#123;&#125;', use default '&#123;&#125;' class."</span>, handlerClassName, jobPropertiesEnum.getKey());</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">return</span> Class.forName(jobPropertiesEnum.getDefaultValue()).newInstance();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(e);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>每个处理器都会对应一个 JobPropertiesEnum，使用枚举获得处理器。优先从 <code>JobProperties.map</code> 获取<strong>自定义</strong>的处理器实现类，如果不符合条件( 未实现正确接口 或者 创建处理器失败 )，使用<strong>默认</strong>的处理器实现。</li>
<li>每个作业可以配置<strong>不同</strong>的处理器，在<a href="http://www.yunai.me/Elastic-Job/job-config/?self">《Elastic-Job-Lite 源码分析 —— 作业配置》的「2.2.2」作业核心配置</a> 已经解析。</li>
</ul>
<h2>3.3 获取作业异常执行器</h2>
<p>获取作业异常执行器( JobExceptionHandler )和 ExecutorServiceHandler( ExecutorServiceHandler )<strong>相同</strong>。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ExecutorServiceHandler.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JobExceptionHandler</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 处理作业异常.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> jobName 作业名称</div><div class="line">     * <span class="doctag">@param</span> cause 异常原因</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleException</span><span class="params">(String jobName, Throwable cause)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// DefaultJobExceptionHandler.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultJobExceptionHandler</span> <span class="keyword">implements</span> <span class="title">JobExceptionHandler</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleException</span><span class="params">(<span class="keyword">final</span> String jobName, <span class="keyword">final</span> Throwable cause)</span> </span>&#123;</div><div class="line">        log.error(String.format(<span class="string">"Job '%s' exception occur in job processing"</span>, jobName), cause);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>默认实现 DefaultJobExceptionHandler <strong>打印异常日志，不会抛出异常</strong>。</li>
</ul>
<h1>4. 执行器执行</h1>
<p>执行逻辑主流程如下图( <a href="http://www.yunai.me/images/Elastic-Job/2017_09_23/02.png">打开大图</a> )：</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_09_23/02.png" alt=""></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 检查 作业执行环境</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       jobFacade.checkJobExecutionEnvironment();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> JobExecutionEnvironmentException cause) &#123;</div><div class="line">       jobExceptionHandler.handleException(jobName, cause);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 获取 当前作业服务器的分片上下文</span></div><div class="line">   ShardingContexts shardingContexts = jobFacade.getShardingContexts();</div><div class="line">   <span class="comment">// 发布作业状态追踪事件(State.TASK_STAGING)</span></div><div class="line">   <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">       jobFacade.postJobStatusTraceEvent(shardingContexts.getTaskId(), State.TASK_STAGING, String.format(<span class="string">"Job '%s' execute begin."</span>, jobName));</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 跳过 存在运行中的被错过作业</span></div><div class="line">   <span class="keyword">if</span> (jobFacade.misfireIfRunning(shardingContexts.getShardingItemParameters().keySet())) &#123;</div><div class="line">       <span class="comment">// 发布作业状态追踪事件(State.TASK_FINISHED)</span></div><div class="line">       <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">           jobFacade.postJobStatusTraceEvent(shardingContexts.getTaskId(), State.TASK_FINISHED, String.format(</div><div class="line">                   <span class="string">"Previous job '%s' - shardingItems '%s' is still running, misfired job will start after previous job completed."</span>, jobName, </div><div class="line">                   shardingContexts.getShardingItemParameters().keySet()));</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 执行 作业执行前的方法</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       jobFacade.beforeJobExecuted(shardingContexts);</div><div class="line">       <span class="comment">//CHECKSTYLE:OFF</span></div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable cause) &#123;</div><div class="line">       <span class="comment">//CHECKSTYLE:ON</span></div><div class="line">       jobExceptionHandler.handleException(jobName, cause);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 执行 普通触发的作业</span></div><div class="line">   execute(shardingContexts, JobExecutionEvent.ExecutionSource.NORMAL_TRIGGER);</div><div class="line">   <span class="comment">// 执行 被跳过触发的作业</span></div><div class="line">   <span class="keyword">while</span> (jobFacade.isExecuteMisfired(shardingContexts.getShardingItemParameters().keySet())) &#123;</div><div class="line">       jobFacade.clearMisfire(shardingContexts.getShardingItemParameters().keySet());</div><div class="line">       execute(shardingContexts, JobExecutionEvent.ExecutionSource.MISFIRE);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 执行 作业失效转移</span></div><div class="line">   jobFacade.failoverIfNecessary();</div><div class="line">   <span class="comment">// 执行 作业执行后的方法</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       jobFacade.afterJobExecuted(shardingContexts);</div><div class="line">       <span class="comment">//CHECKSTYLE:OFF</span></div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable cause) &#123;</div><div class="line">       <span class="comment">//CHECKSTYLE:ON</span></div><div class="line">       jobExceptionHandler.handleException(jobName, cause);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码步骤比较多，我们一步一步往下看。</p>
<h2>4.1 检查作业执行环境</h2>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkJobExecutionEnvironment</span><span class="params">()</span> <span class="keyword">throws</span> JobExecutionEnvironmentException </span>&#123;</div><div class="line">   configService.checkMaxTimeDiffSecondsTolerable();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>调用 <code>ConfigService#checkMaxTimeDiffSecondsTolerable()</code> 方法校验本机时间是否合法，在<a href="http://www.yunai.me/Elastic-Job/job-config/?self">《Elastic-Job-Lite 源码分析 —— 作业配置》的「3.3」校验本机时间是否合法</a> 已经解析。</li>
<li>当校验本机时间不合法时，抛出异常。若使用 DefaultJobExceptionHandler 作为异常处理，<strong>只打印日志，不会终止作业执行</strong>。如果你的作业对时间精准度有比较高的要求，期望作业<strong>终止</strong>执行，可以自定义 JobExceptionHandler 实现对异常的处理。</li>
</ul>
<h2>4.2 获取当前作业服务器的分片上下文</h2>
<p>调用 <code>LiteJobFacade#getShardingContexts()</code> 方法获取当前作业服务器的分片上下文。通过这个方法，作业获得<strong>其所分配执行的分片项</strong>，在<a href="http://www.yunai.me/Elastic-Job/ob-sharding/?self">《Elastic-Job-Lite 源码解析 —— 作业分片》</a>详细分享。</p>
<h2>4.3 发布作业状态追踪事件</h2>
<p>调用 <code>LiteJobFacade#postJobStatusTraceEvent()</code> 方法发布作业状态追踪事件，在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31_bak.jpg">《Elastic-Job-Lite 源码解析 —— 作业事件与追踪》</a>详细分享。</p>
<h2>4.4 跳过正在运行中的被错过执行的作业</h2>
<p>该逻辑和**「4.7」执行被错过执行的作业**，一起解析，可以整体性的理解 Elastic-Job-Lite 对被错过执行( misfired )的作业处理。</p>
<h2>4.5 执行作业执行前的方法</h2>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeJobExecuted</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (ElasticJobListener each : elasticJobListeners) &#123;</div><div class="line">       each.beforeJobExecuted(shardingContexts);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>调用作业监听器执行作业<strong>执行前</strong>的方法，在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31_bak.jpg">《Elastic-Job-Lite 源码解析 —— 作业监听器》</a>详细分享。</li>
</ul>
<h2>4.6 执行普通触发的作业</h2>
<p>这个小节的标题不太准确，其他<strong>作业来源</strong>( ExecutionSource )也是执行这样的逻辑。本小节执行作业会经历 4 个方法，方法<strong>顺序</strong>往下调用，我们逐个来看。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 执行多个作业的分片</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> shardingContexts 分片上下文集合</div><div class="line">* <span class="doctag">@param</span> executionSource 执行来源</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts, <span class="keyword">final</span> JobExecutionEvent.ExecutionSource executionSource)</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 执行多个作业的分片</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> shardingContexts 分片上下文集合</div><div class="line">* <span class="doctag">@param</span> executionSource 执行来源</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts, <span class="keyword">final</span> JobExecutionEvent.ExecutionSource executionSource)</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 执行单个作业的分片</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> shardingContexts 分片上下文集合</div><div class="line">* <span class="doctag">@param</span> item 分片序号</div><div class="line">* <span class="doctag">@param</span> startEvent 执行事件(开始)</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts, <span class="keyword">final</span> <span class="keyword">int</span> item, <span class="keyword">final</span> JobExecutionEvent startEvent)</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 执行单个作业的分片【子类实现】</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> shardingContext 分片上下文集合</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(ShardingContext shardingContext)</span></span>;</div></pre></td></tr></table></figure></p>
<p>ps：<strong>作业事件</strong>相关逻辑，先统一跳过，在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31_bak.jpg">《Elastic-Job-Lite 源码解析 —— 作业事件与追踪》</a>详细分享。</p>
<hr>
<p><strong>private void execute(shardingContexts, executionSource)</strong></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts, <span class="keyword">final</span> JobExecutionEvent.ExecutionSource executionSource)</span> </span>&#123;</div><div class="line">   <span class="comment">// 无可执行的分片，发布作业状态追踪事件(State.TASK_FINISHED)</span></div><div class="line">   <span class="keyword">if</span> (shardingContexts.getShardingItemParameters().isEmpty()) &#123;</div><div class="line">       <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">           jobFacade.postJobStatusTraceEvent(shardingContexts.getTaskId(), State.TASK_FINISHED, String.format(<span class="string">"Sharding item for job '%s' is empty."</span>, jobName));</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 注册作业启动信息</span></div><div class="line">   jobFacade.registerJobBegin(shardingContexts);</div><div class="line">   <span class="comment">// 发布作业状态追踪事件(State.TASK_RUNNING)</span></div><div class="line">   String taskId = shardingContexts.getTaskId();</div><div class="line">   <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">       jobFacade.postJobStatusTraceEvent(taskId, State.TASK_RUNNING, <span class="string">""</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// TODO</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       process(shardingContexts, executionSource);</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       <span class="comment">// TODO 考虑增加作业失败的状态，并且考虑如何处理作业失败的整体回路</span></div><div class="line">       <span class="comment">// 注册作业完成信息</span></div><div class="line">       jobFacade.registerJobCompleted(shardingContexts);</div><div class="line">       <span class="comment">// 根据是否有异常，发布作业状态追踪事件(State.TASK_FINISHED / State.TASK_ERROR)</span></div><div class="line">       <span class="keyword">if</span> (itemErrorMessages.isEmpty()) &#123;</div><div class="line">           <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">               jobFacade.postJobStatusTraceEvent(taskId, State.TASK_FINISHED, <span class="string">""</span>);</div><div class="line">           &#125;</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">               jobFacade.postJobStatusTraceEvent(taskId, State.TASK_ERROR, itemErrorMessages.toString());</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>方法参数 <code>executionSource</code> 代表执行来源( ExecutionSource )，一共有三种：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ExecutionSource &#123;</div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 普通触发执行</div><div class="line">    */</div><div class="line">   NORMAL_TRIGGER,</div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 被错过执行</div><div class="line">    */</div><div class="line">   MISFIRE,</div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 失效转移执行</div><div class="line">    */</div><div class="line">   FAILOVER</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>调用 <code>LiteJobFacade#registerJobBegin(...)</code> 方法注册作业<strong>启动</strong>信息：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerJobBegin</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts)</span> </span>&#123;</div><div class="line">   executionService.registerJobBegin(shardingContexts);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ExecutionService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerJobBegin</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts)</span> </span>&#123;</div><div class="line">   JobRegistry.getInstance().setJobRunning(jobName, <span class="keyword">true</span>);</div><div class="line">   <span class="keyword">if</span> (!configService.load(<span class="keyword">true</span>).isMonitorExecution()) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> each : shardingContexts.getShardingItemParameters().keySet()) &#123;</div><div class="line">       jobNodeStorage.fillEphemeralJobNode(ShardingNode.getRunningNode(each), <span class="string">""</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>仅当作业配置设置<strong>监控作业运行时状态</strong>( <code>LiteJobConfiguration.monitorExecution = true</code> )时，记录作业运行状态。</li>
<li>调用 <code>JobNodeStorage#fillEphemeralJobNode(...)</code> 方法记录<strong>分配的作业分片项</strong>正在运行中。如何记录的，在<a href="http://www.yunai.me/Elastic-Job/job-storage/?self">《Elastic-Job-Lite 源码解析 —— 作业数据存储》</a>详细分享。</li>
</ul>
</li>
<li>
<p>调用 <code>LiteJobFacade#registerJobCompleted(...)</code> 方法注册作业<strong>完成</strong>信息：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerJobCompleted</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts)</span> </span>&#123;</div><div class="line">   executionService.registerJobCompleted(shardingContexts);</div><div class="line">   <span class="keyword">if</span> (configService.load(<span class="keyword">true</span>).isFailover()) &#123;</div><div class="line">       failoverService.updateFailoverComplete(shardingContexts.getShardingItemParameters().keySet());</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ExecutionService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 注册作业完成信息.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> shardingContexts 分片上下文</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerJobCompleted</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts)</span> </span>&#123;</div><div class="line">   JobRegistry.getInstance().setJobRunning(jobName, <span class="keyword">false</span>);</div><div class="line">   <span class="keyword">if</span> (!configService.load(<span class="keyword">true</span>).isMonitorExecution()) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> each : shardingContexts.getShardingItemParameters().keySet()) &#123;</div><div class="line">       jobNodeStorage.removeJobNodeIfExisted(ShardingNode.getRunningNode(each));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>仅当作业配置设置<strong>监控作业运行时状态</strong>( <code>LiteJobConfiguration.monitorExecution = true</code> )，移除作业运行状态。</li>
<li>调用 <code>JobNodeStorage#removeJobNodeIfExisted(...)</code> 方法<strong>移除分配的作业分片项</strong>正在运行中的标记，表示作业分片项不在运行中状态。</li>
<li>调用 <code>FailoverService#updateFailoverComplete(...)</code> 方法更新执行完毕失效转移的分片项状态，在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31_bak.jpg">《Elastic-Job-Lite 源码解析 —— 作业失效转移》</a>详细分享。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>private void process(shardingContexts, executionSource)</strong></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts, <span class="keyword">final</span> JobExecutionEvent.ExecutionSource executionSource)</span> </span>&#123;</div><div class="line">   Collection&lt;Integer&gt; items = shardingContexts.getShardingItemParameters().keySet();</div><div class="line">   <span class="comment">// 单分片，直接执行</span></div><div class="line">   <span class="keyword">if</span> (<span class="number">1</span> == items.size()) &#123;</div><div class="line">       <span class="keyword">int</span> item = shardingContexts.getShardingItemParameters().keySet().iterator().next();</div><div class="line">       JobExecutionEvent jobExecutionEvent =  <span class="keyword">new</span> JobExecutionEvent(shardingContexts.getTaskId(), jobName, executionSource, item);</div><div class="line">       <span class="comment">// 执行一个作业</span></div><div class="line">       process(shardingContexts, item, jobExecutionEvent);</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 多分片，并行执行</span></div><div class="line">   <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(items.size());</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">final</span> <span class="keyword">int</span> each : items) &#123;</div><div class="line">       <span class="keyword">final</span> JobExecutionEvent jobExecutionEvent = <span class="keyword">new</span> JobExecutionEvent(shardingContexts.getTaskId(), jobName, executionSource, each);</div><div class="line">       <span class="keyword">if</span> (executorService.isShutdown()) &#123;</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line">       executorService.submit(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">           </div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                   <span class="comment">// 执行一个作业</span></div><div class="line">                   process(shardingContexts, each, jobExecutionEvent);</div><div class="line">               &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                   latch.countDown();</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 等待多分片全部完成</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       latch.await();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> InterruptedException ex) &#123;</div><div class="line">       Thread.currentThread().interrupt();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>分配<strong>单</strong>分片项时，直接执行，无需使用线程池，性能更优。</li>
<li>分配<strong>多</strong>分片项时，使用线程池<strong>并发</strong>执行，通过 CountDownLatch 实现等待分片项全部执行完成。</li>
</ul>
<hr>
<p><strong>private void process(shardingContexts, item, startEvent)</strong><br>
<strong>protected abstract void process(shardingContext)</strong></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts, <span class="keyword">final</span> <span class="keyword">int</span> item, <span class="keyword">final</span> JobExecutionEvent startEvent)</span> </span>&#123;</div><div class="line">   <span class="comment">// 发布执行事件(开始)</span></div><div class="line">   <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">       jobFacade.postJobExecutionEvent(startEvent);</div><div class="line">   &#125;</div><div class="line">   log.trace(<span class="string">"Job '&#123;&#125;' executing, item is: '&#123;&#125;'."</span>, jobName, item);</div><div class="line">   JobExecutionEvent completeEvent;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 执行单个作业</span></div><div class="line">       process(<span class="keyword">new</span> ShardingContext(shardingContexts, item));</div><div class="line">       <span class="comment">// 发布执行事件(成功)</span></div><div class="line">       completeEvent = startEvent.executionSuccess();</div><div class="line">       log.trace(<span class="string">"Job '&#123;&#125;' executed, item is: '&#123;&#125;'."</span>, jobName, item);</div><div class="line">       <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">           jobFacade.postJobExecutionEvent(completeEvent);</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// CHECKSTYLE:OFF</span></div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable cause) &#123;</div><div class="line">       <span class="comment">// CHECKSTYLE:ON</span></div><div class="line">       <span class="comment">// 发布执行事件(失败)</span></div><div class="line">       completeEvent = startEvent.executionFailure(cause);</div><div class="line">       jobFacade.postJobExecutionEvent(completeEvent);</div><div class="line">       <span class="comment">// 设置该分片执行异常信息</span></div><div class="line">       itemErrorMessages.put(item, ExceptionUtil.transform(cause));</div><div class="line">       <span class="comment">//</span></div><div class="line">       jobExceptionHandler.handleException(jobName, cause);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(ShardingContext shardingContext)</span></span>;</div></pre></td></tr></table></figure></p>
<ul>
<li>不同作业执行器实现类通过实现 <code>#process(shardingContext)</code> 抽象方法，实现对<strong>单个分片项</strong>作业的处理。</li>
<li>不同作业执行器实现类通过实现 <code>#process(shardingContext)</code> 抽象方法，实现对<strong>单个分片项</strong>作业的处理。</li>
<li>不同作业执行器实现类通过实现 <code>#process(shardingContext)</code> 抽象方法，实现对<strong>单个分片项</strong>作业的处理。</li>
</ul>
<h3>4.6.1 简单作业执行器</h3>
<p>SimpleJobExecutor，简单作业执行器</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleJobExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractElasticJobExecutor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 简单作业实现</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SimpleJob simpleJob;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext)</span> </span>&#123;</div><div class="line">        simpleJob.execute(shardingContext);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>调用 <code>SimpleJob#execute()</code> 方法对单个分片项作业进行处理。</li>
</ul>
<h3>4.6.2 数据流作业执行器</h3>
<p>DataflowJobExecutor，数据流作业执行器。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DataflowJobExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractElasticJobExecutor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 数据流作业对象</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DataflowJob&lt;Object&gt; dataflowJob;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext)</span> </span>&#123;</div><div class="line">        DataflowJobConfiguration dataflowConfig = (DataflowJobConfiguration) getJobRootConfig().getTypeConfig();</div><div class="line">        <span class="keyword">if</span> (dataflowConfig.isStreamingProcess()) &#123; <span class="comment">// 流式处理数据</span></div><div class="line">            streamingExecute(shardingContext);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            oneOffExecute(shardingContext);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 流式处理</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> shardingContext 分片上下文</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">streamingExecute</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext)</span> </span>&#123;</div><div class="line">        List&lt;Object&gt; data = fetchData(shardingContext);</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != data &amp;&amp; !data.isEmpty()) &#123;</div><div class="line">            processData(shardingContext, data);</div><div class="line">            <span class="keyword">if</span> (!getJobFacade().isEligibleForJobRunning()) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            data = fetchData(shardingContext);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 一次处理</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> shardingContext 分片上下文</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">oneOffExecute</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext)</span> </span>&#123;</div><div class="line">        List&lt;Object&gt; data = fetchData(shardingContext);</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != data &amp;&amp; !data.isEmpty()) &#123;</div><div class="line">            processData(shardingContext, data);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>当作业配置设置流式处理数据( <code>DataflowJobConfiguration.streamingProcess = true</code> ) 时，调用 <code>#streamingExecute()</code> <strong>不断</strong>加载数据，<strong>不断</strong>处理数据，直到<strong>数据为空</strong> 或者 <strong>作业不适合继续运行</strong>：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEligibleForJobRunning</span><span class="params">()</span> </span>&#123;</div><div class="line">   LiteJobConfiguration liteJobConfig = configService.load(<span class="keyword">true</span>);</div><div class="line">   <span class="keyword">if</span> (liteJobConfig.getTypeConfig() <span class="keyword">instanceof</span> DataflowJobConfiguration) &#123;</div><div class="line">       <span class="keyword">return</span> !shardingService.isNeedSharding() <span class="comment">// 作业不需要重新分片</span></div><div class="line">               &amp;&amp; ((DataflowJobConfiguration) liteJobConfig.getTypeConfig()).isStreamingProcess();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> !shardingService.isNeedSharding(); <span class="comment">// 作业不需要重新分片</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>作业需要重新分片，所以不适合继续流式数据处理。</li>
</ul>
<blockquote>
<p>如果采用流式作业处理方式，建议processData处理数据后更新其状态，避免fetchData再次抓取到，从而使得作业永不停止。 流式数据处理参照TbSchedule设计，适用于不间歇的数据处理。</p>
</blockquote>
</li>
<li>
<p>当作业配置<strong>不</strong>设置流式处理数据( <code>DataflowJobConfiguration.streamingProcess = false</code> ) 时，调用 <code>#oneOffExecute()</code> <strong>一次</strong>加载数据，<strong>一次</strong>处理数据。</p>
</li>
<li>
<p>调用 <code>#fetchData()</code> 方法加载数据；调用 <code>#processData(...)</code> 方法处理数据：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DataflowJobExecutor.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 加载数据</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> shardingContext 分片上下文</div><div class="line">* <span class="doctag">@return</span> 数据</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> List&lt;Object&gt; <span class="title">fetchData</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> dataflowJob.fetchData(shardingContext);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 处理数据</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> shardingContext 分片上下文</div><div class="line">* <span class="doctag">@param</span> data 数据</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processData</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext, <span class="keyword">final</span> List&lt;Object&gt; data)</span> </span>&#123;</div><div class="line">   dataflowJob.processData(shardingContext, data);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
</ul>
<h3>4.6.3 脚本作业执行器</h3>
<p>ScriptJobExecutor，脚本作业执行器。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ScriptJobExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractElasticJobExecutor</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> String scriptCommandLine = ((ScriptJobConfiguration) getJobRootConfig().getTypeConfig()).getScriptCommandLine();</div><div class="line">        <span class="keyword">if</span> (Strings.isNullOrEmpty(scriptCommandLine)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JobConfigurationException(<span class="string">"Cannot find script command line for job '%s', job is not executed."</span>, shardingContext.getJobName());</div><div class="line">        &#125;</div><div class="line">        executeScript(shardingContext, scriptCommandLine);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 执行脚本</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> shardingContext 分片上下文</div><div class="line">     * <span class="doctag">@param</span> scriptCommandLine 执行脚本路径</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeScript</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext, <span class="keyword">final</span> String scriptCommandLine)</span> </span>&#123;</div><div class="line">        CommandLine commandLine = CommandLine.parse(scriptCommandLine);</div><div class="line">        <span class="comment">// JSON 格式传递参数</span></div><div class="line">        commandLine.addArgument(GsonFactory.getGson().toJson(shardingContext), <span class="keyword">false</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">new</span> DefaultExecutor().execute(commandLine);</div><div class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IOException ex) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JobConfigurationException(<span class="string">"Execute script failure."</span>, ex);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p><code>scriptCommandLine</code> 传递的是<strong>脚本路径</strong>。使用 <a href="https://commons.apache.org/proper/commons-exec/" rel="external nofollow noopener noreferrer" target="_blank">Apache Commons Exec</a> 工具包实现脚本调用：</p>
<blockquote>
<p>Script类型作业意为脚本类型作业，支持shell，python，perl等所有类型脚本。只需通过控制台或代码配置scriptCommandLine即可，无需编码。执行脚本路径可包含参数，参数传递完毕后，作业框架会自动追加最后一个参数为作业运行时信息。</p>
</blockquote>
</li>
<li>
<p>脚本参数传递使用 JSON 格式。</p>
</li>
</ul>
<h2>4.7 执行被错过触发的作业</h2>
<p>当作业执行过久，导致到达下次执行时间未进行下一次作业执行，Elastic-Job-Lite 会设置该作业分片项为被错过执行( misfired )。下一次作业执行时，会<strong>补充</strong>执行被错过执行的作业分片项。</p>
<p><strong>标记作业被错过执行</strong></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobScheduler.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> Scheduler <span class="title">createScheduler</span><span class="params">()</span> </span>&#123;</div><div class="line">   Scheduler result;</div><div class="line">   <span class="comment">// 省略部分代码</span></div><div class="line">   result.getListenerManager().addTriggerListener(schedulerFacade.newJobTriggerListener());</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> Properties <span class="title">getBaseQuartzProperties</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 省略部分代码</span></div><div class="line">   result.put(<span class="string">"org.quartz.jobStore.misfireThreshold"</span>, <span class="string">"1"</span>);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// JobScheduleController.class</span></div><div class="line"><span class="function"><span class="keyword">private</span> CronTrigger <span class="title">createTrigger</span><span class="params">(<span class="keyword">final</span> String cron)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> TriggerBuilder.newTrigger()</div><div class="line">           .withIdentity(triggerIdentity)</div><div class="line">           .withSchedule(CronScheduleBuilder.cronSchedule(cron)</div><div class="line">           .withMisfireHandlingInstructionDoNothing())</div><div class="line">           .build();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p><code>org.quartz.jobStore.misfireThreshold</code> 设置超过 1 毫秒，作业分片项即被视为错过执行。</p>
</li>
<li>
<p><code>#withMisfireHandlingInstructionDoNothing()</code> 设置 Quartz 系统不会立刻再执行任务，而是等到距离目前时间最近的预计时间执行。<strong>重新执行被错过执行的作业交给 Elastic-Job-Lite 处理</strong>。</p>
</li>
<li>
<p>使用 TriggerListener 监听被错过执行的作业分片项：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobTriggerListener.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobTriggerListener</span> <span class="keyword">extends</span> <span class="title">TriggerListenerSupport</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">triggerMisfired</span><span class="params">(<span class="keyword">final</span> Trigger trigger)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != trigger.getPreviousFireTime()) &#123;</div><div class="line">            executionService.setMisfire(shardingService.getLocalShardingItems());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ExecutionService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMisfire</span><span class="params">(<span class="keyword">final</span> Collection&lt;Integer&gt; items)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> each : items) &#123;</div><div class="line">       jobNodeStorage.createJobNodeIfNeeded(ShardingNode.getMisfireNode(each));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>调用 <code>#setMisfire(...)</code> 设置作业分片项被错过执行。</li>
</ul>
</li>
</ul>
<p><strong>跳过正在运行中的被错过执行的作业</strong></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">misfireIfRunning</span><span class="params">(<span class="keyword">final</span> Collection&lt;Integer&gt; shardingItems)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> executionService.misfireIfHasRunningItems(shardingItems);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ExecutionService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">misfireIfHasRunningItems</span><span class="params">(<span class="keyword">final</span> Collection&lt;Integer&gt; items)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (!hasRunningItems(items)) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">   setMisfire(items);</div><div class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasRunningItems</span><span class="params">(<span class="keyword">final</span> Collection&lt;Integer&gt; items)</span> </span>&#123;</div><div class="line">   LiteJobConfiguration jobConfig = configService.load(<span class="keyword">true</span>);</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> == jobConfig || !jobConfig.isMonitorExecution()) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> each : items) &#123;</div><div class="line">       <span class="keyword">if</span> (jobNodeStorage.isJobNodeExisted(ShardingNode.getRunningNode(each))) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>当分配的作业分片项里存在<strong>任意一个分片正在运行</strong>中，设置分片项<strong>都</strong>被错过执行( <code>misfired</code> )，并不执行这些作业分片。如果不进行跳过，则可能导致<strong>同时</strong>运行某个作业分片。</li>
<li>该功能依赖作业配置<strong>监控作业运行时状态</strong>( <code>LiteJobConfiguration.monitorExecution = true</code> )时生效。</li>
</ul>
<p><strong>执行被错过执行的作业分片项</strong></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// .... 省略部分代码</span></div><div class="line">   <span class="comment">// 执行 被跳过触发的作业</span></div><div class="line">   <span class="keyword">while</span> (jobFacade.isExecuteMisfired(shardingContexts.getShardingItemParameters().keySet())) &#123;</div><div class="line">       jobFacade.clearMisfire(shardingContexts.getShardingItemParameters().keySet());</div><div class="line">       execute(shardingContexts, JobExecutionEvent.ExecutionSource.MISFIRE);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// .... 省略部分代码</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExecuteMisfired</span><span class="params">(<span class="keyword">final</span> Collection&lt;Integer&gt; shardingItems)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> isEligibleForJobRunning() <span class="comment">// 合适继续运行</span></div><div class="line">           &amp;&amp; configService.load(<span class="keyword">true</span>).getTypeConfig().getCoreConfig().isMisfire() <span class="comment">// 作业配置开启作业被错过触发</span></div><div class="line">           &amp;&amp; !executionService.getMisfiredJobItems(shardingItems).isEmpty(); <span class="comment">// 所执行的作业分片存在被错过( misfired )</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearMisfire</span><span class="params">(<span class="keyword">final</span> Collection&lt;Integer&gt; shardingItems)</span> </span>&#123;</div><div class="line">   executionService.clearMisfire(shardingItems);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>清除分配的作业分片项被错过执行的标识，并执行作业分片项。</li>
<li>为什么此处使用 <strong>while(...)</strong>？<strong>防御性编程</strong>，<code>#isExecuteMisfired(...)</code> 判断使用<strong>内存缓存</strong>的数据，而该数据的更新依赖 Zookeeper 通知进行<strong>异步</strong>更新，可能因为各种情况，例如网络，数据可能未及时更新导致<strong>数据不一致</strong>。使用 <strong>while(...)</strong> 进行防御编程，保证<strong>内存缓存</strong>的数据已经更新。</li>
</ul>
<h2>4.8 执行作业失效转移</h2>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failoverIfNecessary</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (configService.load(<span class="keyword">true</span>).isFailover()) &#123;</div><div class="line">       failoverService.failoverIfNecessary();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>调用作业失效转移服务( FailoverService )执行作业失效转移( <code>#failoverIfNecessary()</code> )，在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31_bak.jpg">《Elastic-Job-Lite 源码解析 —— 作业失效转移》</a>详细分享。</li>
</ul>
<h2>4.9 执行作业执行后的方法</h2>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterJobExecuted</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (ElasticJobListener each : elasticJobListeners) &#123;</div><div class="line">       each.afterJobExecuted(shardingContexts);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>调用作业监听器执行作业<strong>执行后</strong>的方法，在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31_bak.jpg">《Elastic-Job-Lite 源码解析 —— 作业监听器》</a>详细分享。</li>
</ul>
<h1>666. 彩蛋</h1>
<p>呼！略长略长略长！</p>
<p>下面会更新如下两篇文章，为后续的主节点选举、失效转移、作业分片策略等文章做铺垫：</p>
<ul>
<li><a href="http://www.yunai.me/Elastic-Job/reg-center-zookeeper/?self">《Elastic-Job-Lite 源码解析 —— 注册中心》</a></li>
<li><a href="http://www.yunai.me/Elastic-Job/job-storage/?self">《Elastic-Job-Lite 源码解析 —— 作业数据存储》</a></li>
</ul>
<p>道友，赶紧上车，分享一波朋友圈！</p>
<p>啊啊啊，我好想马上拜读 Elastic-Job-Cloud。为了你们，我忍住了心碎。</p>
<p>旁白君：煞笔笔者已经偷偷在读了。<br>
芋道君：旁白君，你大爷！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-%E6%A6%82%E8%BF%B0&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-lite%E8%B0%83%E
    
    </summary>
    
      <category term="Elastic-Job" scheme="http://www.yunai.me/categories/Elastic-Job/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Lite 源码分析 —— 作业初始化</title>
    <link href="http://www.yunai.me/Elastic-Job/job-init/"/>
    <id>http://www.yunai.me/Elastic-Job/job-init/</id>
    <published>2017-09-15T16:00:00.000Z</published>
    <updated>2017-08-25T07:49:27.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. 作业注册表</a></li>
<li><a href="#">3. 作业调度器</a>
<ul>
<li><a href="#">3.1 创建</a></li>
<li><a href="#">3.2 初始化</a>
<ul>
<li><a href="#">3.2.1 更新作业配置</a></li>
<li><a href="#">3.2.2 设置当前作业分片总数</a></li>
<li><a href="#">3.2.3 创建作业调度控制器</a></li>
<li><a href="#">3.2.4 注册作业启动信息</a></li>
<li><a href="#">3.2.5 调度作业</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<h1>1. 概述</h1>
<p>本文主要分享 <strong>Elastic-Job-Lite 作业初始化</strong>。</p>
<p>涉及到主要类的类图如下( <a href="http://www.yunai.me/images/Elastic-Job/2017_09_09/16.png">打开大图</a> )：</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_09_16/01.png" alt=""></p>
<blockquote>
<p>你行好事会因为得到赞赏而愉悦<br>
同理，开源项目贡献者会因为 Star 而更加有动力<br>
为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p>
</blockquote>
<h1>2. 作业注册表</h1>
<p>作业注册表( JobRegistry )，维护了单个 Elastic-Job-Lite <strong>进程内</strong>作业相关信息，可以理解成其专属的 Spring IOC 容器。因此，其本身是一个<strong>单例</strong>。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobRegistry</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 单例</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> JobRegistry instance;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业调度控制器集合</div><div class="line">     * key：作业名称</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Map&lt;String, JobScheduleController&gt; schedulerMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 注册中心集合</div><div class="line">     * key：作业名称</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Map&lt;String, CoordinatorRegistryCenter&gt; regCenterMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业运行实例集合</div><div class="line">     * key：作业名称</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Map&lt;String, JobInstance&gt; jobInstanceMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 运行中作业集合</div><div class="line">     * key：作业名字</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Map&lt;String, Boolean&gt; jobRunningMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业总分片数量集合</div><div class="line">     * key：作业名字</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; currentShardingTotalCountMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取作业注册表实例.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@return</span> 作业注册表实例</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JobRegistry <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (JobRegistry.class) &#123;</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</div><div class="line">                    instance = <span class="keyword">new</span> JobRegistry();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// .... 省略方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>instance</code> 是一个单例，通过 <code>#getInstance()</code> 方法获取该单例。该单例的创建方式为**<a href="http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/#%E5%8F%8C%E9%87%8D%E6%A3%80%E9%AA%8C%E9%94%81" rel="external nofollow noopener noreferrer" target="_blank">双重检验锁模式</a>**。</li>
<li>Map集合属性<strong>全部</strong>以<strong>作业名称</strong>作为 KEY，通过作业名称，可以获得作业相关信息。</li>
<li>省略的方法，下文在实际调用时，进行解析。</li>
</ul>
<h1>3. 作业调度器</h1>
<p>作业调度器( JobScheduler )，创建并初始化后，进行作业调度。</p>
<p><strong>Elastic-Job-Lite 使用 Quartz 作为调度内核。</strong></p>
<h2>3.1 创建</h2>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobScheduler</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Lite作业配置</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LiteJobConfiguration liteJobConfig;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 注册中心</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CoordinatorRegistryCenter regCenter;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 调度器门面对象</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SchedulerFacade schedulerFacade;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业门面对象</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobFacade jobFacade;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JobScheduler</span><span class="params">(<span class="keyword">final</span> CoordinatorRegistryCenter regCenter, <span class="keyword">final</span> LiteJobConfiguration liteJobConfig, <span class="keyword">final</span> ElasticJobListener... elasticJobListeners)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(regCenter, liteJobConfig, <span class="keyword">new</span> JobEventBus(), elasticJobListeners);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JobScheduler</span><span class="params">(<span class="keyword">final</span> CoordinatorRegistryCenter regCenter, <span class="keyword">final</span> LiteJobConfiguration liteJobConfig, <span class="keyword">final</span> JobEventConfiguration jobEventConfig, </span></span></div><div class="line">                        <span class="keyword">final</span> ElasticJobListener... elasticJobListeners) &#123;</div><div class="line">        <span class="keyword">this</span>(regCenter, liteJobConfig, <span class="keyword">new</span> JobEventBus(jobEventConfig), elasticJobListeners);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JobScheduler</span><span class="params">(<span class="keyword">final</span> CoordinatorRegistryCenter regCenter, <span class="keyword">final</span> LiteJobConfiguration liteJobConfig, <span class="keyword">final</span> JobEventBus jobEventBus, <span class="keyword">final</span> ElasticJobListener... elasticJobListeners)</span> </span>&#123;</div><div class="line">        <span class="comment">// 添加 作业运行实例</span></div><div class="line">        JobRegistry.getInstance().addJobInstance(liteJobConfig.getJobName(), <span class="keyword">new</span> JobInstance());</div><div class="line">        <span class="comment">// 设置 Lite作业配置</span></div><div class="line">        <span class="keyword">this</span>.liteJobConfig = liteJobConfig;</div><div class="line">        <span class="keyword">this</span>.regCenter = regCenter;</div><div class="line">        <span class="comment">// 设置 作业监听器</span></div><div class="line">        List&lt;ElasticJobListener&gt; elasticJobListenerList = Arrays.asList(elasticJobListeners);</div><div class="line">        setGuaranteeServiceForElasticJobListeners(regCenter, elasticJobListenerList);</div><div class="line">        <span class="comment">// 设置 调度器门面对象</span></div><div class="line">        schedulerFacade = <span class="keyword">new</span> SchedulerFacade(regCenter, liteJobConfig.getJobName(), elasticJobListenerList);</div><div class="line">        <span class="comment">// 设置 作业门面对象</span></div><div class="line">        jobFacade = <span class="keyword">new</span> LiteJobFacade(regCenter, liteJobConfig.getJobName(), Arrays.asList(elasticJobListeners), jobEventBus);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>调用 <code>#JobRegistry#addJobInstance()</code> 方法添<strong>加作业运行实例( JobInstance )</strong>。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobRegistry.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 作业运行实例集合</div><div class="line">* key：作业名称</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> Map&lt;String, JobInstance&gt; jobInstanceMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line"><span class="comment">/**</span></div><div class="line">* 添加作业实例.</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> jobName 作业名称</div><div class="line">* <span class="doctag">@param</span> jobInstance 作业实例</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addJobInstance</span><span class="params">(<span class="keyword">final</span> String jobName, <span class="keyword">final</span> JobInstance jobInstance)</span> </span>&#123;</div><div class="line">   jobInstanceMap.put(jobName, jobInstance);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// JobInstance.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobInstance</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELIMITER = <span class="string">"@-@"</span>;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业实例主键.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String jobInstanceId;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JobInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        jobInstanceId = IpUtils.getIp()</div><div class="line">                + DELIMITER</div><div class="line">                + ManagementFactory.getRuntimeMXBean().getName().split(<span class="string">"@"</span>)[<span class="number">0</span>]; <span class="comment">// PID</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>jobInstanceId</code> 格式：<code>${IP}@-@${PID}</code>。其中 <code>PID</code> 为进程编号。同一个 Elastic-Job-Lite 实例，<strong>不同</strong>的作业使用<strong>相同</strong>的作业实例主键。</li>
</ul>
</li>
<li>
<p>设置作业监听器，在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31_bak.jpg">《Elastic-Job-Lite 源码解析 —— 作业监听器》</a>详细分享。</p>
</li>
<li>
<p>SchedulerFacade，为<strong>调度器</strong>提供内部服务的门面类。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulerFacade</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业名称</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String jobName;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业配置服务</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConfigurationService configService;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业分片服务</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ShardingService shardingService;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 主节点服务</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LeaderService leaderService;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业服务器服务</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerService serverService;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业运行实例服务</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InstanceService instanceService;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 执行作业服务</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutionService executionService;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业监控服务</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MonitorService monitorService;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 调解作业不一致状态服务</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReconcileService reconcileService;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业注册中心的监听器管理者</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> ListenerManager listenerManager;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SchedulerFacade</span><span class="params">(<span class="keyword">final</span> CoordinatorRegistryCenter regCenter, <span class="keyword">final</span> String jobName, <span class="keyword">final</span> List&lt;ElasticJobListener&gt; elasticJobListeners)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.jobName = jobName;</div><div class="line">        <span class="comment">// .... 省略 new XXXXX() 对象</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>LiteJobFacade，为<strong>作业</strong>提供内部服务的门面类。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LiteJobFacade</span> <span class="keyword">implements</span> <span class="title">JobFacade</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业配置服务</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConfigurationService configService;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业分片服务</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ShardingService shardingService;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 执行作业服务</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutionService executionService;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业运行时上下文服务</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutionContextService executionContextService;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业失效转移服务</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FailoverService failoverService;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业监听器数组</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ElasticJobListener&gt; elasticJobListeners;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业事件总线</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobEventBus jobEventBus;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LiteJobFacade</span><span class="params">(<span class="keyword">final</span> CoordinatorRegistryCenter regCenter, <span class="keyword">final</span> String jobName, <span class="keyword">final</span> List&lt;ElasticJobListener&gt; elasticJobListeners, <span class="keyword">final</span> JobEventBus jobEventBus)</span> </span>&#123;</div><div class="line">        <span class="comment">// .... 省略 new XXXXX() 对象</span></div><div class="line">        failoverService = <span class="keyword">new</span> FailoverService(regCenter, jobName);</div><div class="line">        <span class="keyword">this</span>.elasticJobListeners = elasticJobListeners;</div><div class="line">        <span class="keyword">this</span>.jobEventBus = jobEventBus;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
</ul>
<p>SchedulerFacade 和 LiteJobFacade，看起来很相近，实际差别很大。它们分别为调度器、作业提供需要的方法。下文也会体现这一特点。</p>
<h2>3.2 初始化</h2>
<p>作业调度器创建后，调用 <code>#init()</code> 方法初始化，作业方<strong>开始</strong>调度。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 初始化作业.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 更新 作业配置</span></div><div class="line">   LiteJobConfiguration liteJobConfigFromRegCenter = schedulerFacade.updateJobConfiguration(liteJobConfig);</div><div class="line">   <span class="comment">// 设置 当前作业分片总数</span></div><div class="line">   JobRegistry.getInstance().setCurrentShardingTotalCount(liteJobConfigFromRegCenter.getJobName(), liteJobConfigFromRegCenter.getTypeConfig().getCoreConfig().getShardingTotalCount());</div><div class="line">   <span class="comment">// 创建 作业调度控制器</span></div><div class="line">   JobScheduleController jobScheduleController = <span class="keyword">new</span> JobScheduleController(</div><div class="line">           createScheduler(), createJobDetail(liteJobConfigFromRegCenter.getTypeConfig().getJobClass()), liteJobConfigFromRegCenter.getJobName());</div><div class="line">   <span class="comment">// 添加 作业调度控制器</span></div><div class="line">   JobRegistry.getInstance().registerJob(liteJobConfigFromRegCenter.getJobName(), jobScheduleController, regCenter);</div><div class="line">   <span class="comment">// 注册 作业启动信息</span></div><div class="line">   schedulerFacade.registerStartUpInfo(!liteJobConfigFromRegCenter.isDisabled());</div><div class="line">   <span class="comment">// 调度作业</span></div><div class="line">   jobScheduleController.scheduleJob(liteJobConfigFromRegCenter.getTypeConfig().getCoreConfig().getCron());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3>3.2.1 更新作业配置</h3>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SchedulerFacade.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 更新作业配置.</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> liteJobConfig 作业配置</div><div class="line">* <span class="doctag">@return</span> 更新后的作业配置</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> LiteJobConfiguration <span class="title">updateJobConfiguration</span><span class="params">(<span class="keyword">final</span> LiteJobConfiguration liteJobConfig)</span> </span>&#123;</div><div class="line">   <span class="comment">// 更新 作业配置</span></div><div class="line">   configService.persist(liteJobConfig);</div><div class="line">   <span class="comment">// 读取 作业配置</span></div><div class="line">   <span class="keyword">return</span> configService.load(<span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>从<a href="http://www.yunai.me/Elastic-Job/job-config/?self">《Elastic-Job 源码分析 —— 作业配置》</a>的「3.2 持久化作业配置」，调用 <code>ConfigService#persist(...)</code> 方法也不一定会更新作业配置，因此调用 <code>ConfigService#load(...)</code> 方法返回的可能是本地的作业配置，也可能是<strong>注册中心</strong>存储的作业配置。</li>
</ul>
<h3>3.2.2 设置当前作业分片总数</h3>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobRegistry.java</span></div><div class="line"><span class="keyword">private</span> Map&lt;String, Integer&gt; currentShardingTotalCountMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line"><span class="comment">/**</span></div><div class="line">* 设置当前分片总数.</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> jobName 作业名称</div><div class="line">* <span class="doctag">@param</span> currentShardingTotalCount 当前分片总数</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrentShardingTotalCount</span><span class="params">(<span class="keyword">final</span> String jobName, <span class="keyword">final</span> <span class="keyword">int</span> currentShardingTotalCount)</span> </span>&#123;</div><div class="line">   currentShardingTotalCountMap.put(jobName, currentShardingTotalCount);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3>3.2.3 创建作业调度控制器</h3>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// .... 省略</span></div><div class="line">   <span class="comment">// 创建 作业调度控制器</span></div><div class="line">   JobScheduleController jobScheduleController = <span class="keyword">new</span> JobScheduleController(</div><div class="line">           createScheduler(), createJobDetail(liteJobConfigFromRegCenter.getTypeConfig().getJobClass()), liteJobConfigFromRegCenter.getJobName());</div><div class="line">   <span class="comment">// .... 省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>JobScheduleController，作业调度控制器，提供对 Quartz 方法的封装：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobScheduleController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Quartz 调度器</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Scheduler scheduler;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业信息</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobDetail jobDetail;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 触发器编号</div><div class="line">     * 目前使用工作名字( jobName )</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String triggerIdentity;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleJob</span><span class="params">(<span class="keyword">final</span> String cron)</span> </span>&#123;&#125; <span class="comment">// 调度作业</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">rescheduleJob</span><span class="params">(<span class="keyword">final</span> String cron)</span> </span>&#123;&#125; <span class="comment">// 重新调度作业</span></div><div class="line">    <span class="function"><span class="keyword">private</span> CronTrigger <span class="title">createTrigger</span><span class="params">(<span class="keyword">final</span> String cron)</span> </span>&#123;&#125; <span class="comment">// 创建触发器</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">isPaused</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 判断作业是否暂停</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">pauseJob</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 暂停作业</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">resumeJob</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 恢复作业</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">triggerJob</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 立刻启动作业</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 关闭调度器</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>调用 <code>#createScheduler()</code> 方法创建 Quartz 调度器：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobScheduler.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> Scheduler <span class="title">createScheduler</span><span class="params">()</span> </span>&#123;</div><div class="line">   Scheduler result;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       StdSchedulerFactory factory = <span class="keyword">new</span> StdSchedulerFactory();</div><div class="line">       factory.initialize(getBaseQuartzProperties());</div><div class="line">       result = factory.getScheduler();</div><div class="line">       result.getListenerManager().addTriggerListener(schedulerFacade.newJobTriggerListener());</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SchedulerException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(ex);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> Properties <span class="title">getBaseQuartzProperties</span><span class="params">()</span> </span>&#123;</div><div class="line">   Properties result = <span class="keyword">new</span> Properties();</div><div class="line">   result.put(<span class="string">"org.quartz.threadPool.class"</span>, org.quartz.simpl.SimpleThreadPool.class.getName());</div><div class="line">   result.put(<span class="string">"org.quartz.threadPool.threadCount"</span>, <span class="string">"1"</span>); <span class="comment">// Quartz 线程数：1</span></div><div class="line">   result.put(<span class="string">"org.quartz.scheduler.instanceName"</span>, liteJobConfig.getJobName());</div><div class="line">   result.put(<span class="string">"org.quartz.jobStore.misfireThreshold"</span>, <span class="string">"1"</span>);</div><div class="line">   result.put(<span class="string">"org.quartz.plugin.shutdownhook.class"</span>, JobShutdownHookPlugin.class.getName()); <span class="comment">// 作业关闭钩子</span></div><div class="line">   result.put(<span class="string">"org.quartz.plugin.shutdownhook.cleanShutdown"</span>, Boolean.TRUE.toString()); <span class="comment">// 关闭时，清理所有资源</span></div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>org.quartz.threadPool.threadCount = 1</code>，即 Quartz 执行作业线程数量为 1。原因：一个<strong>作业( ElasticJob )<strong>的调度，需要配置</strong>独有</strong>的一个<strong>作业调度器( JobScheduler )</strong>，两者是 <code>1 : 1</code> 的关系。</li>
<li><code>org.quartz.plugin.shutdownhook.class</code> 设置作业<strong>优雅关闭</strong>钩子：<a href="https://github.com/dangdangdotcom/elastic-job/blob/7dc099541a16de49f024fc59e46377a726be7f6b/elastic-job-lite/elastic-job-lite-core/src/main/java/com/dangdang/ddframe/job/lite/internal/schedule/JobShutdownHookPlugin.java" rel="external nofollow noopener noreferrer" target="_blank">JobShutdownHookPlugin</a>。</li>
<li>触发器监听器( TriggerListener )，在<a href="http://www.yunai.me/Elastic-Job/job-execute/?self">《Elastic-Job-Lite 源码解析 —— 作业执行》</a>详细分享。</li>
</ul>
</li>
<li>
<p>调用 <code>#createJobDetail()</code> 方法创建 Quartz 作业：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobScheduler.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> JobDetail <span class="title">createJobDetail</span><span class="params">(<span class="keyword">final</span> String jobClass)</span> </span>&#123;</div><div class="line">   <span class="comment">// 创建 Quartz 作业</span></div><div class="line">   JobDetail result = JobBuilder.newJob(LiteJob.class).withIdentity(liteJobConfig.getJobName()).build();</div><div class="line">   <span class="comment">//</span></div><div class="line">   result.getJobDataMap().put(JOB_FACADE_DATA_MAP_KEY, jobFacade);</div><div class="line">   <span class="comment">// 创建 Elastic-Job 对象</span></div><div class="line">   Optional&lt;ElasticJob&gt; elasticJobInstance = createElasticJobInstance();</div><div class="line">   <span class="keyword">if</span> (elasticJobInstance.isPresent()) &#123;</div><div class="line">       result.getJobDataMap().put(ELASTIC_JOB_DATA_MAP_KEY, elasticJobInstance.get());</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!jobClass.equals(ScriptJob.class.getCanonicalName())) &#123;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           result.getJobDataMap().put(ELASTIC_JOB_DATA_MAP_KEY, Class.forName(jobClass).newInstance());</div><div class="line">       &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> ReflectiveOperationException ex) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> JobConfigurationException(<span class="string">"Elastic-Job: Job class '%s' can not initialize."</span>, jobClass);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">protected</span> Optional&lt;ElasticJob&gt; <span class="title">createElasticJobInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> Optional.absent();</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">// SpringJobScheduler.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> Optional&lt;ElasticJob&gt; <span class="title">createElasticJobInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> Optional.fromNullable(elasticJob);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>创建 Quartz 作业设置了 LiteJob 类，这样 Quartz 触发作业执行时，LiteJob 会去调用 Elastic-Job 作业对象。在<a href="http://www.yunai.me/Elastic-Job/job-execute/?self">《Elastic-Job-Lite 源码解析 —— 作业执行》</a>详细分享。</li>
<li>在 Spring 里，Elastic-Job 如果已经创建好<strong>注入</strong>到 SpringJobScheduler，无需进行创建。</li>
<li><code>Jodetail.jobDataMap</code> 属性里添加了作业门面对象( LiteJobFacade )、Elastic-Job 对象，Quartz  触发作业时，会设置到 LiteJob 对象里。</li>
</ul>
</li>
</ul>
<h3>3.2.4 注册作业启动信息</h3>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 注册作业启动信息.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> enabled 作业是否启用</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStartUpInfo</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> enabled)</span> </span>&#123;</div><div class="line">   <span class="comment">// 开启 所有监听器</span></div><div class="line">   listenerManager.startAllListeners();</div><div class="line">   <span class="comment">// 选举 主节点</span></div><div class="line">   leaderService.electLeader();</div><div class="line">   <span class="comment">// 持久化 作业服务器上线信息</span></div><div class="line">   serverService.persistOnline(enabled);</div><div class="line">   <span class="comment">// 持久化 作业运行实例上线相关信息</span></div><div class="line">   instanceService.persistOnline();</div><div class="line">   <span class="comment">// 设置 需要重新分片的标记</span></div><div class="line">   shardingService.setReshardingFlag();</div><div class="line">   <span class="comment">// 初始化 作业监听服务</span></div><div class="line">   monitorService.listen();</div><div class="line">   <span class="comment">// 初始化 调解作业不一致状态服务</span></div><div class="line">   <span class="keyword">if</span> (!reconcileService.isRunning()) &#123;</div><div class="line">       reconcileService.startAsync();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>开启所有监听器。每个功能模块都有其相应的监听器，在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31_bak.jpg">模块对应「文章」</a>详细分享。</p>
</li>
<li>
<p>选举主节点，在<a href="http://www.yunai.me/Elastic-Job/election/?self">《Elastic-Job-Lite 源码解析 —— 主节点选举》</a>详细分享。</p>
</li>
<li>
<p>调用 <code>ServerService#persistOnline()</code> 方法，持久化作业服务器上线信息。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerService</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 持久化作业服务器上线信息.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> enabled 作业是否启用</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">persistOnline</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> enabled)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!JobRegistry.getInstance().isShutdown(jobName)) &#123;</div><div class="line">            jobNodeStorage.fillJobNode(serverNode.getServerNode(JobRegistry.getInstance().getJobInstance(jobName).getIp()), enabled ? <span class="string">""</span> : ServerStatus.DISABLED.name());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>当作业配置设置作业<strong>禁用</strong>时( <code>LiteJobConfiguration.disabled = true</code> )，作业调度但<strong>调度作业分片为空</strong>。不太好理解？<a href="http://www.yunai.me/Elastic-Job/job-sharding/?self">《Elastic-Job-Lite 源码解析 —— 作业分片》</a>详细分享。</li>
</ul>
</li>
<li>
<p>调用 <code>InstanceService#persistOnline()</code> 方法，持久化作业运行实例上线相关信息：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceService</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 持久化作业运行实例上线相关信息.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">persistOnline</span><span class="params">()</span> </span>&#123;</div><div class="line">        jobNodeStorage.fillEphemeralJobNode(instanceNode.getLocalInstanceNode(), <span class="string">""</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>设置需要重新分片的标记，在<a href="http://www.yunai.me/Elastic-Job/ob-sharding/?self">《Elastic-Job-Lite 源码解析 —— 作业分片》</a>详细分享。</p>
</li>
<li>
<p>初始化作业监听服务，在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31_bak.jpg">《Elastic-Job-Lite 源码解析 —— 作业监控服务》</a>详细分享。</p>
</li>
<li>
<p>初始化调解作业不一致状态服务，在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31_bak.jpg">《Elastic-Job-Lite 源码解析 —— 作业不一致修复》</a>详细分享。</p>
</li>
</ul>
<h3>3.2.5 调度作业</h3>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobScheduler.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// .... 省略部分代码</span></div><div class="line">   <span class="comment">// 调度作业</span></div><div class="line">   jobScheduleController.scheduleJob(liteJobConfigFromRegCenter.getTypeConfig().getCoreConfig().getCron());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// JobScheduleController.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 调度作业.</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> cron CRON表达式</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleJob</span><span class="params">(<span class="keyword">final</span> String cron)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">if</span> (!scheduler.checkExists(jobDetail.getKey())) &#123;</div><div class="line">           scheduler.scheduleJob(jobDetail, createTrigger(cron));</div><div class="line">       &#125;</div><div class="line">       scheduler.start();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SchedulerException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>调用 <code>#scheduleJob()</code> 方法后，该 Elastic-Job 作业<strong>开始</strong>被调度。</li>
</ul>
<h1>666. 彩蛋</h1>
<p>作业初始化，如果你对 Quartz 不是特别了解，可以再看 Quartz 再重新理解。</p>
<p>下一篇，<a href="http://www.yunai.me/Elastic-Job/job-execute/?self">《Elastic-Job-Lite 源码解析 —— 作业执行》</a> 起航！</p>
<p>道友，分享一波<strong>微信朋友圈</strong>支持支持支持，可好？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. 作业注册表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;3
    
    </summary>
    
      <category term="Elastic-Job" scheme="http://www.yunai.me/categories/Elastic-Job/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Lite 源码分析 —— 作业配置</title>
    <link href="http://www.yunai.me/Elastic-Job/job-config/"/>
    <id>http://www.yunai.me/Elastic-Job/job-config/</id>
    <published>2017-09-08T16:00:00.000Z</published>
    <updated>2017-08-25T07:39:57.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. 作业配置</a>
<ul>
<li><a href="#">2.1 注册中心配置</a></li>
<li><a href="#">2.2 Lite作业配置</a>
<ul>
<li><a href="#">2.2.1 作业类型配置</a></li>
<li><a href="#">2.2.2 作业核心配置</a></li>
</ul>
</li>
<li><a href="#">2.3 作业事件配置</a></li>
<li><a href="#">2.4 作业监听器</a></li>
</ul>
</li>
<li><a href="#">3. 作业配置服务</a>
<ul>
<li><a href="#">3.1 读取作业配置</a></li>
<li><a href="#">3.2 持久化作业配置</a></li>
<li><a href="#">3.3 校验本机时间是否合法</a></li>
</ul>
</li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<h1>1. 概述</h1>
<p>本文主要分享 <strong>Elastic-Job-Lite 作业配置</strong>。</p>
<p>涉及到主要类的类图如下( <a href="http://www.yunai.me/images/Elastic-Job/2017_09_09/01.png">打开大图</a> )：</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_09_09/01.png" alt=""></p>
<ul>
<li><strong>黄色</strong>的类在 <code>elastic-job-common-core</code> 项目里，为 Elastic-Job-Lite、Elastic-Job-Cloud <strong>公用</strong>作业配置类。</li>
</ul>
<p>另外建议你已经( 非必须 )：</p>
<ul>
<li>阅读过<a href="http://dangdangdotcom.github.io/elastic-job/elastic-job-lite/02-guide/config-manual/" rel="external nofollow noopener noreferrer" target="_blank">《官方文档 —— 配置手册》</a></li>
<li>运行过 <a href="https://github.com/dangdangdotcom/elastic-job/blob/8926e94aa7c48dc635a36518da2c4b10194420a5/elastic-job-example/elastic-job-example-lite-java/src/main/java/com/dangdang/ddframe/job/example/JavaMain.java" rel="external nofollow noopener noreferrer" target="_blank">JavaMain.java</a></li>
</ul>
<blockquote>
<p>你行好事会因为得到赞赏而愉悦<br>
同理，开源项目贡献者会因为 Star 而更加有动力<br>
为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p>
</blockquote>
<h1>2. 作业配置</h1>
<p>一个<strong>作业( ElasticJob )<strong>的调度，需要配置</strong>独有</strong>的一个<strong>作业调度器( JobScheduler )</strong>，两者是 <code>1 : 1</code> 的关系。<strong>这点大家要注意下，当然下文看代码也会看到。</strong></p>
<p>作业调度器的创建可以配置四个参数：</p>
<ol>
<li>注册中心( CoordinatorRegistryCenter )：用于协调分布式服务。<strong>必填</strong>。</li>
<li>Lite作业配置( LiteJobConfiguration )：<strong>必填</strong>。</li>
<li>作业事件总线( JobEventBus )：对作业事件<strong>异步</strong>监听。<strong>选填</strong>。</li>
<li>作业监听器( ElasticJobListener )：对作业执行前，执行后进行<strong>同步</strong>监听。<strong>选填</strong>。</li>
</ol>
<h2>2.1 注册中心配置</h2>
<p>Elastic-Job 抽象了<strong>注册中心接口( RegistryCenter )</strong>，并提供了默认<strong>基于 Zookeeper 的注册中心实现( ZookeeperRegistryCenter )</strong>。</p>
<p>ZookeeperRegistryCenter 对应配置类为 ZookeeperConfiguration。该类注释很完整，可以点击<a href="https://github.com/dangdangdotcom/elastic-job/blob/7dc099541a16de49f024fc59e46377a726be7f6b/elastic-job-common/elastic-job-common-core/src/main/java/com/dangdang/ddframe/job/reg/zookeeper/ZookeeperConfiguration.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a>直接查看源码，这里我们重点说下 <code>namespace</code> 属性。如果你有多个<strong>不同</strong> Elastic-Job集群 时，使用相同 Zookeeper，可以配置不同的 <code>namespace</code> 进行隔离。</p>
<p>注册中心的<strong>初始化</strong>，我们会在<a href="http://www.yunai.me/Elastic-Job/reg-center-zookeeper/?self">《Elastic-Job-Lite 源码解析 —— 注册中心》</a>详细分享。</p>
<h2>2.2 Lite作业配置</h2>
<p><a href="https://github.com/dangdangdotcom/elastic-job/blob/6617853bf059df373e2cb6ce959038c583ae5064/elastic-job-lite/elastic-job-lite-core/src/main/java/com/dangdang/ddframe/job/lite/config/LiteJobConfiguration.java" rel="external nofollow noopener noreferrer" target="_blank">LiteJobConfiguration</a> 继承自接口 <a href="https://github.com/dangdangdotcom/elastic-job/blob/6617853bf059df373e2cb6ce959038c583ae5064/elastic-job-common/elastic-job-common-core/src/main/java/com/dangdang/ddframe/job/config/JobRootConfiguration.java" rel="external nofollow noopener noreferrer" target="_blank">JobRootConfiguration</a>，作为 Elastic-Job-Lite 里的作业( LiteJob )配置。<em>Elastic-Job-Cloud 的作业( CloudJob )对应另外的配置类，也实现了该接口。</em></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LiteJobConfiguration</span> <span class="keyword">implements</span> <span class="title">JobRootConfiguration</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobTypeConfiguration typeConfig;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> monitorExecution;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxTimeDiffSeconds;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> monitorPort;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String jobShardingStrategyClass;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> reconcileIntervalMinutes;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> disabled;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> overwrite;</div><div class="line">    </div><div class="line">    <span class="comment">// .... 省略部分get方法</span></div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    </div><div class="line">        <span class="comment">// .... 省略部分属性</span></div><div class="line">    </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> LiteJobConfiguration <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LiteJobConfiguration(jobConfig, monitorExecution, maxTimeDiffSeconds, monitorPort, jobShardingStrategyClass, reconcileIntervalMinutes, disabled, overwrite);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p><code>typeConfig</code>：作业类型配置。<strong>必填</strong>。</p>
</li>
<li>
<p><code>monitorExecution</code>：监控作业运行时状态。默认为 <code>false</code>。选填。在<a href="http://www.yunai.me/Elastic-Job/job-execute/?self">《Elastic-Job-Lite 源码解析 —— 作业执行》</a>详细分享。</p>
<blockquote>
<p>每次作业执行时间和间隔时间均<strong>非常短</strong>的情况，建议不监控作业运行时状态以提升效率。因为是瞬时状态，所以无必要监控。请用户自行增加数据堆积监控。并且不能保证数据重复选取，应在作业中实现幂等性。<br>
每次作业执行时间和间隔时间均<strong>较长的</strong>情况，建议监控作业运行时状态，可保证数据不会重复选取。</p>
</blockquote>
</li>
<li>
<p><code>monitorPort</code>：作业监控端口。默认为 <code>-1</code>，不开启作业监控端口。选填。在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31_bak.jpg">《Elastic-Job-Lite 源码解析 —— 作业监控服务》</a>详细分享。</p>
<blockquote>
<p>建议配置作业监控端口, 方便开发者dump作业信息。<br>
使用方法: echo “dump” | nc 127.0.0.1 9888</p>
</blockquote>
</li>
<li>
<p><code>maxTimeDiffSeconds</code>：设置最大容忍的本机与注册中心的时间误差秒数。默认为 <code>-1</code>，不检查时间误差。选填。</p>
</li>
<li>
<p><code>jobShardingStrategyClass</code>：作业分片策略实现类全路径。默认为使用分配侧路。选填。在<a href="http://www.yunai.me/Elastic-Job/ob-sharding-strategy/?self">《Elastic-Job-Lite 源码解析 —— 作业分片策略》</a>详细分享。</p>
</li>
<li>
<p><code>reconcileIntervalMinutes</code>：修复作业服务器不一致状态服务调度间隔时间，配置为小于1的任意值表示不执行修复。默认为 <code>10</code>。在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31_bak.jpg">《Elastic-Job-Lite 源码解析 —— 作业不一致修复 》</a>详细分享。</p>
</li>
<li>
<p><code>disabled</code>：作业是否禁用执行。默认为 <code>false</code>。选填。</p>
</li>
<li>
<p><code>overwrite</code>：设置使用本地作业配置覆盖注册中心的作业配置。默认为 <code>false</code>。选填。建议使用**运维平台( console )**配置作业配置，统一管理。</p>
</li>
<li>
<p>Builder 类：使用该类配置 LiteJobConfiguration 属性，调用 <code>#build()</code> 方法最终生成作业配置。参见：<a href="http://blog.csdn.net/top_code/article/details/8469297" rel="external nofollow noopener noreferrer" target="_blank">《JAVA设计模式 — 生成器模式(Builder)》</a>。</p>
</li>
</ul>
<h3>2.2.1 作业类型配置</h3>
<p>作业类型配置<strong>接口</strong>( <a href="https://github.com/dangdangdotcom/elastic-job/blob/6617853bf059df373e2cb6ce959038c583ae5064/elastic-job-common/elastic-job-common-core/src/main/java/com/dangdang/ddframe/job/config/JobTypeConfiguration.java" rel="external nofollow noopener noreferrer" target="_blank">JobTypeConfiguration</a> ) 有三种配置实现，针对三种作业类型：</p>
<table>
<thead>
<tr>
<th style="text-align:left">配置实现</th>
<th style="text-align:left">作业</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://github.com/dangdangdotcom/elastic-job/blob/6617853bf059df373e2cb6ce959038c583ae5064/elastic-job-common/elastic-job-common-core/src/main/java/com/dangdang/ddframe/job/config/simple/SimpleJobConfiguration.java" rel="external nofollow noopener noreferrer" target="_blank">SimpleJobConfiguration</a></td>
<td style="text-align:left">SimpleJob</td>
<td style="text-align:left">简单作业。例如：订单过期作业</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://github.com/dangdangdotcom/elastic-job/blob/6617853bf059df373e2cb6ce959038c583ae5064/elastic-job-common/elastic-job-common-core/src/main/java/com/dangdang/ddframe/job/config/dataflow/DataflowJobConfiguration.java" rel="external nofollow noopener noreferrer" target="_blank">DataflowJobConfiguration</a></td>
<td style="text-align:left">DataflowJob</td>
<td style="text-align:left">数据流作业。TODO：笔者暂时未了解流式处理数据，不误人子弟</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://github.com/dangdangdotcom/elastic-job/blob/6617853bf059df373e2cb6ce959038c583ae5064/elastic-job-common/elastic-job-common-core/src/main/java/com/dangdang/ddframe/job/config/script/ScriptJobConfiguration.java" rel="external nofollow noopener noreferrer" target="_blank">ScriptJobConfiguration</a></td>
<td style="text-align:left">ScriptJob</td>
<td style="text-align:left">脚本作业。例如：调用 shell 脚本备份数据库作业</td>
</tr>
</tbody>
</table>
<p>三种<strong>配置类</strong>属性对比如：</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">SimpleJob</th>
<th style="text-align:left">DataflowJob</th>
<th style="text-align:left">ScriptJob</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>coreConfig</code></td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">作业核心配置</td>
</tr>
<tr>
<td style="text-align:left"><code>jobType</code></td>
<td style="text-align:left">JobType.SIMPLE</td>
<td style="text-align:left">JobType.DATAFLOW</td>
<td style="text-align:left">JobType.SCRIPT</td>
<td style="text-align:left">作业类型</td>
</tr>
<tr>
<td style="text-align:left"><code>jobClass</code></td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√ (默认：ScriptJob.class)</td>
<td style="text-align:left">作业实现类全路径</td>
</tr>
<tr>
<td style="text-align:left"><code>streamingProcess</code></td>
<td style="text-align:left"></td>
<td style="text-align:left">√</td>
<td style="text-align:left"></td>
<td style="text-align:left">是否流式处理数据</td>
</tr>
<tr>
<td style="text-align:left"><code>scriptCommandLine</code></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">√</td>
<td style="text-align:left">脚本型作业执行命令行</td>
</tr>
</tbody>
</table>
<p><strong>作业类型配置不仅仅适用于 Elastic-Job-Lite，也适用于 Elastic-Job-Cloud。</strong></p>
<h3>2.2.2 作业核心配置</h3>
<p>作业核心配置( JobCoreConfiguration )，我们可以看到在每种作业类型配置都有该属性( <code>coreConfig</code> )。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobCoreConfiguration</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String jobName;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String cron;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> shardingTotalCount;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String shardingItemParameters;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String jobParameter;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> failover;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> misfire;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String description;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobProperties jobProperties;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    </div><div class="line">        <span class="comment">// .... 省略部分属性</span></div><div class="line">    </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> JobCoreConfiguration <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">            Preconditions.checkArgument(!Strings.isNullOrEmpty(jobName), <span class="string">"jobName can not be empty."</span>);</div><div class="line">            Preconditions.checkArgument(!Strings.isNullOrEmpty(cron), <span class="string">"cron can not be empty."</span>);</div><div class="line">            Preconditions.checkArgument(shardingTotalCount &gt; <span class="number">0</span>, <span class="string">"shardingTotalCount should larger than zero."</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JobCoreConfiguration(jobName, cron, shardingTotalCount, shardingItemParameters, jobParameter, failover, misfire, description, jobProperties);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p><code>jobName</code>：作业名称。<strong>必填。</strong></p>
</li>
<li>
<p><code>cron</code>：cron表达式，用于控制作业触发时间。<strong>必填。</strong></p>
</li>
<li>
<p><code>shardingTotalCount</code>：作业分片总数。如果一个作业启动超过作业分片总数的节点，只有 <code>shardingTotalCount</code> 会执行作业。**必填。**在<a href="http://www.yunai.me/Elastic-Job/ob-sharding-strategy/?self">《Elastic-Job-Lite 源码解析 —— 作业分片策略 》</a>详细分享。</p>
</li>
<li>
<p><code>shardingItemParameters</code>：分片序列号和参数。选填。</p>
<blockquote>
<p>分片序列号和参数用等号分隔，多个键值对用逗号分隔<br>
分片序列号从0开始，<strong>不可大于或等于</strong>作业分片总数<br>
如：<br>
0=a,1=b,2=c</p>
</blockquote>
</li>
<li>
<p><code>jobParameter</code>：作业自定义参数。选填。</p>
<blockquote>
<p>作业自定义参数，可通过传递该参数为作业调度的业务方法传参，用于实现带参数的作业<br>
例：每次获取的数据量、作业实例从数据库读取的主键等</p>
</blockquote>
</li>
<li>
<p><code>failover</code>：是否开启作业执行失效转移。<strong>开启表示如果作业在一次作业执行中途宕机，允许将该次未完成的作业在另一作业节点上补偿执行</strong>。默认为 <code>false</code>。选填。在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31_bak.jpg">《Elastic-Job-Lite 源码解析 —— 作业失效转移 》</a>详细分享。</p>
</li>
<li>
<p><code>misfire</code>：是否开启错过作业重新执行。默认为 <code>true</code>。选填。在<a href="http://www.yunai.me/Elastic-Job/job-execute/?self">《Elastic-Job-Lite 源码解析 —— 作业执行 》</a>详细分享。</p>
</li>
<li>
<p><code>description</code>：作业描述。选填。</p>
</li>
<li>
<p><code>jobProperties</code>：作业属性配置。选填。在<a href="http://www.yunai.me/Elastic-Job/job-execute/?self">《Elastic-Job-Lite 源码解析 —— 作业执行 》</a>详细分享。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobProperties</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> EnumMap&lt;JobPropertiesEnum, String&gt; map = <span class="keyword">new</span> EnumMap&lt;&gt;(JobPropertiesEnum.class);</div><div class="line">    </div><div class="line">   <span class="keyword">public</span> <span class="keyword">enum</span> JobPropertiesEnum &#123;</div><div class="line">        </div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 作业异常处理器.</div><div class="line">         */</div><div class="line">        JOB_EXCEPTION_HANDLER(<span class="string">"job_exception_handler"</span>, JobExceptionHandler.class, DefaultJobExceptionHandler.class.getCanonicalName()),</div><div class="line">        </div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 线程池服务处理器.</div><div class="line">         */</div><div class="line">        EXECUTOR_SERVICE_HANDLER(<span class="string">"executor_service_handler"</span>, ExecutorServiceHandler.class, DefaultExecutorServiceHandler.class.getCanonicalName());</div><div class="line">        </div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String key;</div><div class="line">    </div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; classType;</div><div class="line">        </div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String defaultValue;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>JOB_EXCEPTION_HANDLER</code>：用于扩展<strong>异常处理</strong>类。</li>
<li><code>EXECUTOR_SERVICE_HANDLER</code>：用于扩展<strong>作业处理线程池</strong>类。</li>
<li>通过这个属性，我们可以自定义<strong>每个作业</strong>的异常处理和线程池服务。</li>
</ul>
</li>
</ul>
<h2>2.3 作业事件配置</h2>
<p>通过作业事件配置( JobEventConfiguration )，实现对作业事件的<strong>异步</strong>监听、处理。在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31_bak.jpg">《Elastic-Job-Lite 源码解析 —— 作业事件与追踪》</a>详细分享。</p>
<h2>2.4 作业监听器</h2>
<p>通过配置作业监听器( ElasticJobListener )，实现对作业执行的<strong>同步</strong>监听、处理。在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31_bak.jpg">《Elastic-Job-Lite 源码解析 —— 作业监听器》</a>详细分享。</p>
<h1>3. 作业配置服务</h1>
<p>多个 Elastic-Job-Lite 使用相同<strong>注册中心</strong>和相同 <strong><code>namespace</code></strong> 组成集群，实现高可用。集群中，使用作业配置服务( ConfigurationService ) 共享作业配置。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 时间服务</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TimeService timeService;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业节点数据访问类</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobNodeStorage jobNodeStorage;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConfigurationService</span><span class="params">(<span class="keyword">final</span> CoordinatorRegistryCenter regCenter, <span class="keyword">final</span> String jobName)</span> </span>&#123;</div><div class="line">        jobNodeStorage = <span class="keyword">new</span> JobNodeStorage(regCenter, jobName);</div><div class="line">        timeService = <span class="keyword">new</span> TimeService();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>JobNodeStorage，封装注册中心，提供存储服务。在<a href="http://www.yunai.me/Elastic-Job/job-storage/?self">《Elastic-Job-Lite 源码解析 —— 作业数据存储》</a>详细分享。</p>
</li>
<li>
<p>TimeService，时间服务，提供当前时间查询。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeService</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取当前时间的毫秒数.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@return</span> 当前时间的毫秒数</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCurrentMillis</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> System.currentTimeMillis();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
</ul>
<h2>3.1 读取作业配置</h2>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 读取作业配置.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> fromCache 是否从缓存中读取</div><div class="line">* <span class="doctag">@return</span> 作业配置</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> LiteJobConfiguration <span class="title">load</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> fromCache)</span> </span>&#123;</div><div class="line">   String result;</div><div class="line">   <span class="keyword">if</span> (fromCache) &#123; <span class="comment">// 缓存</span></div><div class="line">       result = jobNodeStorage.getJobNodeData(ConfigurationNode.ROOT);</div><div class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> == result) &#123;</div><div class="line">           result = jobNodeStorage.getJobNodeDataDirectly(ConfigurationNode.ROOT);</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       result = jobNodeStorage.getJobNodeDataDirectly(ConfigurationNode.ROOT);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> LiteJobConfigurationGsonFactory.fromJson(result);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>3.2 持久化作业配置</h2>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 持久化分布式作业配置信息.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> liteJobConfig 作业配置</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">persist</span><span class="params">(<span class="keyword">final</span> LiteJobConfiguration liteJobConfig)</span> </span>&#123;</div><div class="line">   checkConflictJob(liteJobConfig);</div><div class="line">   <span class="keyword">if</span> (!jobNodeStorage.isJobNodeExisted(ConfigurationNode.ROOT) || liteJobConfig.isOverwrite()) &#123;</div><div class="line">       jobNodeStorage.replaceJobNode(ConfigurationNode.ROOT, LiteJobConfigurationGsonFactory.toJson(liteJobConfig));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>调用 <code>#checkConflictJob(...)</code> 方法<strong>校验</strong>注册中心存储的作业配置的作业实现类全路径( <code>jobClass</code> )和当前的是否相同，如果不同，则认为是<strong>冲突</strong>，不允许存储：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkConflictJob</span><span class="params">(<span class="keyword">final</span> LiteJobConfiguration liteJobConfig)</span> </span>&#123;</div><div class="line">   Optional&lt;LiteJobConfiguration&gt; liteJobConfigFromZk = find();</div><div class="line">   <span class="keyword">if</span> (liteJobConfigFromZk.isPresent()</div><div class="line">           &amp;&amp; !liteJobConfigFromZk.get().getTypeConfig().getJobClass().equals(liteJobConfig.getTypeConfig().getJobClass())) &#123; <span class="comment">// jobClass 是否相同</span></div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> JobConfigurationException(<span class="string">"Job conflict with register center. The job '%s' in register center's class is '%s', your job class is '%s'"</span>, </div><div class="line">               liteJobConfig.getJobName(), liteJobConfigFromZk.get().getTypeConfig().getJobClass(), liteJobConfig.getTypeConfig().getJobClass());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
</ul>
<ul>
<li>当注册中心<strong>未存储</strong>该作业配置 或者 当前作业配置允许替换注册中心作业配置( <code>overwrite = true</code> )时，持久化作业配置。</li>
</ul>
<h2>3.3 校验本机时间是否合法</h2>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 检查本机与注册中心的时间误差秒数是否在允许范围.</div><div class="line">* </div><div class="line">* <span class="doctag">@throws</span> JobExecutionEnvironmentException 本机与注册中心的时间误差秒数不在允许范围所抛出的异常</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkMaxTimeDiffSecondsTolerable</span><span class="params">()</span> <span class="keyword">throws</span> JobExecutionEnvironmentException </span>&#123;</div><div class="line">   <span class="keyword">int</span> maxTimeDiffSeconds =  load(<span class="keyword">true</span>).getMaxTimeDiffSeconds();</div><div class="line">   <span class="keyword">if</span> (-<span class="number">1</span>  == maxTimeDiffSeconds) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">long</span> timeDiff = Math.abs(timeService.getCurrentMillis() - jobNodeStorage.getRegistryCenterTime());</div><div class="line">   <span class="keyword">if</span> (timeDiff &gt; maxTimeDiffSeconds * <span class="number">1000L</span>) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> JobExecutionEnvironmentException(</div><div class="line">               <span class="string">"Time different between job server and register center exceed '%s' seconds, max time different is '%s' seconds."</span>, timeDiff / <span class="number">1000</span>, maxTimeDiffSeconds);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>Elastic-Job-Lite 作业触发是<strong>依赖本机时间</strong>，相同集群使用注册中心时间为基准，校验本机与注册中心的时间误差是否在允许范围内( <code>LiteJobConfiguration.maxTimeDiffSeconds</code> )。</li>
</ul>
<h1>666. 彩蛋</h1>
<p>Elastic-Job-Lite 源码解析系列第一篇文章，希望大家多多支持，预计全部更新完会有 15+ 篇。Elastic-Job-Cloud 源码系列后续也会更新。</p>
<p>道友，分享一波<strong>微信朋友圈</strong>支持支持支持，可好？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. 作业配置&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2.
    
    </summary>
    
      <category term="Elastic-Job" scheme="http://www.yunai.me/categories/Elastic-Job/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job 源码分析 —— 为什么阅读 Elastic-Job 源码？</title>
    <link href="http://www.yunai.me/Elastic-Job/why-read-Elastic-Job-source-code/"/>
    <id>http://www.yunai.me/Elastic-Job/why-read-Elastic-Job-source-code/</id>
    <published>2017-08-31T16:00:00.000Z</published>
    <updated>2017-08-23T17:46:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<h2>为什么阅读 Elastic-Job 源码？</h2>
<ol>
<li>之前断断续续读过 Quartz 源码，团队里也对 Quartz 做过一些封装管理，很多 Quartz 二次封装开源项目，想了解 Elastic-Job 做了哪些功能，是怎么实现的</li>
<li>Quartz 多节点通过数据库锁实现任务抢占，Elastic-Job 基于什么策略实现任务调度与分配</li>
<li>任务分片如何实现</li>
<li>Elastic-Job-Cloud 如何实现任务动态扩容和缩容</li>
<li>任务超时如何处理？任务假死怎么判断？</li>
</ol>
<h2>使用公司</h2>
<h2>步骤/功能</h2>
<ul>
<li>[ ] 分布式调度协调</li>
<li>[ ] 弹性扩容缩容</li>
<li>[ ] 失效转移</li>
<li>[x] 错过执行作业重触发</li>
<li>[ ] 作业分片策略</li>
<li>[x] 作业唯一节点执行</li>
<li>[ ] 自诊断并修复分布式不稳定造成的问题</li>
<li>[x] 支持并行调度</li>
<li>[ ] 支持作业生命周期操作</li>
<li>[ ] 丰富的作业类型</li>
<li>[ ] Spring整合以及命名空间提供</li>
<li>[ ] 运维平台</li>
<li>[ ] 事件追踪</li>
<li>[ ] DUMP 作业运行信息</li>
<li>[ ] 作业监听器</li>
<li>[ ] 基于 Docker 的进程隔离（TBD）</li>
<li>[x] 高可用</li>
</ul>
<h2>XXL-JOB</h2>
<p>基于 V1.8，会逐渐和 Elastic-Job 功能做对比</p>
<ul>
<li>[ ] 1、简单：支持通过Web页面对任务进行CRUD操作，操作简单，一分钟上手；</li>
<li>[ ] 2、动态：支持动态修改任务状态、暂停/恢复任务，以及终止运行中任务，即时生效；</li>
<li>[ ] 3、调度中心HA（中心式）：调度采用中心式设计，“调度中心”基于集群Quartz实现，可保证调度中心HA；</li>
<li>[ ] 4、执行器HA（分布式）：任务分布式执行，任务&quot;执行器&quot;支持集群部署，可保证任务执行HA；</li>
<li>[ ] 5、任务Failover：执行器集群部署时，任务路由策略选择&quot;故障转移&quot;情况下调度失败时将会平滑切换执行器进行Failover；</li>
<li>[ ] 6、一致性：“调度中心”通过DB锁保证集群分布式调度的一致性, 一次任务调度只会触发一次执行；</li>
<li>[ ] 7、自定义任务参数：支持在线配置调度任务入参，即时生效；</li>
<li>[ ] 8、调度线程池：调度系统多线程触发调度运行，确保调度精确执行，不被堵塞；</li>
<li>[ ] 9、弹性扩容缩容：一旦有新执行器机器上线或者下线，下次调度时将会重新分配任务；</li>
<li>[ ] 10、邮件报警：任务失败时支持邮件报警，支持配置多邮件地址群发报警邮件；</li>
<li>[ ] 11、状态监控：支持实时监控任务进度；</li>
<li>[ ] 12、Rolling执行日志：支持在线查看调度结果，并且支持以Rolling方式实时查看执行器输出的完整的执行日志；</li>
<li>[ ] 13、GLUE：提供Web IDE，支持在线开发任务逻辑代码，动态发布，实时编译生效，省略部署上线的过程。支持30个版本的历史版本回溯。</li>
<li>[ ] 14、数据加密：调度中心和执行器之间的通讯进行数据加密，提升调度信息安全性；</li>
<li>[ ] 15、任务依赖：支持配置子任务依赖，当父任务执行结束且执行成功后将会主动触发一次子任务的执行, 多个子任务用逗号分隔；</li>
<li>[ ] 16、推送maven中央仓库: 将会把最新稳定版推送到maven中央仓库, 方便用户接入和使用;</li>
<li>[ ] 17、任务注册: 执行器会周期性自动注册任务, 调度中心将会自动发现注册的任务并触发执行。同时，也支持手动录入执行器地址；</li>
<li>[ ] 18、路由策略：执行器集群部署时提供丰富的路由策略，包括：第一个、最后一个、轮询、随机、一致性HASH、最不经常使用、最近最久未使用、故障转移、忙碌转移等；</li>
<li>[ ] 19、运行报表：支持实时查看运行数据，如任务数量、调度次数、执行器数量等；以及调度报表，如调度日期分布图，调度成功分布图等；</li>
<li>[ ] 20、脚本任务：支持以GLUE模式开发和运行脚本任务，包括Shell、Python等类型脚本;</li>
<li>[ ] 21、阻塞处理策略：调度过于密集执行器来不及处理时的处理策略，策略包括：单机串行（默认）、丢弃后续调度、覆盖之前调度；</li>
<li>[ ] 22、失败处理策略；调度失败时的处理策略，策略包括：失败告警（默认）、失败重试；</li>
<li>[ ] 23、分片广播任务：执行器集群部署时，任务路由策略选择&quot;分片广播&quot;情况下，一次任务调度将会广播触发对应集群中所有执行器执行一次任务，同时传递分片参数；可根据分片参数开发分片任务；</li>
<li>[ ] 24、动态分片：分片广播任务以执行器为维度进行分片，支持动态扩容执行器集群从而动态增加分片数量，协同进行业务处理；在进行大数据量业务操作时可显著提升任务处理能力和速度。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：&lt;/p&gt;
&lt;ol&gt;
&lt;
    
    </summary>
    
      <category term="Elastic-Job" scheme="http://www.yunai.me/categories/Elastic-Job/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— 分布式事务（二）之事务补偿型</title>
    <link href="http://www.yunai.me/Sharding-JDBC/transaction-tcc/"/>
    <id>http://www.yunai.me/Sharding-JDBC/transaction-tcc/</id>
    <published>2017-08-21T16:00:00.000Z</published>
    <updated>2017-08-14T18:34:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<p>占坑文。关注公众号，第一时间获得更新通知。
ps：tcc 暂时未实现，目前在 RoadMap 中</p>
<hr>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>
🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：&lt;/p&gt;
&lt;ol&gt;

    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— 分布式事务（一）之最大努力型</title>
    <link href="http://www.yunai.me/Sharding-JDBC/transaction-bed/"/>
    <id>http://www.yunai.me/Sharding-JDBC/transaction-bed/</id>
    <published>2017-08-19T16:00:00.000Z</published>
    <updated>2017-08-14T18:34:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. 最大努力送达型</a></li>
<li><a href="#">3. 柔性事务管理器</a>
<ul>
<li><a href="#">3.1 概念</a></li>
<li><a href="#">3.2 柔性事务配置</a></li>
<li><a href="#">3.3 柔性事务</a>
<ul>
<li><a href="#">3.3.1 创建柔性事务</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#">4. 事务日志存储器</a>
<ul>
<li><a href="#">4.1 #add()</a></li>
<li><a href="#">4.2 #remove()</a></li>
<li><a href="#">4.3 #findEligibleTransactionLogs()</a></li>
<li><a href="#">4.4 #increaseAsyncDeliveryTryTimes()</a></li>
<li><a href="#">4.5 #processData()</a></li>
</ul>
</li>
<li><a href="#">5. 最大努力送达型事务监听器</a></li>
<li><a href="#">6. 最大努力送达型异步作业</a>
<ul>
<li><a href="#">6.1 BestEffortsDeliveryJob</a></li>
<li><a href="#">6.2 AsyncSoftTransactionJobConfiguration</a></li>
<li><a href="#">6.3 Elastic-Job 是否必须？</a></li>
</ul>
</li>
<li><a href="#">7. 适用场景</a></li>
<li><a href="#">8. 开发指南 &amp; 开发示例</a></li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<h1>1. 概述</h1>
<p>数据库表<strong>分库</strong>后，业务场景下的<strong>单库本地事务</strong>可能变成<strong>跨库分布式事务</strong>。虽然我们可以通过合适的<strong>分库规则</strong>让操作的数据在同库下，继续保证<strong>单库本地事务</strong>，这也是非常推崇的，但不是所有场景下都能适用。如果这些场景对事务的一致性有要求，我们就不得不解决分布式事务的“麻烦”。</p>
<p><strong>分布式事务</strong>是个很大的话题，我们来看看 Sharding-JDBC 对她的权衡：</p>
<blockquote>
<p>Sharding-JDBC由于性能方面的考量，决定不支持强一致性分布式事务。我们已明确规划线路图，未来会支持最终一致性的柔性事务。</p>
</blockquote>
<p>Sharding-JDBC 提供了两种 <strong>柔性事务</strong>：</p>
<ul>
<li>最大努力送达型 BED ：已经实现</li>
<li>事务补偿型 TCC ：计划中</li>
</ul>
<p><strong>本文分享 最大努力送达型 的实现</strong>。建议前置阅读：<a href="http://www.yunai.me/Sharding-JDBC/sql-execute/?self">《Sharding-JDBC 源码分析 —— SQL 执行》</a>。</p>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>
🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
<h1>2. 最大努力送达型</h1>
<p><strong>概念</strong></p>
<blockquote>
<p>在分布式数据库的场景下，相信对于该数据库的操作最终一定可以成功，所以通过最大努力反复尝试送达操作。</p>
</blockquote>
<p>从概念看，可能不是很直白的理解是什么意思，本文会<strong>最大努力</strong>让你干净理解。</p>
<p><strong>架构图</strong></p>
<blockquote>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_20/01.jpeg" alt=""></p>
</blockquote>
<p>执行过程有 <strong>四种</strong> 情况：</p>
<ol>
<li>【红线】执行成功</li>
<li>【棕线】执行失败，同步重试成功</li>
<li>【粉线】执行失败，同步重试失败，异步重试成功</li>
<li>【绿线】执行失败，同步重试失败，异步重试失败，事务日志保留</li>
</ol>
<p>整体成漏斗倒三角，上一个阶段失败，交给下一个阶段重试：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_20/02.png" alt=""></p>
<p>整个过程通过如下 <strong>组件</strong> 完成：</p>
<ul>
<li>柔性事务管理器</li>
<li>最大努力送达型柔性事务</li>
<li>最大努力送达型事务监听器</li>
<li>事务日志存储器</li>
<li>最大努力送达型异步作业</li>
</ul>
<p>下面，我们逐节分享每个组件。</p>
<h1>3. 柔性事务管理器</h1>
<h2>3.1 概念</h2>
<p>柔性事务管理器，SoftTransactionManager 实现，负责对柔性事务配置( SoftTransactionConfiguration ) 、柔性事务( AbstractSoftTransaction )的管理。</p>
<h2>3.2 柔性事务配置</h2>
<p>调用 <code>#init()</code> 初始化柔性管理器：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SoftTransactionManager.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 柔性事务配置对象</div><div class="line">*/</div><div class="line"><span class="meta">@Getter</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> SoftTransactionConfiguration transactionConfig;  </div><div class="line"></div><div class="line"><span class="comment">// SoftTransactionManager.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 初始化事务管理器.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="comment">// 初始化 最大努力送达型事务监听器</span></div><div class="line">   EventBusInstance.getInstance().register(<span class="keyword">new</span> BestEffortsDeliveryListener());</div><div class="line">   <span class="comment">// 初始化 事务日志数据库存储表</span></div><div class="line">   <span class="keyword">if</span> (TransactionLogDataSourceType.RDB == transactionConfig.getStorageType()) &#123;</div><div class="line">       Preconditions.checkNotNull(transactionConfig.getTransactionLogDataSource());</div><div class="line">       createTable();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 初始化 内嵌的最大努力送达型异步作业</span></div><div class="line">   <span class="keyword">if</span> (transactionConfig.getBestEffortsDeliveryJobConfiguration().isPresent()) &#123;</div><div class="line">       <span class="keyword">new</span> NestedBestEffortsDeliveryJobFactory(transactionConfig).init();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>将最大努力送达型事务监听器( BestEffortsDeliveryListener )注册到事务总线 ( EventBus )。在『最大努力送达型事务监听器』小节会详细分享</li>
<li>当使用<strong>数据库</strong>存储事务日志( TransactionLog ) 时，若**事务日志表( <code>transaction_log</code> )**不存在则进行创建。在『事务日志存储器』小节会详细分享</li>
<li>当配置使用<strong>内嵌的</strong>最大努力送达型异步作业( NestedBestEffortsDeliveryJob ) 时，进行初始化。在『最大努力送达型异步作业』小节会详细分享</li>
</ul>
<p><strong>SoftTransactionConfiguration</strong></p>
<p>SoftTransactionConfiguration，柔性事务配置对象。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftTransactionConfiguration</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 事务管理器管理的数据源.</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span>(AccessLevel.NONE)</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DataSource targetDataSource;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 同步的事务送达的最大尝试次数.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> syncMaxDeliveryTryTimes = <span class="number">3</span>;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 事务日志存储类型.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> TransactionLogDataSourceType storageType = RDB;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 存储事务日志的数据源.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> DataSource transactionLogDataSource;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 内嵌的最大努力送达型异步作业配置对象.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Optional&lt;NestedBestEffortsDeliveryJobConfiguration&gt; bestEffortsDeliveryJobConfiguration = Optional.absent();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>3.3 柔性事务</h2>
<p>在 Sharding-JDBC 里，目前柔性事务分成两种：</p>
<ul>
<li>BEDSoftTransaction ：最大努力送达型柔性事务</li>
<li>TCCSoftTransaction ：TCC型柔性事务</li>
</ul>
<p><strong>继承 AbstractSoftTransaction</strong></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSoftTransaction</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 分片连接原自动提交状态</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> previousAutoCommit;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 分片连接</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> ShardingConnection connection;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 事务类型</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> SoftTransactionType transactionType;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 事务编号</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> String transactionId;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>AbstractSoftTransaction 实现了开启柔性事务、关闭柔性事务两个方法提供给子类调用：</p>
<ul>
<li>
<p><code>#beginInternal()</code></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 开启柔性</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> conn 分片连接</div><div class="line">* <span class="doctag">@param</span> type 事务类型</div><div class="line">* <span class="doctag">@throws</span> SQLException</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">beginInternal</span><span class="params">(<span class="keyword">final</span> Connection conn, <span class="keyword">final</span> SoftTransactionType type)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="comment">// TODO 判断如果在传统事务中，则抛异常</span></div><div class="line">   Preconditions.checkArgument(conn <span class="keyword">instanceof</span> ShardingConnection, <span class="string">"Only ShardingConnection can support eventual consistency transaction."</span>);</div><div class="line">   <span class="comment">// 设置执行错误，不抛出异常</span></div><div class="line">   ExecutorExceptionHandler.setExceptionThrown(<span class="keyword">false</span>);</div><div class="line">   connection = (ShardingConnection) conn;</div><div class="line">   transactionType = type;</div><div class="line">   <span class="comment">// 设置自动提交状态</span></div><div class="line">   previousAutoCommit = connection.getAutoCommit();</div><div class="line">   connection.setAutoCommit(<span class="keyword">true</span>);</div><div class="line">   <span class="comment">// 生成事务编号</span></div><div class="line">   <span class="comment">// TODO 替换UUID为更有效率的id生成器</span></div><div class="line">   transactionId = UUID.randomUUID().toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>调用 <code>ExecutorExceptionHandler.setExceptionThrown(false)</code> 设置执行 SQL 错误时，也不抛出异常。</p>
<ul>
<li>对异常处理的代码：<a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/884b38f4c2402e31464d15b444f4b405e07fe211/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/executor/threadlocal/ExecutorExceptionHandler.java#L59" rel="external nofollow noopener noreferrer" target="_blank">ExecutorExceptionHandler#setExceptionThrown()</a></li>
<li>对于其他 SQL，不会因为 SQL 错误不执行，会继续执行</li>
<li>对于上层业务，不会因为 SQL 错误终止逻辑，会继续执行。这里有一点要注意下，上层业务不能对该 SQL 执行结果有强依赖，因为 SQL 错误需要重试达到数据最终一致性</li>
<li>对于<strong>最大努力型事务</strong>( TCC暂未实现 )，会对执行错误的 SQL 进行重试</li>
</ul>
</li>
<li>
<p>调用 <code>connection.setAutoCommit(true);</code>，设置执行自动提交。<strong>使用最大努力型事务时，上层业务执行 SQL 会马上提交，即使调用  <code>Connection#rollback()</code> 也是无法回滚的，这点一定要注意。</strong></p>
</li>
</ul>
</li>
<li>
<p><code>#end()</code></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 结束柔性事务.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">  <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</div><div class="line">      ExecutorExceptionHandler.setExceptionThrown(<span class="keyword">true</span>);</div><div class="line">      connection.setAutoCommit(previousAutoCommit);</div><div class="line">      SoftTransactionManager.closeCurrentTransactionManager();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">// SoftTransactionManager.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 关闭当前的柔性事务管理器.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeCurrentTransactionManager</span><span class="params">()</span> </span>&#123;</div><div class="line">   ExecutorDataMap.getDataMap().put(TRANSACTION, <span class="keyword">null</span>);</div><div class="line">   ExecutorDataMap.getDataMap().put(TRANSACTION_CONFIG, <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>事务结束后，一定要记得调用 <code>#end()</code> 清理线程变量。否则，下次请求使用到该线程，会继续在这个柔性事务内。</li>
</ul>
</li>
</ul>
<p><strong>BEDSoftTransaction</strong></p>
<p>BEDSoftTransaction，最大努力送达型柔性事务。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BEDSoftTransaction</span> <span class="keyword">extends</span> <span class="title">AbstractSoftTransaction</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 开启柔性事务.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> connection 数据库连接对象</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(<span class="keyword">final</span> Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        beginInternal(connection, SoftTransactionType.BestEffortsDelivery);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>TCCSoftTransaction</strong></p>
<p>TCCSoftTransaction，TCC 型柔性事务，暂未实现。实现后，会更新到 <a href="http://www.yunai.me/Sharding-JDBC/transaction-tcc/?self">《Sharding-JDBC 源码分析 —— 分布式事务（二）之事务补偿型》</a>。</p>
<hr>
<h3>3.3.1 创建柔性事务</h3>
<p>通过调用 <code>SoftTransactionManager#getTransaction()</code> 创建柔性事务对象：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* &#123;<span class="doctag">@link</span> ExecutorDataMap#dataMap&#125; 柔性事务对象 key</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TRANSACTION = <span class="string">"transaction"</span>;</div><div class="line"><span class="comment">/**</span></div><div class="line">* &#123;<span class="doctag">@link</span> ExecutorDataMap#dataMap&#125; 柔性事务配置 key</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TRANSACTION_CONFIG = <span class="string">"transactionConfig"</span>;</div><div class="line"></div><div class="line"><span class="comment">// SoftTransactionManager.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 创建柔性事务.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> type 柔性事务类型</div><div class="line">* <span class="doctag">@return</span> 柔性事务</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> AbstractSoftTransaction <span class="title">getTransaction</span><span class="params">(<span class="keyword">final</span> SoftTransactionType type)</span> </span>&#123;</div><div class="line">   AbstractSoftTransaction result;</div><div class="line">   <span class="keyword">switch</span> (type) &#123;</div><div class="line">       <span class="keyword">case</span> BestEffortsDelivery: </div><div class="line">           result = <span class="keyword">new</span> BEDSoftTransaction();</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       <span class="keyword">case</span> TryConfirmCancel:</div><div class="line">           result = <span class="keyword">new</span> TCCSoftTransaction();</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       <span class="keyword">default</span>: </div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(type.toString());</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// TODO 目前使用不支持嵌套事务，以后这里需要可配置</span></div><div class="line">   <span class="keyword">if</span> (getCurrentTransaction().isPresent()) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Cannot support nested transaction."</span>);</div><div class="line">   &#125;</div><div class="line">   ExecutorDataMap.getDataMap().put(TRANSACTION, result);</div><div class="line">   ExecutorDataMap.getDataMap().put(TRANSACTION_CONFIG, transactionConfig);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>后续可以从 <a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/884b38f4c2402e31464d15b444f4b405e07fe211/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/executor/threadlocal/ExecutorDataMap.java" rel="external nofollow noopener noreferrer" target="_blank">ExecutorDataMap</a> 中获取当前线程的柔性事务和柔性事务配置：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SoftTransactionManager.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 获取当前线程的柔性事务配置.</div><div class="line">* </div><div class="line">* <span class="doctag">@return</span> 当前线程的柔性事务配置</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;SoftTransactionConfiguration&gt; <span class="title">getCurrentTransactionConfiguration</span><span class="params">()</span> </span>&#123;</div><div class="line">   Object transactionConfig = ExecutorDataMap.getDataMap().get(TRANSACTION_CONFIG);</div><div class="line">   <span class="keyword">return</span> (<span class="keyword">null</span> == transactionConfig)</div><div class="line">           ? Optional.&lt;SoftTransactionConfiguration&gt;absent()</div><div class="line">           : Optional.of((SoftTransactionConfiguration) transactionConfig);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">/**</span></div><div class="line">* 获取当前的柔性事务.</div><div class="line">* </div><div class="line">* <span class="doctag">@return</span> 当前的柔性事务</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;AbstractSoftTransaction&gt; <span class="title">getCurrentTransaction</span><span class="params">()</span> </span>&#123;</div><div class="line">   Object transaction = ExecutorDataMap.getDataMap().get(TRANSACTION);</div><div class="line">   <span class="keyword">return</span> (<span class="keyword">null</span> == transaction)</div><div class="line">           ? Optional.&lt;AbstractSoftTransaction&gt;absent()</div><div class="line">           : Optional.of((AbstractSoftTransaction) transaction);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
</ul>
<h1>4. 事务日志存储器</h1>
<p>柔性事务执行过程中，会通过事务日志( TransactionLog ) 记录每条 SQL 执行状态：</p>
<ul>
<li>SQL 执行前，记录一条事务日志</li>
<li>SQL 执行成功，移除对应的事务日志</li>
</ul>
<p>通过实现事务日志存储器接口( TransactionLogStorage )，提供存储功能。目前有两种实现：</p>
<ul>
<li>MemoryTransactionLogStorage ：基于<strong>内存</strong>的事务日志存储器。主要用于开发测试，<strong>生产环境下不要使用</strong>。</li>
<li>RdbTransactionLogStorage ：基于<strong>数据库</strong>的事务日志存储器。</li>
</ul>
<p>本节只分析 RdbTransactionLogStorage。对 <a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/884b38f4c2402e31464d15b444f4b405e07fe211/sharding-jdbc-transaction-parent/sharding-jdbc-transaction-storage/src/main/java/com/dangdang/ddframe/rdb/transaction/soft/storage/impl/RdbTransactionLogStorage.java" rel="external nofollow noopener noreferrer" target="_blank">MemoryTransactionLogStorage</a> 感兴趣的同学可以点击链接传送到达。</p>
<p><strong>TransactionLogStorage 有五个接口方法，下文每个小标题都是一个方法。</strong></p>
<h2>4.1 #add()</h2>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TransactionLogStorage.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 存储事务日志.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> transactionLog 事务日志</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(TransactionLog transactionLog)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// RdbTransactionLogStorage.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">final</span> TransactionLog transactionLog)</span> </span>&#123;</div><div class="line">   String sql = <span class="string">"INSERT INTO `transaction_log` (`id`, `transaction_type`, `data_source`, `sql`, `parameters`, `creation_time`) VALUES (?, ?, ?, ?, ?, ?);"</span>;</div><div class="line">   <span class="keyword">try</span> (</div><div class="line">    <span class="comment">// ... 省略你熟悉的代码</span></div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> TransactionLogStorageException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><strong>注意</strong>：如果插入事务日志<strong>失败</strong>，SQL 会继续执行，如果此时 SQL 执行失败，则该 SQL 会不见了。建议：<code>#add()</code> 和下文的 <code>#remove()</code> 异常时，都打印下异常日志都文件系统</li>
</ul>
<p>TransactionLog (transaction_log) 数据库表结构如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>名字</th>
<th>数据库类型</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>事件编号</td>
<td>VARCHAR(40)</td>
<td>EventBus 事件编号，<strong>非事务编号</strong></td>
</tr>
<tr>
<td>transaction_type</td>
<td>柔性事务类型</td>
<td>VARCHAR(30)</td>
<td></td>
</tr>
<tr>
<td>data_source</td>
<td>真实数据源名</td>
<td>VARCHAR(255)</td>
<td></td>
</tr>
<tr>
<td>sql</td>
<td>执行 SQL</td>
<td>TEXT</td>
<td>已经改写过的 SQL</td>
</tr>
<tr>
<td>parameters</td>
<td>占位符参数</td>
<td>TEXT</td>
<td>JSON 字符串存储</td>
</tr>
<tr>
<td>creation_time</td>
<td>记录时间</td>
<td>LONG</td>
<td></td>
</tr>
<tr>
<td>async_delivery_try_times</td>
<td>已异步重试次数</td>
<td>INT</td>
<td></td>
</tr>
</tbody>
</table>
<h2>4.2 #remove()</h2>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TransactionLogStorage.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 根据主键删除事务日志.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> id 事务日志主键</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(String id)</span></span>;</div><div class="line">    </div><div class="line"><span class="comment">// RdbTransactionLogStorage.java    </span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">final</span> String id)</span> </span>&#123;</div><div class="line">   String sql = <span class="string">"DELETE FROM `transaction_log` WHERE `id`=?;"</span>;</div><div class="line">   <span class="keyword">try</span> (</div><div class="line">          <span class="comment">// ... 省略你熟悉的代码</span></div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> TransactionLogStorageException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>4.3 #findEligibleTransactionLogs()</h2>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TransactionLogStorage.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 读取需要处理的事务日志.</div><div class="line">* </div><div class="line">* &lt;p&gt;需要处理的事务日志为: &lt;/p&gt;</div><div class="line">* &lt;p&gt;1. 异步处理次数小于最大处理次数.&lt;/p&gt;</div><div class="line">* &lt;p&gt;2. 异步处理的事务日志早于异步处理的间隔时间.&lt;/p&gt;</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> size 获取日志的数量</div><div class="line">* <span class="doctag">@param</span> maxDeliveryTryTimes 事务送达的最大尝试次数</div><div class="line">* <span class="doctag">@param</span> maxDeliveryTryDelayMillis 执行送达事务的延迟毫秒数.</div><div class="line">*/</div><div class="line"><span class="function">List&lt;TransactionLog&gt; <span class="title">findEligibleTransactionLogs</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> maxDeliveryTryTimes, <span class="keyword">long</span> maxDeliveryTryDelayMillis)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// RdbTransactionLogStorage.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;TransactionLog&gt; <span class="title">findEligibleTransactionLogs</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> size, <span class="keyword">final</span> <span class="keyword">int</span> maxDeliveryTryTimes, <span class="keyword">final</span> <span class="keyword">long</span> maxDeliveryTryDelayMillis)</span> </span>&#123;</div><div class="line">   List&lt;TransactionLog&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(size);</div><div class="line">   String sql = <span class="string">"SELECT `id`, `transaction_type`, `data_source`, `sql`, `parameters`, `creation_time`, `async_delivery_try_times` "</span></div><div class="line">       + <span class="string">"FROM `transaction_log` WHERE `async_delivery_try_times`&lt;? AND `transaction_type`=? AND `creation_time`&lt;? LIMIT ?;"</span>;</div><div class="line">   <span class="keyword">try</span> (Connection conn = dataSource.getConnection()) &#123;</div><div class="line">       <span class="comment">// ... 省略你熟悉的代码</span></div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> TransactionLogStorageException(ex);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>4.4 #increaseAsyncDeliveryTryTimes()</h2>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TransactionLogStorage.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 增加事务日志异步重试次数.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> id 事务主键</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">increaseAsyncDeliveryTryTimes</span><span class="params">(String id)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// RdbTransactionLogStorage.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increaseAsyncDeliveryTryTimes</span><span class="params">(<span class="keyword">final</span> String id)</span> </span>&#123;</div><div class="line">   String sql = <span class="string">"UPDATE `transaction_log` SET `async_delivery_try_times`=`async_delivery_try_times`+1 WHERE `id`=?;"</span>;</div><div class="line">   <span class="keyword">try</span> (</div><div class="line">       <span class="comment">// ... 省略你熟悉的代码</span></div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> TransactionLogStorageException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>4.5 #processData()</h2>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TransactionLogStorage.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 处理事务数据.</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> connection 业务数据库连接</div><div class="line">* <span class="doctag">@param</span> transactionLog 事务日志</div><div class="line">* <span class="doctag">@param</span> maxDeliveryTryTimes 事务送达的最大尝试次数</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">processData</span><span class="params">(Connection connection, TransactionLog transactionLog, <span class="keyword">int</span> maxDeliveryTryTimes)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// RdbTransactionLogStorage.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processData</span><span class="params">(<span class="keyword">final</span> Connection connection, <span class="keyword">final</span> TransactionLog transactionLog, <span class="keyword">final</span> <span class="keyword">int</span> maxDeliveryTryTimes)</span> </span>&#123;</div><div class="line">   <span class="comment">// 重试执行失败 SQL</span></div><div class="line">   <span class="keyword">try</span> (</div><div class="line">       Connection conn = connection;</div><div class="line">       PreparedStatement preparedStatement = conn.prepareStatement(transactionLog.getSql())) &#123;</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> parameterIndex = <span class="number">0</span>; parameterIndex &lt; transactionLog.getParameters().size(); parameterIndex++) &#123;</div><div class="line">           preparedStatement.setObject(parameterIndex + <span class="number">1</span>, transactionLog.getParameters().get(parameterIndex));</div><div class="line">       &#125;</div><div class="line">       preparedStatement.executeUpdate();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">       <span class="comment">// 重试失败，更新事务日志，增加已异步重试次数</span></div><div class="line">       increaseAsyncDeliveryTryTimes(transactionLog.getId());</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> TransactionCompensationException(ex);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 移除重试执行成功 SQL 对应的事务日志</span></div><div class="line">   remove(transactionLog.getId());</div><div class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>不同于前四个<strong>增删改查</strong>接口方法的实现，<code>#processData()</code> 是带有一些逻辑的。根据事务日志( TransactionLog )重试执行失败的 SQL，若成功，移除事务日志；若失败，更新事务日志，增加已异步重试次数</li>
<li>该方法会被<strong>最大努力送达型异步作业</strong>调用到</li>
</ul>
<h1>5. 最大努力送达型事务监听器</h1>
<p>最大努力送达型事务监听器，BestEffortsDeliveryListener，负责记录事务日志、同步重试执行失败 SQL。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// BestEffortsDeliveryListener.java</span></div><div class="line"><span class="meta">@Subscribe</span></div><div class="line"><span class="meta">@AllowConcurrentEvents</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(<span class="keyword">final</span> DMLExecutionEvent event)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (!isProcessContinuously()) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   SoftTransactionConfiguration transactionConfig = SoftTransactionManager.getCurrentTransactionConfiguration().get();</div><div class="line">   TransactionLogStorage transactionLogStorage = TransactionLogStorageFactory.createTransactionLogStorage(transactionConfig.buildTransactionLogDataSource());</div><div class="line">   BEDSoftTransaction bedSoftTransaction = (BEDSoftTransaction) SoftTransactionManager.getCurrentTransaction().get();</div><div class="line">   <span class="keyword">switch</span> (event.getEventExecutionType()) &#123;</div><div class="line">       <span class="keyword">case</span> BEFORE_EXECUTE: <span class="comment">// 执行前，插入事务日志</span></div><div class="line">           <span class="comment">//TODO 对于批量执行的SQL需要解析成两层列表</span></div><div class="line">           transactionLogStorage.add(<span class="keyword">new</span> TransactionLog(event.getId(), bedSoftTransaction.getTransactionId(), bedSoftTransaction.getTransactionType(), </div><div class="line">                   event.getDataSource(), event.getSql(), event.getParameters(), System.currentTimeMillis(), <span class="number">0</span>));</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       <span class="keyword">case</span> EXECUTE_SUCCESS: <span class="comment">// 执行成功，移除事务日志</span></div><div class="line">           transactionLogStorage.remove(event.getId());</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       <span class="keyword">case</span> EXECUTE_FAILURE: <span class="comment">// 执行失败，同步重试</span></div><div class="line">           <span class="keyword">boolean</span> deliverySuccess = <span class="keyword">false</span>;</div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; transactionConfig.getSyncMaxDeliveryTryTimes(); i++) &#123; <span class="comment">// 同步【多次】重试</span></div><div class="line">               <span class="keyword">if</span> (deliverySuccess) &#123;</div><div class="line">                   <span class="keyword">return</span>;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">boolean</span> isNewConnection = <span class="keyword">false</span>;</div><div class="line">               Connection conn = <span class="keyword">null</span>;</div><div class="line">               PreparedStatement preparedStatement = <span class="keyword">null</span>;</div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                   <span class="comment">// 获得数据库连接</span></div><div class="line">                   conn = bedSoftTransaction.getConnection().getConnection(event.getDataSource(), SQLType.DML);</div><div class="line">                   <span class="keyword">if</span> (!isValidConnection(conn)) &#123; <span class="comment">// 因为可能执行失败是数据库连接异常，所以判断一次，如果无效，重新获取数据库连接</span></div><div class="line">                       bedSoftTransaction.getConnection().release(conn);</div><div class="line">                       conn = bedSoftTransaction.getConnection().getConnection(event.getDataSource(), SQLType.DML);</div><div class="line">                       isNewConnection = <span class="keyword">true</span>;</div><div class="line">                   &#125;</div><div class="line">                   preparedStatement = conn.prepareStatement(event.getSql());</div><div class="line">                   <span class="comment">// 同步重试</span></div><div class="line">                   <span class="comment">//TODO 对于批量事件需要解析成两层列表</span></div><div class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> parameterIndex = <span class="number">0</span>; parameterIndex &lt; event.getParameters().size(); parameterIndex++) &#123;</div><div class="line">                       preparedStatement.setObject(parameterIndex + <span class="number">1</span>, event.getParameters().get(parameterIndex));</div><div class="line">                   &#125;</div><div class="line">                   preparedStatement.executeUpdate();</div><div class="line">                   deliverySuccess = <span class="keyword">true</span>;</div><div class="line">                   <span class="comment">// 同步重试成功，移除事务日志</span></div><div class="line">                   transactionLogStorage.remove(event.getId());</div><div class="line">               &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">                   log.error(String.format(<span class="string">"Delivery times %s error, max try times is %s"</span>, i + <span class="number">1</span>, transactionConfig.getSyncMaxDeliveryTryTimes()), ex);</div><div class="line">               &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                   close(isNewConnection, conn, preparedStatement);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       <span class="keyword">default</span>: </div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(event.getEventExecutionType().toString());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>BestEffortsDeliveryListener 通过 EventBus 实现监听 SQL 的执行。Sharding-JDBC 如何实现 EventBus 的，请看<a href="http://www.yunai.me/Sharding-JDBC/sql-execute/?self">《Sharding-JDBC 源码分析 —— SQL 执行》</a></p>
</li>
<li>
<p>调用 <code>#isProcessContinuously()</code> 方法判断是否处于<strong>最大努力送达型事务</strong>中，当且仅当处于该状态才进行监听事件处理</p>
</li>
<li>
<p>SQL 执行<strong>前</strong>，插入事务日志</p>
</li>
<li>
<p>SQL 执行<strong>成功</strong>，移除事务日志</p>
</li>
<li>
<p>SQL 执行<strong>失败</strong>，根据柔性事务配置( SoftTransactionConfiguration )同步的事务送达的最大尝试次数( <code>syncMaxDeliveryTryTimes</code> )进行多次重试<strong>直到成功</strong>。总体逻辑和 <code>RdbTransactionLogStorage#processData()</code> 方法逻辑类似，区别在于<strong>获取分片数据库连接</strong>的特殊处理：此处调用失败，数据库连接可能是异常无效的，因此调用了 <code>#isValidConnection()</code> 判断连接的<strong>有效性</strong>。若无效，则重新获取分片数据库连接。另外，若是重新获取分片数据库连接，需要进行关闭释放 (<code>Connection#close()</code>)：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// BestEffortsDeliveryListener.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 通过 SELECT 1 校验数据库连接是否有效</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> conn 数据库连接</div><div class="line">* <span class="doctag">@return</span> 是否有效</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidConnection</span><span class="params">(<span class="keyword">final</span> Connection conn)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> (PreparedStatement preparedStatement = conn.prepareStatement(<span class="string">"SELECT 1"</span>)) &#123;</div><div class="line">       <span class="keyword">try</span> (ResultSet rs = preparedStatement.executeQuery()) &#123;</div><div class="line">           <span class="keyword">return</span> rs.next() &amp;&amp; <span class="number">1</span> == rs.getInt(<span class="string">"1"</span>);</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 关闭释放预编译SQL对象和数据库连接</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> isNewConnection 是否新创建的数据库连接，是的情况下才释放</div><div class="line">* <span class="doctag">@param</span> conn 数据库连接</div><div class="line">* <span class="doctag">@param</span> preparedStatement 预编译SQL</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> isNewConnection, <span class="keyword">final</span> Connection conn, <span class="keyword">final</span> PreparedStatement preparedStatement)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != preparedStatement) &#123;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           preparedStatement.close();</div><div class="line">       &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">           log.error(<span class="string">"PreparedStatement closed error:"</span>, ex);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (isNewConnection &amp;&amp; <span class="keyword">null</span> != conn) &#123;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           conn.close();</div><div class="line">       &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">           log.error(<span class="string">"Connection closed error:"</span>, ex);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
</ul>
<h1>6. 最大努力送达型异步作业</h1>
<p>当最大努力送达型事务监听器( BestEffortsDeliveryListener )<strong>多次同步</strong>重试失败后，交给<strong>最大努力送达型异步作业</strong>进行<strong>多次异步</strong>重试，并且多次执行有<strong>固定间隔</strong>。</p>
<p>Sharding-JDBC 提供了两个最大努力送达型异步作业实现：</p>
<ul>
<li>NestedBestEffortsDeliveryJob ：内嵌的最大努力送达型异步作业</li>
<li>BestEffortsDeliveryJob ：最大努力送达型异步作业</li>
</ul>
<p>两者实现代码逻辑<strong>基本一致</strong>。前者相比后者，用于开发测试，去除对 Zookeeper 依赖，无法实现<strong>高可用</strong>，因此<strong>生产环境下不适合使用</strong>。</p>
<h2>6.1 BestEffortsDeliveryJob</h2>
<p>BestEffortsDeliveryJob 所在 Maven 项目为 <code>sharding-jdbc-transaction-async-job</code>，基于当当开源的 <a href="https://github.com/dangdangdotcom/elastic-job" rel="external nofollow noopener noreferrer" target="_blank">Elastic-Job</a> 实现。如下是官方对该 Maven 项目的简要说明：</p>
<blockquote>
<p>由于柔性事务采用异步尝试，需要部署独立的作业和Zookeeper。sharding-jdbc-transaction采用elastic-job实现的sharding-jdbc-transaction-async-job，通过简单配置即可启动高可用作业异步送达柔性事务，启动脚本为start.sh。</p>
</blockquote>
<p><strong>BestEffortsDeliveryJob</strong></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestEffortsDeliveryJob</span> <span class="keyword">extends</span> <span class="title">AbstractIndividualThroughputDataFlowElasticJob</span>&lt;<span class="title">TransactionLog</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 最大努力送达型异步作业配置对象</div><div class="line">     */</div><div class="line">    <span class="meta">@Setter</span></div><div class="line">    <span class="keyword">private</span> BestEffortsDeliveryConfiguration bedConfig;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 事务日志存储器对象</div><div class="line">     */</div><div class="line">    <span class="meta">@Setter</span></div><div class="line">    <span class="keyword">private</span> TransactionLogStorage transactionLogStorage;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;TransactionLog&gt; <span class="title">fetchData</span><span class="params">(<span class="keyword">final</span> JobExecutionMultipleShardingContext context)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> transactionLogStorage.findEligibleTransactionLogs(context.getFetchDataCount(),</div><div class="line">            bedConfig.getJobConfig().getMaxDeliveryTryTimes(), bedConfig.getJobConfig().getMaxDeliveryTryDelayMillis());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processData</span><span class="params">(<span class="keyword">final</span> JobExecutionMultipleShardingContext context, <span class="keyword">final</span> TransactionLog data)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> (</div><div class="line">            Connection conn = bedConfig.getTargetDataSource(data.getDataSource()).getConnection()) &#123;</div><div class="line">            transactionLogStorage.processData(conn, data, bedConfig.getJobConfig().getMaxDeliveryTryTimes());</div><div class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException | TransactionCompensationException ex) &#123;</div><div class="line">            log.error(String.format(<span class="string">"Async delivery times %s error, max try times is %s, exception is %s"</span>, data.getAsyncDeliveryTryTimes() + <span class="number">1</span>, </div><div class="line">                bedConfig.getJobConfig().getMaxDeliveryTryTimes(), ex.getMessage()));</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStreamingProcess</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>调用 <code>#fetchData()</code> 方法获取需要处理的事务日志 (TransactionLog)，内部调用了 <code>TransactionLogStorage#findEligibleTransactionLogs()</code> 方法</li>
<li>调用 <code>#processData()</code> 方法处理事务日志，重试执行失败的 SQL，内部调用了 <code>TransactionLogStorage#processData()</code></li>
<li><code>#fetchData()</code> 和 <code>#processData()</code> 调用是 Elastic-Job 控制的。每一轮定时调度，<strong>每条</strong>事务日志只执行<strong>一次</strong>。当<strong>超过</strong>最大异步调用次数后，该条事务日志不再处理，所以<strong>生产使用时，最好增加下相应监控超过最大异步重试次数的事务日志</strong>。</li>
</ul>
<h2>6.2 AsyncSoftTransactionJobConfiguration</h2>
<p>AsyncSoftTransactionJobConfiguration，异步柔性事务作业配置对象。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncSoftTransactionJobConfiguration</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业名称.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> String name = <span class="string">"bestEffortsDeliveryJob"</span>;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 触发作业的cron表达式.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> String cron = <span class="string">"0/5 * * * * ?"</span>;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 每次作业获取的事务日志最大数量.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> transactionLogFetchDataCount = <span class="number">100</span>;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 事务送达的最大尝试次数.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxDeliveryTryTimes = <span class="number">3</span>;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 执行事务的延迟毫秒数.</div><div class="line">     *</div><div class="line">     * &lt;p&gt;早于此间隔时间的入库事务才会被作业执行.&lt;/p&gt;</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> maxDeliveryTryDelayMillis = <span class="number">60</span>  * <span class="number">1000L</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>6.3 Elastic-Job 是否必须？</h2>
<p>Sharding-JDBC 提供的最大努力送达型异步作业实现( BestEffortsDeliveryJob )，通过与 Elastic-Job 集成，可以很便捷并且有质量保证的<strong>高可用</strong>、<strong>高性能</strong>使用。一部分团队，可能已经引入或自研了类似 Elastic-Job 的分布式作业中间件解决方案，每多一个中间件，就是多一个学习与运维成本。那么是否可以使用自己的分布式作业解决方案？答案是，可以的。参考 BestEffortsDeliveryJob 的实现，通过调用 TransactionLogStorage 来实现：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 伪代码(不考虑性能、异常)</span></div><div class="line">List&lt;TransactionLog&gt; transactionLogs = transactionLogStorage.findEligibleTransactionLogs(....);</div><div class="line"><span class="keyword">for</span> (TransactionLog transactionLog : transactionLogs) &#123;</div><div class="line">       transactionLogStorage.processData(conn, log, maxDeliveryTryTimes);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然，个人还是很推荐 Elastic-Job。</p>
<p>😈 <strong>笔者要开始写<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31_bak.jpg">《Elastic-Job 源码分析》</a></strong>。</p>
<hr>
<p>另外，如果有支持<strong>事务消息</strong>的分布式队列系统，可以通过 TransactionLogStorage 实现存储事务消息存储成消息。为什么要支持<strong>事务消息</strong>？如果 SQL 执行是成功的，需要回滚（删除）事务消息。</p>
<h1>7. 适用场景</h1>
<p>见<a href="http://dangdangdotcom.github.io/sharding-jdbc/02-guide/transaction/" rel="external nofollow noopener noreferrer" target="_blank">《官方文档 - 事务支持》</a>。</p>
<h1>8. 开发指南 &amp; 开发示例</h1>
<p>见<a href="http://dangdangdotcom.github.io/sharding-jdbc/02-guide/transaction/" rel="external nofollow noopener noreferrer" target="_blank">《官方文档 - 事务支持》</a>。</p>
<h1>666. 彩蛋</h1>
<p>哈哈哈</p>
<p>算是坚持把这个系列写完了，给自己 32 個赞。</p>
<p>满足！</p>
<p><a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31_bak.jpg">《Elastic-Job 源码分析》</a> 走起！不 High 不结束！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：&lt;/p&gt;
&lt;ol&gt;

    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— JDBC实现与读写分离</title>
    <link href="http://www.yunai.me/Sharding-JDBC/jdbc-implement-and-read-write-splitting/"/>
    <id>http://www.yunai.me/Sharding-JDBC/jdbc-implement-and-read-write-splitting/</id>
    <published>2017-08-17T16:00:00.000Z</published>
    <updated>2017-08-14T18:34:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<p><strong>本文主要基于 Sharding-JDBC 1.5.0 正式版</strong></p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. unspported 包</a></li>
<li><a href="#">3. adapter 包</a>
<ul>
<li><a href="#">3.1 WrapperAdapter</a></li>
<li><a href="#">3.2 AbstractDataSourceAdapter</a></li>
<li><a href="#">3.3 AbstractConnectionAdapter</a></li>
<li><a href="#">3.4 AbstractStatementAdapter</a></li>
<li><a href="#">3.5 AbstractPreparedStatementAdapter</a></li>
<li><a href="#">3.6 AbstractResultSetAdapter</a></li>
</ul>
</li>
<li><a href="#">4. 插入流程</a></li>
<li><a href="#">5. 查询流程</a></li>
<li><a href="#">6. 读写分离</a></li>
<li><a href="#">666. <s>彩蛋</s></a></li>
</ul>
<hr>
<h1>1. 概述</h1>
<p>本文主要分享 <strong>JDBC</strong> 与 <strong>读写分离</strong> 的实现。为什么会把这两个东西放在一起讲呢？客户端直连数据库的读写分离主要通过获取读库和写库的不同连接来实现，和 JDBC Connection 刚好放在一块。</p>
<p>OK，我们先来看一段 Sharding-JDBC 官方对自己的定义和定位</p>
<blockquote>
<p>Sharding-JDBC定位为轻量级java框架，使用客户端直连数据库，以jar包形式提供服务，未使用中间层，无需额外部署，无其他依赖，DBA也无需改变原有的运维方式，可理解为<strong>增强版的JDBC驱动</strong>，旧代码迁移成本几乎为零。</p>
</blockquote>
<p>可以看出，Sharding-JDBC 通过实现 <strong>JDBC规范</strong>，对上层提供透明化数据库分库分表的访问。😈 黑科技？实际我们使用的<strong>数据库连接池</strong>也是通过这种方式实现对上层无感知的提供连接池。甚至还可以通过这种方式实现对 Lucene、<a href="http://www.yunai.me/MyCAT/connect-mongodb/?self">MongoDB</a> 等等的访问。</p>
<p>扯远了，下面来看看 Sharding-JDBC <code>jdbc</code> 包的结构：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_18/01.png" alt=""></p>
<ul>
<li><code>unsupported</code>：声明<strong>不支持</strong>的数据操作方法</li>
<li><code>adapter</code>：适配类，实现和分库分表<strong>无关</strong>的方法</li>
<li><code>core</code>：核心类，实现和分库分表<strong>相关</strong>的方法</li>
</ul>
<p>根据 <code>core</code> 包，可以看出分到四种我们<strong>超级熟悉</strong>的对象</p>
<ul>
<li>
<p>Datasource</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_18/02.png" alt="-w640"></p>
</li>
<li>
<p>Connection</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_18/03.png" alt="-w640"></p>
</li>
<li>
<p>Statement</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_18/04.png" alt="-w640"></p>
</li>
<li>
<p>ResultSet</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_18/05.png" alt="-w640"></p>
</li>
</ul>
<p><strong>实现</strong>层级如下：<strong>JDBC 接口</strong> &lt;=(继承)== <strong><code>unsupported</code>抽象类</strong> &lt;=(继承)== <strong><code>unsupported</code>抽象类</strong> &lt;=(继承)== <strong><code>core</code>类</strong>。</p>
<hr>
<p><strong>本文内容顺序</strong></p>
<ol>
<li><code>unspported</code> 包</li>
<li><code>adapter</code> 包</li>
<li>插入流程，分析的类：
<ul>
<li>ShardingDataSource</li>
<li>ShardingConnection</li>
<li>ShardingPreparedStatement（ShardingStatement 类似，不重复分析）</li>
<li>GeneratedKeysResultSet、GeneratedKeysResultSetMetaData</li>
</ul>
</li>
<li>查询流程，分析的类：
<ul>
<li>ShardingPreparedStatement</li>
<li>ShardingResultSet</li>
</ul>
</li>
<li>读写分离，分析的类：
<ul>
<li>MasterSlaveDataSource</li>
</ul>
</li>
</ol>
<hr>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>
🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
<h1>2. unspported 包</h1>
<p><code>unspported</code> 包内的<strong>抽象</strong>类，声明不支持操作的数据对象，所有方法都是 <code>throw new SQLFeatureNotSupportedException()</code> 方式。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractUnsupportedGeneratedKeysResultSet</span> <span class="keyword">extends</span> <span class="title">AbstractUnsupportedOperationResultSet</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SQLFeatureNotSupportedException(<span class="string">"getBoolean"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// .... 省略其它类似方法</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractUnsupportedOperationConnection</span> <span class="keyword">extends</span> <span class="title">WrapperAdapter</span> <span class="keyword">implements</span> <span class="title">Connection</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> CallableStatement <span class="title">prepareCall</span><span class="params">(<span class="keyword">final</span> String sql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SQLFeatureNotSupportedException(<span class="string">"prepareCall"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">   <span class="comment">// .... 省略其它类似方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>3. adapter 包</h1>
<p><code>adapter</code> 包内的<strong>抽象</strong>类，实现和分库分表<strong>无关</strong>的方法。</p>
<p><strong>考虑到第4、5两小节更容易理解，本小节贴的代码会相对多</strong></p>
<h2>3.1 WrapperAdapter</h2>
<p><a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/d6ac50704f5e45beeeded09a4f0b160c7320b993/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/jdbc/adapter/WrapperAdapter.java" rel="external nofollow noopener noreferrer" target="_blank">WrapperAdapter</a>，JDBC Wrapper 适配类。</p>
<p><strong>对 Wrapper 接口实现如下两个方法</strong>：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;T&gt; <span class="function">T <span class="title">unwrap</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; iface)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">if</span> (isWrapperFor(iface)) &#123;</div><div class="line">       <span class="keyword">return</span> (T) <span class="keyword">this</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(String.format(<span class="string">"[%s] cannot be unwrapped as [%s]"</span>, getClass().getName(), iface.getName()));</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isWrapperFor</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; iface)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">return</span> iface.isInstance(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>提供子类 <code>#recordMethodInvocation()</code> 记录方法调用，<code>#replayMethodsInvocation()</code> 回放记录的方法调用</strong>：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 记录的方法数组</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Collection&lt;JdbcMethodInvocation&gt; jdbcMethodInvocations = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 记录方法调用.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> targetClass 目标类</div><div class="line">* <span class="doctag">@param</span> methodName 方法名称</div><div class="line">* <span class="doctag">@param</span> argumentTypes 参数类型</div><div class="line">* <span class="doctag">@param</span> arguments 参数</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">recordMethodInvocation</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; targetClass, <span class="keyword">final</span> String methodName, <span class="keyword">final</span> Class&lt;?&gt;[] argumentTypes, <span class="keyword">final</span> Object[] arguments)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       jdbcMethodInvocations.add(<span class="keyword">new</span> JdbcMethodInvocation(targetClass.getMethod(methodName, argumentTypes), arguments));</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> NoSuchMethodException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ShardingJdbcException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">/**</span></div><div class="line">* 回放记录的方法调用.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> target 目标对象</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">replayMethodsInvocation</span><span class="params">(<span class="keyword">final</span> Object target)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (JdbcMethodInvocation each : jdbcMethodInvocations) &#123;</div><div class="line">       each.invoke(target);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>这两个方法有什么用途呢？例如下文会提到的 AbstractConnectionAdapter 的 <code>#setAutoCommit()</code>，当它无数据库连接时，先记录；等获得到数据连接后，再回放：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractConnectionAdapter.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setAutoCommit</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> autoCommit)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">this</span>.autoCommit = autoCommit;</div><div class="line">   <span class="keyword">if</span> (getConnections().isEmpty()) &#123; <span class="comment">// 无数据连接时，记录方法调用</span></div><div class="line">       recordMethodInvocation(Connection.class, <span class="string">"setAutoCommit"</span>, <span class="keyword">new</span> Class[] &#123;<span class="keyword">boolean</span>.class&#125;, <span class="keyword">new</span> Object[] &#123;autoCommit&#125;);</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> (Connection each : getConnections()) &#123;</div><div class="line">       each.setAutoCommit(autoCommit);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
</ul>
<ul>
<li>
<p>JdbcMethodInvocation，反射调用JDBC相关方法的工具类：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcMethodInvocation</span> </span>&#123;</div><div class="line">    </div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 方法</div><div class="line">    */</div><div class="line">   <span class="meta">@Getter</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Method method;</div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 方法参数</div><div class="line">    */</div><div class="line">   <span class="meta">@Getter</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Object[] arguments;</div><div class="line">   </div><div class="line">   <span class="comment">/**</span></div><div class="line">    *  调用方法.</div><div class="line">    * </div><div class="line">    * <span class="doctag">@param</span> target 目标对象</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> Object target)</span> </span>&#123;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           method.invoke(target, arguments); <span class="comment">// 反射调用</span></div><div class="line">       &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IllegalAccessException | InvocationTargetException ex) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ShardingJdbcException(<span class="string">"Invoke jdbc method exception"</span>, ex);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
</ul>
<p><strong>提供子类 <code>#throwSQLExceptionIfNecessary()</code> 抛出异常链</strong>：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">throwSQLExceptionIfNecessary</span><span class="params">(<span class="keyword">final</span> Collection&lt;SQLException&gt; exceptions)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">if</span> (exceptions.isEmpty()) &#123; <span class="comment">// 为空不抛出异常</span></div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   SQLException ex = <span class="keyword">new</span> SQLException();</div><div class="line">   <span class="keyword">for</span> (SQLException each : exceptions) &#123;</div><div class="line">       ex.setNextException(each); <span class="comment">// 异常链</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">throw</span> ex;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>3.2 AbstractDataSourceAdapter</h2>
<p><a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/d6ac50704f5e45beeeded09a4f0b160c7320b993/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/jdbc/adapter/AbstractDataSourceAdapter.java" rel="external nofollow noopener noreferrer" target="_blank">AbstractDataSourceAdapter</a>，数据源适配类。</p>
<p>直接点击链接查看源码。</p>
<h2>3.3 AbstractConnectionAdapter</h2>
<p><a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/d6ac50704f5e45beeeded09a4f0b160c7320b993/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/jdbc/adapter/AbstractConnectionAdapter.java" rel="external nofollow noopener noreferrer" target="_blank">AbstractConnectionAdapter</a>，数据库连接适配类。</p>
<p>我们来瞅瞅大家最关心的<strong>事务</strong>相关方法的实现。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 是否自动提交</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> autoCommit = <span class="keyword">true</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 获得链接</div><div class="line">*</div><div class="line">* <span class="doctag">@return</span> 链接</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Collection&lt;Connection&gt; <span class="title">getConnections</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">getAutoCommit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">return</span> autoCommit;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setAutoCommit</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> autoCommit)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">this</span>.autoCommit = autoCommit;</div><div class="line">   <span class="keyword">if</span> (getConnections().isEmpty()) &#123; <span class="comment">// 无数据连接时，记录方法调用</span></div><div class="line">       recordMethodInvocation(Connection.class, <span class="string">"setAutoCommit"</span>, <span class="keyword">new</span> Class[] &#123;<span class="keyword">boolean</span>.class&#125;, <span class="keyword">new</span> Object[] &#123;autoCommit&#125;);</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> (Connection each : getConnections()) &#123;</div><div class="line">       each.setAutoCommit(autoCommit);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>#setAutoCommit()</code> 调用时，实际会设置其所持有的 Connection 的 <code>autoCommit</code> 属性</li>
<li><code>#getConnections()</code> 和分库分表相关，因而仅抽象该方法，留给子类实现</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">for</span> (Connection each : getConnections()) &#123;</div><div class="line">       each.commit();</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   Collection&lt;SQLException&gt; exceptions = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">   <span class="keyword">for</span> (Connection each : getConnections()) &#123;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           each.rollback();</div><div class="line">       &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">           exceptions.add(ex);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   throwSQLExceptionIfNecessary(exceptions);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p><code>#commit()</code>、<code>#rollback()</code> 调用时，实际调用其所持有的 Connection 的方法</p>
</li>
<li>
<p>异常情况下，<code>#commit()</code> 和 <code>#rollback()</code> 处理方式不同，笔者暂时不知道答案，求证后会进行更新</p>
<ul>
<li><code>#commit()</code> 处理方式需要改成和 <code>#rollback()</code> 一样。代码如下：</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   Collection&lt;SQLException&gt; exceptions = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">   <span class="keyword">for</span> (Connection each : getConnections()) &#123;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           each.commit();</div><div class="line">       &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">           exceptions.add(ex);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   throwSQLExceptionIfNecessary(exceptions);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
</ul>
<p>事务级别和是否只读相关代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 只读</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> readOnly = <span class="keyword">true</span>;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 事务级别</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> transactionIsolation = TRANSACTION_READ_UNCOMMITTED;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setReadOnly</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> readOnly)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">this</span>.readOnly = readOnly;</div><div class="line">   <span class="keyword">if</span> (getConnections().isEmpty()) &#123;</div><div class="line">       recordMethodInvocation(Connection.class, <span class="string">"setReadOnly"</span>, <span class="keyword">new</span> Class[] &#123;<span class="keyword">boolean</span>.class&#125;, <span class="keyword">new</span> Object[] &#123;readOnly&#125;);</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> (Connection each : getConnections()) &#123;</div><div class="line">       each.setReadOnly(readOnly);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setTransactionIsolation</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> level)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   transactionIsolation = level;</div><div class="line">   <span class="keyword">if</span> (getConnections().isEmpty()) &#123;</div><div class="line">       recordMethodInvocation(Connection.class, <span class="string">"setTransactionIsolation"</span>, <span class="keyword">new</span> Class[] &#123;<span class="keyword">int</span>.class&#125;, <span class="keyword">new</span> Object[] &#123;level&#125;);</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> (Connection each : getConnections()) &#123;</div><div class="line">       each.setTransactionIsolation(level);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>3.4 AbstractStatementAdapter</h2>
<p><a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/d6ac50704f5e45beeeded09a4f0b160c7320b993/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/jdbc/adapter/AbstractStatementAdapter.java" rel="external nofollow noopener noreferrer" target="_blank">AbstractStatementAdapter</a>，静态语句对象适配类。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getUpdateCount</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">long</span> result = <span class="number">0</span>;</div><div class="line">   <span class="keyword">boolean</span> hasResult = <span class="keyword">false</span>;</div><div class="line">   <span class="keyword">for</span> (Statement each : getRoutedStatements()) &#123;</div><div class="line">       <span class="keyword">if</span> (each.getUpdateCount() &gt; -<span class="number">1</span>) &#123;</div><div class="line">           hasResult = <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">       result += each.getUpdateCount();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (result &gt; Integer.MAX_VALUE) &#123;</div><div class="line">       result = Integer.MAX_VALUE;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> hasResult ? Long.valueOf(result).intValue() : -<span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 获取路由的静态语句对象集合.</div><div class="line">* </div><div class="line">* <span class="doctag">@return</span> 路由的静态语句对象集合</div><div class="line">*/</div><div class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> Collection&lt;? extends Statement&gt; getRoutedStatements();</div></pre></td></tr></table></figure></p>
<ul>
<li><code>#getUpdateCount()</code> 调用持有的 Statement 计算更新数量</li>
<li><code>#getRoutedStatements()</code> 和分库分表相关，因而仅抽象该方法，留给子类实现</li>
</ul>
<h2>3.5 AbstractPreparedStatementAdapter</h2>
<p><a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/d6ac50704f5e45beeeded09a4f0b160c7320b993/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/jdbc/adapter/AbstractPreparedStatementAdapter.java" rel="external nofollow noopener noreferrer" target="_blank">AbstractPreparedStatementAdapter</a>，预编译语句对象的适配类。</p>
<p><strong><code>#recordSetParameter()</code>实现对占位符参数的设置</strong>：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 记录的设置参数方法数组</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;SetParameterMethodInvocation&gt; setParameterMethodInvocations = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line"><span class="comment">/**</span></div><div class="line">* 参数</div><div class="line">*/</div><div class="line"><span class="meta">@Getter</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; parameters = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setInt</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> parameterIndex, <span class="keyword">final</span> <span class="keyword">int</span> x)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   setParameter(parameterIndex, x);</div><div class="line">   recordSetParameter(<span class="string">"setInt"</span>, <span class="keyword">new</span> Class[]&#123;<span class="keyword">int</span>.class, <span class="keyword">int</span>.class&#125;, parameterIndex, x);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 记录占位符参数</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> parameterIndex 占位符参数位置</div><div class="line">* <span class="doctag">@param</span> value 参数</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setParameter</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> parameterIndex, <span class="keyword">final</span> Object value)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (parameters.size() == parameterIndex - <span class="number">1</span>) &#123;</div><div class="line">       parameters.add(value);</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = parameters.size(); i &lt;= parameterIndex - <span class="number">1</span>; i++) &#123; <span class="comment">// 用 null 填充前面未设置的位置</span></div><div class="line">       parameters.add(<span class="keyword">null</span>);</div><div class="line">   &#125;</div><div class="line">   parameters.set(parameterIndex - <span class="number">1</span>, value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 记录设置参数方法调用</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> methodName 方法名，例如 setInt、setLong 等</div><div class="line">* <span class="doctag">@param</span> argumentTypes 参数类型</div><div class="line">* <span class="doctag">@param</span> arguments 参数</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recordSetParameter</span><span class="params">(<span class="keyword">final</span> String methodName, <span class="keyword">final</span> Class[] argumentTypes, <span class="keyword">final</span> Object... arguments)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       setParameterMethodInvocations.add(<span class="keyword">new</span> SetParameterMethodInvocation(PreparedStatement.class.getMethod(methodName, argumentTypes), arguments, arguments[<span class="number">1</span>]));</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> NoSuchMethodException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ShardingJdbcException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 回放记录的设置参数方法调用</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> preparedStatement 预编译语句对象</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">replaySetParameter</span><span class="params">(<span class="keyword">final</span> PreparedStatement preparedStatement)</span> </span>&#123;</div><div class="line">   addParameters();</div><div class="line">   <span class="keyword">for</span> (SetParameterMethodInvocation each : setParameterMethodInvocations) &#123;</div><div class="line">       updateParameterValues(each, parameters.get(each.getIndex() - <span class="number">1</span>)); <span class="comment">// 同一个位置多次设置，值可能不一样，需要更新下</span></div><div class="line">       each.invoke(preparedStatement);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 当使用分布式主键时，生成后会添加到 parameters，此时 parameters 数量多于 setParameterMethodInvocations，需要生成该分布式主键的 SetParameterMethodInvocation</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addParameters</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = setParameterMethodInvocations.size(); i &lt; parameters.size(); i++) &#123;</div><div class="line">       recordSetParameter(<span class="string">"setObject"</span>, <span class="keyword">new</span> Class[]&#123;<span class="keyword">int</span>.class, Object.class&#125;, i + <span class="number">1</span>, parameters.get(i));</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateParameterValues</span><span class="params">(<span class="keyword">final</span> SetParameterMethodInvocation setParameterMethodInvocation, <span class="keyword">final</span> Object value)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (!Objects.equals(setParameterMethodInvocation.getValue(), value)) &#123;</div><div class="line">       setParameterMethodInvocation.changeValueArgument(value); <span class="comment">// 修改占位符参数</span></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>逻辑类似 <code>WrapperAdapter</code> 的 <code>#recordMethodInvocation()</code>，<code>#replayMethodsInvocation()</code>，请<strong>认真</strong>阅读代码注释</p>
</li>
<li>
<p>SetParameterMethodInvocation，继承 JdbcMethodInvocation，反射调用参数设置方法的工具类：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SetParameterMethodInvocation</span> <span class="keyword">extends</span> <span class="title">JdbcMethodInvocation</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 位置</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> index;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 参数值</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object value;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置参数值.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> value 参数值</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeValueArgument</span><span class="params">(<span class="keyword">final</span> Object value)</span> </span>&#123;</div><div class="line">        getArguments()[<span class="number">1</span>] = value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
</ul>
<h2>3.6 AbstractResultSetAdapter</h2>
<p><a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/d6ac50704f5e45beeeded09a4f0b160c7320b993/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/jdbc/adapter/AbstractResultSetAdapter.java" rel="external nofollow noopener noreferrer" target="_blank">AbstractResultSetAdapter</a>，代理结果集适配器。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractResultSetAdapter</span> <span class="keyword">extends</span> <span class="title">AbstractUnsupportedOperationResultSet</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 结果集集合</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ResultSet&gt; resultSets;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="comment">// TODO should return sharding statement in future</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Statement <span class="title">getStatement</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">return</span> getResultSets().get(<span class="number">0</span>).getStatement();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ResultSetMetaData <span class="title">getMetaData</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">return</span> getResultSets().get(<span class="number">0</span>).getMetaData();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findColumn</span><span class="params">(<span class="keyword">final</span> String columnLabel)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">return</span> getResultSets().get(<span class="number">0</span>).findColumn(columnLabel);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// .... 省略其它方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>4. 插入流程</h1>
<p>插入使用<strong>分布式主键</strong>例子代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 代码仅仅是例子，生产环境下请注意异常处理和资源关闭</span></div><div class="line">String sql = <span class="string">"INSERT INTO t_order(uid, nickname, pid) VALUES (1, '2', ?)"</span>;</div><div class="line">DataSource dataSource = <span class="keyword">new</span> ShardingDataSource(shardingRule);</div><div class="line">Connection conn = dataSource.getConnection();</div><div class="line">PreparedStatement ps = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS); <span class="comment">// 返回主键需要  Statement.RETURN_GENERATED_KEYS</span></div><div class="line">ps.setLong(<span class="number">1</span>, <span class="number">100</span>);</div><div class="line">ps.executeUpdate();</div><div class="line">ResultSet rs = ps.getGeneratedKeys();</div><div class="line"><span class="keyword">if</span> (rs.next()) &#123;</div><div class="line">    System.out.println(<span class="string">"id:"</span> + rs.getLong(<span class="number">1</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>调用 <code>#executeUpdate()</code> 方法，内部过程如下</strong>：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_18/06.png" alt=""></p>
<p>是不是对上层<strong>完全透明</strong>？！我们来看看内部是怎么实现的。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingPreparedStatement.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       Collection&lt;PreparedStatementUnit&gt; preparedStatementUnits = route();</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> PreparedStatementExecutor(</div><div class="line">               getShardingConnection().getShardingContext().getExecutorEngine(), getRouteResult().getSqlStatement().getType(), preparedStatementUnits, getParameters()).executeUpdate();</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       clearBatch();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p><code>#route()</code> 分库分表路由，获得预编译语句对象执行单元( PreparedStatementUnit )集合。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PreparedStatementUnit</span> <span class="keyword">implements</span> <span class="title">BaseStatementUnit</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * SQL 执行单元</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SQLExecutionUnit sqlExecutionUnit;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 预编译语句对象</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PreparedStatement statement;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
<li>
<p><code>#executeUpdate()</code> 调用<a href="http://www.yunai.me/Sharding-JDBC/sql-execute/?self">执行引擎</a><strong>并行</strong>执行<strong>多个</strong>预编译语句对象。执行时，最终调用预编译语句对象( PreparedStatement )。我们来看一个例子：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// PreparedStatementExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">()</span> </span>&#123;</div><div class="line">   Context context = MetricsContext.start(<span class="string">"ShardingPreparedStatement-executeUpdate"</span>);</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       List&lt;Integer&gt; results = executorEngine.executePreparedStatement(sqlType, preparedStatementUnits, parameters, <span class="keyword">new</span> ExecuteCallback&lt;Integer&gt;() &#123;</div><div class="line">           </div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> Integer <span class="title">execute</span><span class="params">(<span class="keyword">final</span> BaseStatementUnit baseStatementUnit)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">               <span class="comment">// 调用 PreparedStatement#executeUpdate()</span></div><div class="line">               <span class="keyword">return</span> ((PreparedStatement) baseStatementUnit.getStatement()).executeUpdate();</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">       <span class="keyword">return</span> accumulate(results);</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       MetricsContext.stop(context);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
</ul>
<hr>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingPreparedStatement.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> Collection&lt;PreparedStatementUnit&gt; <span class="title">route</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   Collection&lt;PreparedStatementUnit&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">   <span class="comment">// 路由</span></div><div class="line">   setRouteResult(routingEngine.route(getParameters()));</div><div class="line">   <span class="comment">// 遍历 SQL 执行单元</span></div><div class="line">   <span class="keyword">for</span> (SQLExecutionUnit each : getRouteResult().getExecutionUnits()) &#123;</div><div class="line">       SQLType sqlType = getRouteResult().getSqlStatement().getType();</div><div class="line">       Collection&lt;PreparedStatement&gt; preparedStatements;</div><div class="line">       <span class="comment">// 创建实际的 PreparedStatement</span></div><div class="line">       <span class="keyword">if</span> (SQLType.DDL == sqlType) &#123;</div><div class="line">           preparedStatements = generatePreparedStatementForDDL(each);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           preparedStatements = Collections.singletonList(generatePreparedStatement(each));</div><div class="line">       &#125;</div><div class="line">       getRoutedStatements().addAll(preparedStatements);</div><div class="line">       <span class="comment">// 回放设置占位符参数到 PreparedStatement</span></div><div class="line">       <span class="keyword">for</span> (PreparedStatement preparedStatement : preparedStatements) &#123;</div><div class="line">           replaySetParameter(preparedStatement);</div><div class="line">           result.add(<span class="keyword">new</span> PreparedStatementUnit(each, preparedStatement));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 创建 PreparedStatement</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> sqlExecutionUnit SQL 执行单元</div><div class="line">* <span class="doctag">@return</span> PreparedStatement</div><div class="line">* <span class="doctag">@throws</span> SQLException 当 JDBC 操作发生异常时</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> PreparedStatement <span class="title">generatePreparedStatement</span><span class="params">(<span class="keyword">final</span> SQLExecutionUnit sqlExecutionUnit)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   Optional&lt;GeneratedKey&gt; generatedKey = getGeneratedKey();</div><div class="line">   <span class="comment">// 获得连接</span></div><div class="line">   Connection connection = getShardingConnection().getConnection(sqlExecutionUnit.getDataSource(), getRouteResult().getSqlStatement().getType());</div><div class="line">   <span class="comment">// 声明返回主键</span></div><div class="line">   <span class="keyword">if</span> (isReturnGeneratedKeys() || isReturnGeneratedKeys() &amp;&amp; generatedKey.isPresent()) &#123;</div><div class="line">       <span class="keyword">return</span> connection.prepareStatement(sqlExecutionUnit.getSql(), RETURN_GENERATED_KEYS);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> connection.prepareStatement(sqlExecutionUnit.getSql(), getResultSetType(), getResultSetConcurrency(), getResultSetHoldability());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>调用 <code>#generatePreparedStatement()</code> 创建 PreparedStatement，后调用 <code>#replaySetParameter()</code> 回放设置占位符参数到 PreparedStatement</p>
</li>
<li>
<p>当 <strong>声明返回主键</strong> 时，即 <code>#isReturnGeneratedKeys()</code> 返回 <code>true</code> 时，调用 <code>connection.prepareStatement(sqlExecutionUnit.getSql(), RETURN_GENERATED_KEYS)</code>。为什么该方法会返回 <code>true</code>？上文例子 <code>conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)</code></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingConnection.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">prepareStatement</span><span class="params">(<span class="keyword">final</span> String sql, <span class="keyword">final</span> String[] columnNames)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line"> <span class="keyword">return</span> <span class="keyword">new</span> ShardingPreparedStatement(<span class="keyword">this</span>, sql, Statement.RETURN_GENERATED_KEYS);</div><div class="line">&#125;</div><div class="line">   </div><div class="line"><span class="comment">// ShardingPreparedStatement.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ShardingPreparedStatement</span><span class="params">(<span class="keyword">final</span> ShardingConnection shardingConnection, <span class="keyword">final</span> String sql, <span class="keyword">final</span> <span class="keyword">int</span> autoGeneratedKeys)</span> </span>&#123;</div><div class="line"> <span class="keyword">this</span>(shardingConnection, sql);</div><div class="line"> <span class="keyword">if</span> (RETURN_GENERATED_KEYS == autoGeneratedKeys) &#123;</div><div class="line">     markReturnGeneratedKeys();</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">markReturnGeneratedKeys</span><span class="params">()</span> </span>&#123;</div><div class="line"> returnGeneratedKeys = <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>声明返回主键</strong>后，插入执行完成，我们调用 <code>#getGeneratedKeys()</code> 可以获得主键 ：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingStatement.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ResultSet <span class="title">getGeneratedKeys</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    Optional&lt;GeneratedKey&gt; generatedKey = getGeneratedKey();</div><div class="line">    <span class="comment">// 分布式主键</span></div><div class="line">    <span class="keyword">if</span> (generatedKey.isPresent() &amp;&amp; returnGeneratedKeys) &#123;</div><div class="line">         <span class="keyword">return</span> <span class="keyword">new</span> GeneratedKeysResultSet(routeResult.getGeneratedKeys().iterator(), generatedKey.get().getColumn(), <span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 数据库自增</span></div><div class="line">    <span class="keyword">if</span> (<span class="number">1</span> == getRoutedStatements().size()) &#123;</div><div class="line">        <span class="keyword">return</span> getRoutedStatements().iterator().next().getGeneratedKeys();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GeneratedKeysResultSet();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>调用 <code>ShardingConnection#getConnection()</code> 方法获得该 PreparedStatement 对应的<strong>真实</strong>数据库连接( Connection )：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingConnection.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 根据数据源名称获取相应的数据库连接.</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> dataSourceName 数据源名称</div><div class="line"> * <span class="doctag">@param</span> sqlType SQL语句类型</div><div class="line"> * <span class="doctag">@return</span> 数据库连接</div><div class="line"> * <span class="doctag">@throws</span> SQLException SQL异常</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(<span class="keyword">final</span> String dataSourceName, <span class="keyword">final</span> SQLType sqlType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    <span class="comment">// 从连接缓存中获取连接</span></div><div class="line">    Optional&lt;Connection&gt; connection = getCachedConnection(dataSourceName, sqlType);</div><div class="line">    <span class="keyword">if</span> (connection.isPresent()) &#123;</div><div class="line">        <span class="keyword">return</span> connection.get();</div><div class="line">    &#125;</div><div class="line">    Context metricsContext = MetricsContext.start(Joiner.on(<span class="string">"-"</span>).join(<span class="string">"ShardingConnection-getConnection"</span>, dataSourceName));</div><div class="line">    <span class="comment">//</span></div><div class="line">    DataSource dataSource = shardingContext.getShardingRule().getDataSourceRule().getDataSource(dataSourceName);</div><div class="line">    Preconditions.checkState(<span class="keyword">null</span> != dataSource, <span class="string">"Missing the rule of %s in DataSourceRule"</span>, dataSourceName);</div><div class="line">    String realDataSourceName;</div><div class="line">    <span class="keyword">if</span> (dataSource <span class="keyword">instanceof</span> MasterSlaveDataSource) &#123;</div><div class="line">        dataSource = ((MasterSlaveDataSource) dataSource).getDataSource(sqlType);</div><div class="line">        realDataSourceName = MasterSlaveDataSource.getDataSourceName(dataSourceName, sqlType);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        realDataSourceName = dataSourceName;</div><div class="line">    &#125;</div><div class="line">    Connection result = dataSource.getConnection();</div><div class="line">    MetricsContext.stop(metricsContext);</div><div class="line">    <span class="comment">// 添加到连接缓存</span></div><div class="line">    connectionMap.put(realDataSourceName, result);</div><div class="line">    <span class="comment">// 回放 Connection 方法</span></div><div class="line">    replayMethodsInvocation(result);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> Optional&lt;Connection&gt; <span class="title">getCachedConnection</span><span class="params">(<span class="keyword">final</span> String dataSourceName, <span class="keyword">final</span> SQLType sqlType)</span> </span>&#123;</div><div class="line">    String key = connectionMap.containsKey(dataSourceName) ? dataSourceName : MasterSlaveDataSource.getDataSourceName(dataSourceName, sqlType);</div><div class="line">    <span class="keyword">return</span> Optional.fromNullable(connectionMap.get(key));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>调用 <code>#getCachedConnection()</code> 尝试获得<strong>已缓存</strong>的数据库连接；如果缓存中不存在，获取到连接后会进行<strong>缓存</strong></li>
<li>从 ShardingRule 配置的 DataSourceRule 获取<strong>真实</strong>的数据源( DataSource )</li>
<li>MasterSlaveDataSource 实现<strong>主从</strong>数据源封装，我们在<em>下小节</em>分享</li>
<li>调用 <code>#replayMethodsInvocation()</code> 回放记录的 Connection 方法</li>
</ul>
</li>
</ul>
<p><em>插入实现的代码基本分享完了，因为是不断代码下钻的方式分析，可以反向向上在理理，会更加清晰</em>。</p>
<h1>5. 查询流程</h1>
<p>单纯从 <code>core</code> 包里的 JDBC 实现，查询流程 <code>#executeQuery()</code> 和 <code>#execute()</code> 基本一致，差别在于<strong>执行</strong>和<strong>多结果集归并</strong>。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ResultSet <span class="title">executeQuery</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   ResultSet result;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 路由</span></div><div class="line">       Collection&lt;PreparedStatementUnit&gt; preparedStatementUnits = route();</div><div class="line">       <span class="comment">// 执行</span></div><div class="line">       List&lt;ResultSet&gt; resultSets = <span class="keyword">new</span> PreparedStatementExecutor(</div><div class="line">               getShardingConnection().getShardingContext().getExecutorEngine(), getRouteResult().getSqlStatement().getType(), preparedStatementUnits, getParameters()).executeQuery();</div><div class="line">       <span class="comment">// 结果归并</span></div><div class="line">       result = <span class="keyword">new</span> ShardingResultSet(resultSets, <span class="keyword">new</span> MergeEngine(</div><div class="line">               getShardingConnection().getShardingContext().getDatabaseType(), resultSets, (SelectStatement) getRouteResult().getSqlStatement()).merge());</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       clearBatch();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 设置结果集</span></div><div class="line">   setCurrentResultSet(result);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p><strong>SQL执行</strong> 感兴趣的同学可以看：<a href="http://www.yunai.me/Sharding-JDBC/sql-execute/?self">《Sharding-JDBC 源码分析 —— SQL 执行》</a></p>
</li>
<li>
<p><strong>结果归并</strong> 感兴趣的同学可以看：<a href="http://www.yunai.me/Sharding-JDBC/result-merger/?self">《Sharding-JDBC 源码分析 —— 结果归并》</a></p>
</li>
<li>
<p>结果归并 <code>#merge()</code> 完后，创建分片结果集( ShardingResultSet )</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingResultSet</span> <span class="keyword">extends</span> <span class="title">AbstractResultSetAdapter</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 归并结果集</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResultSetMerger mergeResultSet;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        Object result = mergeResultSet.getValue(columnIndex, <span class="keyword">int</span>.class);</div><div class="line">        wasNull = <span class="keyword">null</span> == result;</div><div class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) ResultSetUtil.convertValue(result, <span class="keyword">int</span>.class);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(<span class="keyword">final</span> String columnLabel)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        Object result = mergeResultSet.getValue(columnLabel, <span class="keyword">int</span>.class);</div><div class="line">        wasNull = <span class="keyword">null</span> == result;</div><div class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) ResultSetUtil.convertValue(result, <span class="keyword">int</span>.class);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// .... 隐藏其他类似 getXXXX() 方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
</ul>
<h1>6. 读写分离</h1>
<p>建议前置阅读：<a href="http://dangdangdotcom.github.io/sharding-jdbc/02-guide/master-slave/" rel="external nofollow noopener noreferrer" target="_blank">《官方文档 —— 读写分离》</a></p>
<p>当你有读写分离的需求时，将 ShardingRule 配置<strong>对应的数据源</strong> 从 ShardingDataSource 替换成 MasterSlaveDataSource。我们来看看 MasterSlaveDataSource 的功能和实现。</p>
<p><strong>支持一主多从的读写分离配置，可配合分库分表使用</strong></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// MasterSlaveDataSourceFactory.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MasterSlaveDataSourceFactory</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建读写分离数据源.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> name 读写分离数据源名称</div><div class="line">     * <span class="doctag">@param</span> masterDataSource 主节点数据源</div><div class="line">     * <span class="doctag">@param</span> slaveDataSource 从节点数据源</div><div class="line">     * <span class="doctag">@param</span> otherSlaveDataSources 其他从节点数据源</div><div class="line">     * <span class="doctag">@return</span> 读写分离数据源</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title">createDataSource</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> DataSource masterDataSource, <span class="keyword">final</span> DataSource slaveDataSource, <span class="keyword">final</span> DataSource... otherSlaveDataSources)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MasterSlaveDataSource(name, masterDataSource, Lists.asList(slaveDataSource, otherSlaveDataSources));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// MasterSlaveDataSource.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MasterSlaveDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractDataSourceAdapter</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 数据源名</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 主数据源</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DataSource masterDataSource;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 从数据源集合</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;DataSource&gt; slaveDataSources;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>同一线程且同一数据库连接内，如有写入操作，以后的读操作均从主库读取，用于保证数据一致性。</strong></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingConnection.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(<span class="keyword">final</span> String dataSourceName, <span class="keyword">final</span> SQLType sqlType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="comment">// .... 省略部分代码</span></div><div class="line">   String realDataSourceName;</div><div class="line">   <span class="keyword">if</span> (dataSource <span class="keyword">instanceof</span> MasterSlaveDataSource) &#123; <span class="comment">// 读写分离</span></div><div class="line">       dataSource = ((MasterSlaveDataSource) dataSource).getDataSource(sqlType);</div><div class="line">       realDataSourceName = MasterSlaveDataSource.getDataSourceName(dataSourceName, sqlType);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       realDataSourceName = dataSourceName;</div><div class="line">   &#125;</div><div class="line">   Connection result = dataSource.getConnection();</div><div class="line">   <span class="comment">// .... 省略部分代码</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// MasterSlaveDataSource.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 当前线程是否是 DML 操作标识</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; DML_FLAG = <span class="keyword">new</span> ThreadLocal&lt;Boolean&gt;() &#123;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> Boolean <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 从库负载均衡策略</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> SlaveLoadBalanceStrategy slaveLoadBalanceStrategy = <span class="keyword">new</span> RoundRobinSlaveLoadBalanceStrategy();</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 获取主或从节点的数据源.</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> sqlType SQL类型</div><div class="line">* <span class="doctag">@return</span> 主或从节点的数据源</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">getDataSource</span><span class="params">(<span class="keyword">final</span> SQLType sqlType)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (isMasterRoute(sqlType)) &#123;</div><div class="line">       DML_FLAG.set(<span class="keyword">true</span>);</div><div class="line">       <span class="keyword">return</span> masterDataSource;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> slaveLoadBalanceStrategy.getDataSource(name, slaveDataSources);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMasterRoute</span><span class="params">(<span class="keyword">final</span> SQLType sqlType)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> SQLType.DQL != sqlType || DML_FLAG.get() || HintManagerHolder.isMasterRouteOnly();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>ShardingConnection 获取到的数据源是 MasterSlaveDataSource 时，调用 <code>MasterSlaveDataSource#getConnection()</code> 方法获取<strong>真实</strong>的数据源</p>
</li>
<li>
<p>通过 <code>#isMasterRoute()</code> 判断是否读取<strong>主库</strong>，以下三种情况会访问主库：</p>
<ul>
<li>非查询语句 (DQL)</li>
<li><strong>该</strong>数据源在<strong>当前</strong>线程访问过主库：通过线程变量 <code>DML_FLAG</code> 实现</li>
<li>强制主库：程序里调用 <code>HintManager.getInstance().setMasterRouteOnly()</code> 实现</li>
</ul>
</li>
<li>
<p>访问从库时，会通过负载均衡策略( SlaveLoadBalanceStrategy ) 选择一个从库</p>
<pre><code class="language-Java">// SlaveLoadBalanceStrategy.java
public interface SlaveLoadBalanceStrategy {
    
    /**
     * 根据负载均衡策略获取从库数据源.
     * 
     * @param name 读写分离数据源名称
     * @param slaveDataSources 从库数据源列表
     * @return 选中的从库数据源
     */
    DataSource getDataSource(String name, List&lt;DataSource&gt; slaveDataSources);
}

// RoundRobinSlaveLoadBalanceStrategy.java
public final class RoundRobinSlaveLoadBalanceStrategy implements SlaveLoadBalanceStrategy {
    
    private static final ConcurrentHashMap&lt;String, AtomicInteger&gt; COUNT_MAP = new ConcurrentHashMap&lt;&gt;();
    
    @Override
    public DataSource getDataSource(final String name, final List&lt;DataSource&gt; slaveDataSources) {
        AtomicInteger count = COUNT_MAP.containsKey(name) ? COUNT_MAP.get(name) : new AtomicInteger(0);
        COUNT_MAP.putIfAbsent(name, count);
        count.compareAndSet(slaveDataSources.size(), 0);
        return slaveDataSources.get(count.getAndIncrement() % slaveDataSources.size());
    }
}
</code></pre>
<ul>
<li>MasterSlaveDataSource 默认使用 RoundRobinSlaveLoadBalanceStrategy，暂时不支持配置</li>
<li>RoundRobinSlaveLoadBalanceStrategy，轮询负载均衡策略，<strong>每个从节点访问次数均衡，暂不支持数据源故障移除</strong></li>
</ul>
</li>
</ul>
<h1>666. 彩蛋</h1>
<p>没有彩蛋<br>
没有彩<br>
没有<br>
没</p>
<p>下一篇，<a href="http://www.yunai.me/Sharding-JDBC/transaction-bed/?self">《分布式事务（一）之最大努力型》</a>走起。老司机，赶紧上车。</p>
<p>道友，分享一个朋友圈可好？不然交个道姑那<s>敏感词</s>你。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：&lt;/p&gt;
&lt;ol&gt;

    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— 结果归并</title>
    <link href="http://www.yunai.me/Sharding-JDBC/result-merger/"/>
    <id>http://www.yunai.me/Sharding-JDBC/result-merger/</id>
    <published>2017-08-15T16:00:00.000Z</published>
    <updated>2017-08-14T18:34:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<p><strong>本文主要基于 Sharding-JDBC 1.5.0 正式版</strong></p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. MergeEngine</a>
<ul>
<li><a href="#">2.1 SelectStatement#setIndexForItems()</a></li>
<li><a href="#">2.2 ResultSetMerger</a>
<ul>
<li><a href="#">2.2.1 AbstractStreamResultSetMerger</a></li>
<li><a href="#">2.2.2 AbstractMemoryResultSetMerger</a></li>
<li><a href="#">2.2.3 AbstractDecoratorResultSetMerger</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#">3. OrderByStreamResultSetMerger</a>
<ul>
<li><a href="#">3.1 归并算法</a></li>
<li><a href="#">3.2 #next()</a></li>
</ul>
</li>
<li><a href="#">4. GroupByStreamResultSetMerger</a>
<ul>
<li><a href="#">4.1 AggregationUnit</a></li>
<li><a href="#">4.2 #next()</a></li>
</ul>
</li>
<li><a href="#">5. GroupByMemoryResultSetMerger</a>
<ul>
<li><a href="#">5.1 #next()</a></li>
</ul>
</li>
<li><a href="#">6. IteratorStreamResultSetMerger</a></li>
<li><a href="#">7. LimitDecoratorResultSetMerger</a></li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<h1>1. 概述</h1>
<p>本文分享<strong>查询结果归并</strong>的源码实现。</p>
<p>正如前文<a href="http://www.yunai.me/Sharding-JDBC/sql-execute/?self">《SQL 执行》</a>提到的**“分表分库，需要执行的 SQL 数量从单条变成了多条”<strong>，多个</strong>SQL执行**结果必然需要进行合并，例如：</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order <span class="keyword">ORDER</span> <span class="keyword">BY</span> create_time</div></pre></td></tr></table></figure></p>
<p>在各分片排序完后，Sharding-JDBC 获取到结果后，仍然需要再进一步排序。目前有 <strong>分页</strong>、<strong>分组</strong>、<strong>排序</strong>、<strong>聚合列</strong>、<strong>迭代</strong> 五种场景需要做进一步处理。当然，如果单分片<strong>SQL执行</strong>结果是无需合并的。在<a href="http://www.yunai.me/Sharding-JDBC/sql-execute/?self">《SQL 执行》</a>不知不觉已经分享了插入、更新、删除操作的结果合并，所以下面我们一起看看<strong>查询结果归并</strong>的实现。</p>
<hr>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>
🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
<h1>2. MergeEngine</h1>
<p>MergeEngine，分片结果集归并引擎。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// MergeEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 数据库类型</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> DatabaseType databaseType;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 结果集集合</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;ResultSet&gt; resultSets;</div><div class="line"><span class="comment">/**</span></div><div class="line">* Select SQL语句对象</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> SelectStatement selectStatement;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 查询列名与位置映射</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Integer&gt; columnLabelIndexMap;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MergeEngine</span><span class="params">(<span class="keyword">final</span> DatabaseType databaseType, <span class="keyword">final</span> List&lt;ResultSet&gt; resultSets, <span class="keyword">final</span> SelectStatement selectStatement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">this</span>.databaseType = databaseType;</div><div class="line">   <span class="keyword">this</span>.resultSets = resultSets;</div><div class="line">   <span class="keyword">this</span>.selectStatement = selectStatement;</div><div class="line">   <span class="comment">// 获得 查询列名与位置映射</span></div><div class="line">   columnLabelIndexMap = getColumnLabelIndexMap(resultSets.get(<span class="number">0</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 获得 查询列名与位置映射</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> resultSet 结果集</div><div class="line">* <span class="doctag">@return</span> 查询列名与位置映射</div><div class="line">* <span class="doctag">@throws</span> SQLException 当结果集已经关闭</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> Map&lt;String, Integer&gt; <span class="title">getColumnLabelIndexMap</span><span class="params">(<span class="keyword">final</span> ResultSet resultSet)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   ResultSetMetaData resultSetMetaData = resultSet.getMetaData(); <span class="comment">// 元数据（包含查询列信息）</span></div><div class="line">   Map&lt;String, Integer&gt; result = <span class="keyword">new</span> TreeMap&lt;&gt;(String.CASE_INSENSITIVE_ORDER);</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= resultSetMetaData.getColumnCount(); i++) &#123;</div><div class="line">       result.put(SQLUtil.getExactlyValue(resultSetMetaData.getColumnLabel(i)), i);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>当 MergeEngine 被创建时，会传入 <code>resultSets</code> 结果集集合，并根据其获得 <code>columnLabelIndexMap</code> 查询列名与位置映射。通过 <code>columnLabelIndexMap</code>，可以很方便的使用查询列名获得在返回结果记录列( header )的第几列。</li>
</ul>
<hr>
<p>MergeEngine 的 <code>#merge()</code> 方法作为入口提供<strong>查询结果归并</strong>功能。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 合并结果集.</div><div class="line">*</div><div class="line">* <span class="doctag">@return</span> 归并完毕后的结果集</div><div class="line">* <span class="doctag">@throws</span> SQLException SQL异常</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> ResultSetMerger <span class="title">merge</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   selectStatement.setIndexForItems(columnLabelIndexMap);</div><div class="line">   <span class="keyword">return</span> decorate(build());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>#merge()</code> 主体逻辑就两行代码，设置查询列位置信息，并返回<strong>合适</strong>的归并结果集接口( ResultSetMerger ) 实现。</li>
</ul>
<h2>2.1 SelectStatement#setIndexForItems()</h2>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SelectStatement.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 为选择项设置索引.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> columnLabelIndexMap 列标签索引字典</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIndexForItems</span><span class="params">(<span class="keyword">final</span> Map&lt;String, Integer&gt; columnLabelIndexMap)</span> </span>&#123;</div><div class="line">   setIndexForAggregationItem(columnLabelIndexMap);</div><div class="line">   setIndexForOrderItem(columnLabelIndexMap, orderByItems);</div><div class="line">   setIndexForOrderItem(columnLabelIndexMap, groupByItems);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>部分<strong>查询列</strong>是经过<strong>推到</strong>出来，在 <strong>SQL解析</strong> 过程中，未获得到查询列位置，需要通过该方法进行初始化。对这块不了解的同学，回头可以看下<a href="http://www.yunai.me/Sharding-JDBC/sql-parse-3/?self">《SQL 解析（三）之查询SQL》</a>。🙂 现在不用回头，皇冠会掉。</p>
</li>
<li>
<p><code>#setIndexForAggregationItem()</code> 处理 <strong>AVG聚合计算列</strong> 推导出其对应的 <strong>SUM/COUNT 聚合计算列</strong>的位置：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setIndexForAggregationItem</span><span class="params">(<span class="keyword">final</span> Map&lt;String, Integer&gt; columnLabelIndexMap)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (AggregationSelectItem each : getAggregationSelectItems()) &#123;</div><div class="line">       Preconditions.checkState(columnLabelIndexMap.containsKey(each.getColumnLabel()), String.format(<span class="string">"Can't find index: %s, please add alias for aggregate selections"</span>, each));</div><div class="line">       each.setIndex(columnLabelIndexMap.get(each.getColumnLabel()));</div><div class="line">       <span class="keyword">for</span> (AggregationSelectItem derived : each.getDerivedAggregationSelectItems()) &#123;</div><div class="line">           Preconditions.checkState(columnLabelIndexMap.containsKey(derived.getColumnLabel()), String.format(<span class="string">"Can't find index: %s"</span>, derived));</div><div class="line">           derived.setIndex(columnLabelIndexMap.get(derived.getColumnLabel()));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
<li>
<p><code>#setIndexForOrderItem()</code> 处理 <strong>ORDER BY / GROUP BY 列不在查询列</strong> 推导出的<strong>查询列</strong>的位置：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setIndexForOrderItem</span><span class="params">(<span class="keyword">final</span> Map&lt;String, Integer&gt; columnLabelIndexMap, <span class="keyword">final</span> List&lt;OrderItem&gt; orderItems)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (OrderItem each : orderItems) &#123;</div><div class="line">      <span class="keyword">if</span> (-<span class="number">1</span> != each.getIndex()) &#123;</div><div class="line">          <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      Preconditions.checkState(columnLabelIndexMap.containsKey(each.getColumnLabel()), String.format(<span class="string">"Can't find index: %s"</span>, each));</div><div class="line">      <span class="keyword">if</span> (columnLabelIndexMap.containsKey(each.getColumnLabel())) &#123;</div><div class="line">          each.setIndex(columnLabelIndexMap.get(each.getColumnLabel()));</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
</ul>
<h2>2.2 ResultSetMerger</h2>
<p>ResultSetMerger，归并结果集接口。</p>
<p>我们先来看看整体的类结构关系：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_16/04.png" alt=""></p>
<p>从 <strong>功能</strong> 上分成四种：</p>
<ul>
<li>分组：GroupByMemoryResultSetMerger、GroupByStreamResultSetMerger；包含<strong>聚合列</strong></li>
<li>排序：OrderByStreamResultSetMerger</li>
<li>迭代：IteratorStreamResultSetMerger</li>
<li>分页：LimitDecoratorResultSetMerger</li>
</ul>
<p>从 <strong>实现方式</strong> 上分成三种：</p>
<ul>
<li>Stream 流式：AbstractStreamResultSetMerger</li>
<li>Memory 内存：AbstractMemoryResultSetMerger</li>
<li>Decorator 装饰者：AbstractDecoratorResultSetMerger</li>
</ul>
<p><strong>什么时候该用什么实现方式？</strong></p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_16/06.png" alt=""></p>
<ul>
<li>Stream 流式：将数据游标与结果集的游标保持一致，顺序的从结果集中一条条的获取正确的数据。看完下文<em>第三节</em> OrderByStreamResultSetMerger 可以形象的理解。</li>
<li>Memory 内存：需要将结果集的所有数据都遍历并存储在内存中，再通过内存归并后，将内存中的数据伪装成结果集返回。看完下文<em>第五节</em> GroupByMemoryResultSetMerger 可以形象的理解。</li>
<li>Decorator 装饰者：可以和前二者任意组合</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// MergeEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 合并结果集.</div><div class="line">*</div><div class="line">* <span class="doctag">@return</span> 归并完毕后的结果集</div><div class="line">* <span class="doctag">@throws</span> SQLException SQL异常</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> ResultSetMerger <span class="title">merge</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   selectStatement.setIndexForItems(columnLabelIndexMap);</div><div class="line">   <span class="keyword">return</span> decorate(build());</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> ResultSetMerger <span class="title">build</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">if</span> (!selectStatement.getGroupByItems().isEmpty() || !selectStatement.getAggregationSelectItems().isEmpty()) &#123; <span class="comment">// 分组 或 聚合列</span></div><div class="line">       <span class="keyword">if</span> (selectStatement.isSameGroupByAndOrderByItems()) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">new</span> GroupByStreamResultSetMerger(columnLabelIndexMap, resultSets, selectStatement, getNullOrderType());</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">new</span> GroupByMemoryResultSetMerger(columnLabelIndexMap, resultSets, selectStatement, getNullOrderType());</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (!selectStatement.getOrderByItems().isEmpty()) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> OrderByStreamResultSetMerger(resultSets, selectStatement.getOrderByItems(), getNullOrderType());</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> IteratorStreamResultSetMerger(resultSets);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> ResultSetMerger <span class="title">decorate</span><span class="params">(<span class="keyword">final</span> ResultSetMerger resultSetMerger)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   ResultSetMerger result = resultSetMerger;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != selectStatement.getLimit()) &#123;</div><div class="line">       result = <span class="keyword">new</span> LimitDecoratorResultSetMerger(result, selectStatement.getLimit());</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3>2.2.1 AbstractStreamResultSetMerger</h3>
<p>AbstractStreamResultSetMerger，<strong>流式</strong>归并结果集抽象类，提供从<strong>当前结果集</strong>获得行数据。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStreamResultSetMerger</span> <span class="keyword">implements</span> <span class="title">ResultSetMerger</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 当前结果集</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> ResultSet currentResultSet;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">protected</span> ResultSet <span class="title">getCurrentResultSet</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == currentResultSet) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"Current ResultSet is null, ResultSet perhaps end of next."</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> currentResultSet;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> columnIndex, <span class="keyword">final</span> Class&lt;?&gt; type)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (Object.class == type) &#123;</div><div class="line">            <span class="keyword">return</span> getCurrentResultSet().getObject(columnIndex);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">int</span>.class == type) &#123;</div><div class="line">            <span class="keyword">return</span> getCurrentResultSet().getInt(columnIndex);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (String.class == type) &#123;</div><div class="line">            <span class="keyword">return</span> getCurrentResultSet().getString(columnIndex);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// .... 省略其他数据类型读取类似代码</span></div><div class="line">        <span class="keyword">return</span> getCurrentResultSet().getObject(columnIndex);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3>2.2.2 AbstractMemoryResultSetMerger</h3>
<p>AbstractMemoryResultSetMerger，<strong>内存</strong>归并结果集抽象类，提供从<strong>内存数据行对象( MemoryResultSetRow )</strong> 获得行数据。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractMemoryResultSetMerger</span> <span class="keyword">implements</span> <span class="title">ResultSetMerger</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Integer&gt; labelAndIndexMap;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 内存数据行对象</div><div class="line">     */</div><div class="line">    <span class="meta">@Setter</span></div><div class="line">    <span class="keyword">private</span> MemoryResultSetRow currentResultSetRow;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> columnIndex, <span class="keyword">final</span> Class&lt;?&gt; type)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (Blob.class == type || Clob.class == type || Reader.class == type || InputStream.class == type || SQLXML.class == type) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SQLFeatureNotSupportedException();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> currentResultSetRow.getCell(columnIndex);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>和 AbstractStreamResultSetMerger 对比，貌似区别不大？！确实，从抽象父类上看，两种实现方式差不多。抽象父类提供给实现子类的是<strong>数据读取</strong>的功能，真正的流式归并、内存归并是在子类实现上体现。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryResultSetRow</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 行数据</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] data;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MemoryResultSetRow</span><span class="params">(<span class="keyword">final</span> ResultSet resultSet)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        data = load(resultSet);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 加载 ResultSet 当前行数据到内存</div><div class="line">     * <span class="doctag">@param</span> resultSet 结果集</div><div class="line">     * <span class="doctag">@return</span> 行数据</div><div class="line">     * <span class="doctag">@throws</span> SQLException 当结果集关闭</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Object[] load(<span class="keyword">final</span> ResultSet resultSet) <span class="keyword">throws</span> SQLException &#123;</div><div class="line">        <span class="keyword">int</span> columnCount = resultSet.getMetaData().getColumnCount();</div><div class="line">        Object[] result = <span class="keyword">new</span> Object[columnCount];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; i++) &#123;</div><div class="line">            result[i] = resultSet.getObject(i + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取数据.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> columnIndex 列索引</div><div class="line">     * <span class="doctag">@return</span> 数据</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getCell</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> columnIndex)</span> </span>&#123;</div><div class="line">        Preconditions.checkArgument(columnIndex &gt; <span class="number">0</span> &amp;&amp; columnIndex &lt; data.length + <span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> data[columnIndex - <span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置数据.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> columnIndex 列索引</div><div class="line">     * <span class="doctag">@param</span> value 值</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCell</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> columnIndex, <span class="keyword">final</span> Object value)</span> </span>&#123;</div><div class="line">        Preconditions.checkArgument(columnIndex &gt; <span class="number">0</span> &amp;&amp; columnIndex &lt; data.length + <span class="number">1</span>);</div><div class="line">        data[columnIndex - <span class="number">1</span>] = value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>调用 <code>#load()</code> 方法，将当前结果集的一条行数据加载到内存。</li>
</ul>
<h3>2.2.3 AbstractDecoratorResultSetMerger</h3>
<p>AbstractDecoratorResultSetMerger，装饰结果集归并抽象类，通过调用<strong>其装饰的归并对象</strong> <code>#getValue()</code> 方法获得行数据。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDecoratorResultSetMerger</span> <span class="keyword">implements</span> <span class="title">ResultSetMerger</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 装饰的归并对象</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResultSetMerger resultSetMerger;</div><div class="line">        </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> columnIndex, <span class="keyword">final</span> Class&lt;?&gt; type)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">return</span> resultSetMerger.getValue(columnIndex, type);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>3. OrderByStreamResultSetMerger</h1>
<p>OrderByStreamResultSetMerger，基于 <strong>Stream</strong> 方式排序归并结果集实现。</p>
<h2>3.1 归并算法</h2>
<p>因为<strong>各个分片结果集已经排序完成</strong>，使用**<a href="https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" rel="external nofollow noopener noreferrer" target="_blank">《归并算法》</a>**能够充分利用这个优势。</p>
<blockquote>
<p>归并操作（merge），也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。</p>
<p>【迭代法】</p>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>
<li>重复步骤3直到某一指针到达序列尾</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾</li>
</ol>
</blockquote>
<p>从定义上看，是不是超级符合我们这个场景。😈 此时此刻，你是不是捂着胸口，感叹：“大学怎么没好好学数据结构与算法呢”？反正我是捂着了，都是眼泪。</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_16/01.jpg" alt=""></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderByStreamResultSetMerger</span> <span class="keyword">extends</span> <span class="title">AbstractStreamResultSetMerger</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 排序列</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span>(AccessLevel.NONE)</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;OrderItem&gt; orderByItems;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 排序值对象队列</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;OrderByValue&gt; orderByValuesQueue;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 默认排序类型</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OrderType nullOrderType;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 是否第一个 ResultSet 已经调用 #next()</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isFirstNext;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderByStreamResultSetMerger</span><span class="params">(<span class="keyword">final</span> List&lt;ResultSet&gt; resultSets, <span class="keyword">final</span> List&lt;OrderItem&gt; orderByItems, <span class="keyword">final</span> OrderType nullOrderType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">this</span>.orderByItems = orderByItems;</div><div class="line">        <span class="keyword">this</span>.orderByValuesQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(resultSets.size());</div><div class="line">        <span class="keyword">this</span>.nullOrderType = nullOrderType;</div><div class="line">        orderResultSetsToQueue(resultSets);</div><div class="line">        isFirstNext = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">orderResultSetsToQueue</span><span class="params">(<span class="keyword">final</span> List&lt;ResultSet&gt; resultSets)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">for</span> (ResultSet each : resultSets) &#123;</div><div class="line">            OrderByValue orderByValue = <span class="keyword">new</span> OrderByValue(each, orderByItems, nullOrderType);</div><div class="line">            <span class="keyword">if</span> (orderByValue.next()) &#123;</div><div class="line">                orderByValuesQueue.offer(orderByValue);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 设置当前 ResultSet，这样 #getValue() 能拿到记录</span></div><div class="line">        setCurrentResultSet(orderByValuesQueue.isEmpty() ? resultSets.get(<span class="number">0</span>) : orderByValuesQueue.peek().getResultSet());</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>属性 <code>orderByValuesQueue</code> 使用的队列实现是<strong>优先级</strong>队列( PriorityQueue )。有兴趣的同学可以看看<a href="http://wlh0706-163-com.iteye.com/blog/1850125" rel="external nofollow noopener noreferrer" target="_blank">《JDK源码研究PriorityQueue》</a>，本文不展开讲，不是主角戏份不多。我们记住几个方法的用途：</p>
<ul>
<li><code>#offer()</code>：增加元素。增加时，会将该元素和已有元素们按照<strong>优先级</strong>进行排序</li>
<li><code>#peek()</code>：获得优先级第一的元素</li>
<li><code>#pool()</code>：获得优先级第一的元素<strong>并移除</strong></li>
</ul>
</li>
<li>
<p>一个 ResultSet 构建一个 OrderByValue 用于排序，即上文<strong>归并算法</strong>提到的**“空间”**。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderByValue</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">OrderByValue</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 已排序结果集</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResultSet resultSet;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 排序列</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;OrderItem&gt; orderByItems;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 默认排序类型</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OrderType nullOrderType;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 排序列对应的值数组</div><div class="line">     * 因为一条记录可能有多个排序列，所以是数组</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> List&lt;Comparable&lt;?&gt;&gt; orderValues;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 遍历下一个结果集游标.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@return</span> 是否有下一个结果集</div><div class="line">     * <span class="doctag">@throws</span> SQLException SQL异常</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> result = resultSet.next();</div><div class="line">        orderValues = result ? getOrderValues() : Collections.&lt;Comparable&lt;?&gt;&gt;emptyList();</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获得 排序列对应的值数组</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> 排序列对应的值数组</div><div class="line">     * <span class="doctag">@throws</span> SQLException 当结果集关闭时</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> List&lt;Comparable&lt;?&gt;&gt; getOrderValues() <span class="keyword">throws</span> SQLException &#123;</div><div class="line">        List&lt;Comparable&lt;?&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(orderByItems.size());</div><div class="line">        <span class="keyword">for</span> (OrderItem each : orderByItems) &#123;</div><div class="line">            Object value = resultSet.getObject(each.getIndex());</div><div class="line">            Preconditions.checkState(<span class="keyword">null</span> == value || value <span class="keyword">instanceof</span> Comparable, <span class="string">"Order by value must implements Comparable"</span>);</div><div class="line">            result.add((Comparable&lt;?&gt;) value);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 对比 &#123;<span class="doctag">@link</span> #orderValues&#125;，即两者的第一条记录</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> o 对比 OrderByValue</div><div class="line">     * <span class="doctag">@return</span> -1 0 1</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(<span class="keyword">final</span> OrderByValue o)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; orderByItems.size(); i++) &#123;</div><div class="line">            OrderItem thisOrderBy = orderByItems.get(i);</div><div class="line">            <span class="keyword">int</span> result = ResultSetUtil.compareTo(orderValues.get(i), o.orderValues.get(i), thisOrderBy.getType(), nullOrderType);</div><div class="line">            <span class="keyword">if</span> (<span class="number">0</span> != result) &#123;</div><div class="line">                <span class="keyword">return</span> result;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>调用 <code>OrderByValue#next()</code> 方法时，获得其对应结果集<strong>排在第一条</strong>的记录，通过 <code>#getOrderValues()</code> 计算该记录的排序字段值。这样<strong>两个OrderByValue</strong> 通过 <code>#compareTo()</code> 方法可以比较<strong>两个结果集</strong>的第一条记录。</li>
</ul>
</li>
<li>
<p><code>if (orderByValue.next()) {</code> 处，调用 <code>OrderByValue#next()</code> 后，添加到 PriorityQueue。因此，<code>orderByValuesQueue.peek().getResultSet()</code> 能够获得多个 ResultSet 中排在第一的。</p>
</li>
</ul>
<h2>3.2 #next()</h2>
<p>通过调用 <code>OrderByStreamResultSetMerger#next()</code> 不断获得当前排在第一的记录。<code>#next()</code> 每次调用后，实际做的是当前 ResultSet 的替换，以及当前的 ResultSet 的记录指向下一条。这样说起来可能比较绕，我们来看一张图：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_16/02.png" alt=""></p>
<ul>
<li>白色向下箭头：OrderByStreamResultSetMerger 对 ResultSet 的指向。</li>
<li>黑色箭头：ResultSet 对当前记录的指向。</li>
<li>ps：这块如果分享的不清晰让您费劲，十分抱歉。欢迎加我微信（wangwenbin-server）交流下，这样我也可以优化表述。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// OrderByStreamResultSetMerger.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">if</span> (orderByValuesQueue.isEmpty()) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (isFirstNext) &#123;</div><div class="line">       isFirstNext = <span class="keyword">false</span>;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 移除上一次获得的 ResultSet</span></div><div class="line">   OrderByValue firstOrderByValue = orderByValuesQueue.poll();</div><div class="line">   <span class="comment">// 如果上一次获得的 ResultSet还有下一条记录，继续添加到 排序值对象队列</span></div><div class="line">   <span class="keyword">if</span> (firstOrderByValue.next()) &#123;</div><div class="line">       orderByValuesQueue.offer(firstOrderByValue);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (orderByValuesQueue.isEmpty()) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 设置当前 ResultSet</span></div><div class="line">   setCurrentResultSet(orderByValuesQueue.peek().getResultSet());</div><div class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p><code>orderByValuesQueue.poll()</code> 移除上一次获得的 ResultSet。为什么不能 <code>#setCurrentResultSet()</code> 就移除呢？如果该 ResultSet 里面还存在下一条记录，需要继续参加<strong>排序</strong>。而判断是否有下一条，需要调用 <code>ResultSet#next()</code> 方法，这会导致 ResultSet 指向了下一条记录。因而 <code>orderByValuesQueue.poll()</code> 调用是<strong>后置</strong>的。</p>
</li>
<li>
<p><code>isFirstNext</code> 变量那的判断看着是不是很“灵异”？因为 <code>#orderResultSetsToQueue()</code> 处设置了第一次的 ResultSet。如果不加这个标记，会导致第一条记录“不见”了。</p>
</li>
<li>
<p>通过不断的 <code>Queue#poll()</code>、<code>Queue#offset()</code> 实现排序。巧妙！仿佛 Get 新技能了：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 移除上一次获得的 ResultSet</span></div><div class="line">OrderByValue firstOrderByValue = orderByValuesQueue.poll();</div><div class="line"><span class="comment">// 如果上一次获得的 ResultSet还有下一条记录，继续添加到 排序值对象队列</span></div><div class="line"><span class="keyword">if</span> (firstOrderByValue.next()) &#123;</div><div class="line">  orderByValuesQueue.offer(firstOrderByValue);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
</ul>
<hr>
<p>在看下，我们上文 Stream 方式归并的定义：**将数据游标与结果集的游标保持一致，顺序的从结果集中一条条的获取正确的数据。**是不是能够清晰的对上了？！🙂</p>
<h1>4. GroupByStreamResultSetMerger</h1>
<p>GroupByStreamResultSetMerger，基于 <strong>Stream</strong> 方式分组归并结果集实现。 它继承自 OrderByStreamResultSetMerger，在<strong>排序</strong>的逻辑上，实现分组功能。实现原理也较为简单：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_16/03.png" alt=""></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupByStreamResultSetMerger</span> <span class="keyword">extends</span> <span class="title">OrderByStreamResultSetMerger</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 查询列名与位置映射</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Integer&gt; labelAndIndexMap;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Select SQL语句对象</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SelectStatement selectStatement;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 当前结果记录</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; currentRow;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 下一条结果记录 GROUP BY 条件</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> List&lt;?&gt; currentGroupByValues;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupByStreamResultSetMerger</span><span class="params">(</span></span></div><div class="line">            <span class="keyword">final</span> Map&lt;String, Integer&gt; labelAndIndexMap, <span class="keyword">final</span> List&lt;ResultSet&gt; resultSets, <span class="keyword">final</span> SelectStatement selectStatement, <span class="keyword">final</span> OrderType nullOrderType) <span class="keyword">throws</span> SQLException &#123;</div><div class="line">        <span class="keyword">super</span>(resultSets, selectStatement.getOrderByItems(), nullOrderType);</div><div class="line">        <span class="keyword">this</span>.labelAndIndexMap = labelAndIndexMap;</div><div class="line">        <span class="keyword">this</span>.selectStatement = selectStatement;</div><div class="line">        currentRow = <span class="keyword">new</span> ArrayList&lt;&gt;(labelAndIndexMap.size());</div><div class="line">        <span class="comment">// 初始化下一条结果记录 GROUP BY 条件</span></div><div class="line">        currentGroupByValues = getOrderByValuesQueue().isEmpty() ? Collections.emptyList() : <span class="keyword">new</span> GroupByValue(getCurrentResultSet(), selectStatement.getGroupByItems()).getGroupValues();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> columnIndex, <span class="keyword">final</span> Class&lt;?&gt; type)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">return</span> currentRow.get(columnIndex - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(<span class="keyword">final</span> String columnLabel, <span class="keyword">final</span> Class&lt;?&gt; type)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        Preconditions.checkState(labelAndIndexMap.containsKey(columnLabel), String.format(<span class="string">"Can't find columnLabel: %s"</span>, columnLabel));</div><div class="line">        <span class="keyword">return</span> currentRow.get(labelAndIndexMap.get(columnLabel) - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p><code>currentRow</code> 为当前结果记录，使用 <code>#getValue()</code>、<code>#getCalendarValue()</code> 方法获得当前结果记录的查询列值。</p>
</li>
<li>
<p><code>currentGroupByValues</code> 为<strong>下一条</strong>结果记录 GROUP BY 条件，通过 GroupByValue 生成：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupByValue</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 分组条件值数组</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;?&gt; groupValues;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupByValue</span><span class="params">(<span class="keyword">final</span> ResultSet resultSet, <span class="keyword">final</span> List&lt;OrderItem&gt; groupByItems)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        groupValues = getGroupByValues(resultSet, groupByItems);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获得分组条件值数组</div><div class="line">     * 例如，`GROUP BY user_id, order_status` 返回的某条记录结果为 `userId = 1, order_status = 3`，对应的 `groupValues = [1, 3]`</div><div class="line">     * <span class="doctag">@param</span> resultSet 结果集（单分片）</div><div class="line">     * <span class="doctag">@param</span> groupByItems 分组列</div><div class="line">     * <span class="doctag">@return</span> 分组条件值数组</div><div class="line">     * <span class="doctag">@throws</span> SQLException 当结果集关闭</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> List&lt;?&gt; getGroupByValues(<span class="keyword">final</span> ResultSet resultSet, <span class="keyword">final</span> List&lt;OrderItem&gt; groupByItems) <span class="keyword">throws</span> SQLException &#123;</div><div class="line">        List&lt;Object&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(groupByItems.size());</div><div class="line">        <span class="keyword">for</span> (OrderItem each : groupByItems) &#123;</div><div class="line">            result.add(resultSet.getObject(each.getIndex())); <span class="comment">// 从结果集获得每个分组条件的值</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>GroupByStreamResultSetMerger 在创建时，当前结果记录<strong>实际未合并</strong>，需要先调用 <code>#next()</code>，在使用 <code>#getValue()</code> 等方法获取值，这个和 OrderByStreamResultSetMerger 不同，可能是个 BUG。</p>
</li>
</ul>
<h2>4.1 AggregationUnit</h2>
<p>AggregationUnit，归并计算单元接口，有两个接口方法：</p>
<ul>
<li><code>#merge()</code>：归并聚合值</li>
<li><code>#getResult()</code>：获取计算结果</li>
</ul>
<p>一共有三个实现类：</p>
<ul>
<li><a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/d6ac50704f5e45beeeded09a4f0b160c7320b993/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/merger/groupby/aggregation/AccumulationAggregationUnit.java" rel="external nofollow noopener noreferrer" target="_blank">AccumulationAggregationUnit</a>：累加聚合单元，解决 COUNT、SUM 聚合列</li>
<li><a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/d6ac50704f5e45beeeded09a4f0b160c7320b993/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/merger/groupby/aggregation/ComparableAggregationUnit.java" rel="external nofollow noopener noreferrer" target="_blank">ComparableAggregationUnit</a>：比较聚合单元，解决 MAX、MIN 聚合列</li>
<li><a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/d6ac50704f5e45beeeded09a4f0b160c7320b993/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/merger/groupby/aggregation/AverageAggregationUnit.java" rel="external nofollow noopener noreferrer" target="_blank">AverageAggregationUnit</a>：平均值聚合单元，解决 AVG 聚合列</li>
</ul>
<p>实现都比较易懂，直接点击链接查看源码，我们就不浪费篇幅贴代码啦。</p>
<h2>4.2 #next()</h2>
<p>我们先看看大体的调用流程：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_16/05.png" alt=""></p>
<p>😈 看起来代码比较多，逻辑其实比较清晰，对照着顺序图顺序往下读即可。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// GroupByStreamResultSetMerger.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="comment">// 清除当前结果记录</span></div><div class="line">   currentRow.clear();</div><div class="line">   <span class="keyword">if</span> (getOrderByValuesQueue().isEmpty()) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">//</span></div><div class="line">   <span class="keyword">if</span> (isFirstNext()) &#123;</div><div class="line">       <span class="keyword">super</span>.next();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 顺序合并下面相同分组条件的记录</span></div><div class="line">   <span class="keyword">if</span> (aggregateCurrentGroupByRowAndNext()) &#123;</div><div class="line">       <span class="comment">// 生成下一条结果记录 GROUP BY 条件</span></div><div class="line">       currentGroupByValues = <span class="keyword">new</span> GroupByValue(getCurrentResultSet(), selectStatement.getGroupByItems()).getGroupValues();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">aggregateCurrentGroupByRowAndNext</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</div><div class="line">   <span class="comment">// 生成计算单元</span></div><div class="line">   Map&lt;AggregationSelectItem, AggregationUnit&gt; aggregationUnitMap = Maps.toMap(selectStatement.getAggregationSelectItems(), <span class="keyword">new</span> Function&lt;AggregationSelectItem, AggregationUnit&gt;() &#123;</div><div class="line">       </div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> AggregationUnit <span class="title">apply</span><span class="params">(<span class="keyword">final</span> AggregationSelectItem input)</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> AggregationUnitFactory.create(input.getType());</div><div class="line">       &#125;</div><div class="line">   &#125;);</div><div class="line">   <span class="comment">// 循环顺序合并下面相同分组条件的记录</span></div><div class="line">   <span class="keyword">while</span> (currentGroupByValues.equals(<span class="keyword">new</span> GroupByValue(getCurrentResultSet(), selectStatement.getGroupByItems()).getGroupValues())) &#123;</div><div class="line">       <span class="comment">// 归并聚合值</span></div><div class="line">       aggregate(aggregationUnitMap);</div><div class="line">       <span class="comment">// 缓存当前记录到结果记录</span></div><div class="line">       cacheCurrentRow();</div><div class="line">       <span class="comment">// 获取下一条记录</span></div><div class="line">       result = <span class="keyword">super</span>.next();</div><div class="line">       <span class="keyword">if</span> (!result) &#123;</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 设置当前记录的聚合字段结果</span></div><div class="line">   setAggregationValueToCurrentRow(aggregationUnitMap);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">aggregate</span><span class="params">(<span class="keyword">final</span> Map&lt;AggregationSelectItem, AggregationUnit&gt; aggregationUnitMap)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">for</span> (Entry&lt;AggregationSelectItem, AggregationUnit&gt; entry : aggregationUnitMap.entrySet()) &#123;</div><div class="line">       List&lt;Comparable&lt;?&gt;&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">2</span>);</div><div class="line">       <span class="keyword">if</span> (entry.getKey().getDerivedAggregationSelectItems().isEmpty()) &#123; <span class="comment">// SUM/COUNT/MAX/MIN 聚合列</span></div><div class="line">           values.add(getAggregationValue(entry.getKey()));</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">for</span> (AggregationSelectItem each : entry.getKey().getDerivedAggregationSelectItems()) &#123; <span class="comment">// AVG 聚合列</span></div><div class="line">               values.add(getAggregationValue(each));</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       entry.getValue().merge(values);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cacheCurrentRow</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getCurrentResultSet().getMetaData().getColumnCount(); i++) &#123;</div><div class="line">       currentRow.add(getCurrentResultSet().getObject(i + <span class="number">1</span>));</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="keyword">private</span> Comparable&lt;?&gt; getAggregationValue(<span class="keyword">final</span> AggregationSelectItem aggregationSelectItem) <span class="keyword">throws</span> SQLException &#123;</div><div class="line">   Object result = getCurrentResultSet().getObject(aggregationSelectItem.getIndex());</div><div class="line">   Preconditions.checkState(<span class="keyword">null</span> == result || result <span class="keyword">instanceof</span> Comparable, <span class="string">"Aggregation value must implements Comparable"</span>);</div><div class="line">   <span class="keyword">return</span> (Comparable&lt;?&gt;) result;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setAggregationValueToCurrentRow</span><span class="params">(<span class="keyword">final</span> Map&lt;AggregationSelectItem, AggregationUnit&gt; aggregationUnitMap)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (Entry&lt;AggregationSelectItem, AggregationUnit&gt; entry : aggregationUnitMap.entrySet()) &#123;</div><div class="line">       currentRow.set(entry.getKey().getIndex() - <span class="number">1</span>, entry.getValue().getResult()); <span class="comment">// 获取计算结果</span></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>5. GroupByMemoryResultSetMerger</h1>
<p>GroupByMemoryResultSetMerger，基于 <strong>内存</strong> 分组归并结果集实现。</p>
<p>区别于 GroupByStreamResultSetMerger，其无法使用每个分片结果集的<strong>有序</strong>的特点，只能在内存中合并后，进行<strong>整个</strong>重新排序。因而，性能和内存都较 GroupByStreamResultSetMerger 会差。</p>
<p>主流程如下：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_16/07.png" alt=""></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupByMemoryResultSetMerger</span> <span class="keyword">extends</span> <span class="title">AbstractMemoryResultSetMerger</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Select SQL语句对象</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SelectStatement selectStatement;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 默认排序类型</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OrderType nullOrderType;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 内存结果集</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Iterator&lt;MemoryResultSetRow&gt; memoryResultSetRows;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupByMemoryResultSetMerger</span><span class="params">(</span></span></div><div class="line">            <span class="keyword">final</span> Map&lt;String, Integer&gt; labelAndIndexMap, <span class="keyword">final</span> List&lt;ResultSet&gt; resultSets, <span class="keyword">final</span> SelectStatement selectStatement, <span class="keyword">final</span> OrderType nullOrderType) <span class="keyword">throws</span> SQLException &#123;</div><div class="line">        <span class="keyword">super</span>(labelAndIndexMap);</div><div class="line">        <span class="keyword">this</span>.selectStatement = selectStatement;</div><div class="line">        <span class="keyword">this</span>.nullOrderType = nullOrderType;</div><div class="line">        memoryResultSetRows = init(resultSets);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> Iterator&lt;MemoryResultSetRow&gt; <span class="title">init</span><span class="params">(<span class="keyword">final</span> List&lt;ResultSet&gt; resultSets)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        Map&lt;GroupByValue, MemoryResultSetRow&gt; dataMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">1024</span>); <span class="comment">// 分组条件值与内存记录映射</span></div><div class="line">        Map&lt;GroupByValue, Map&lt;AggregationSelectItem, AggregationUnit&gt;&gt; aggregationMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">1024</span>); <span class="comment">// 分组条件值与聚合列映射</span></div><div class="line">        <span class="comment">// 遍历结果集</span></div><div class="line">        <span class="keyword">for</span> (ResultSet each : resultSets) &#123;</div><div class="line">            <span class="keyword">while</span> (each.next()) &#123;</div><div class="line">                <span class="comment">// 生成分组条件</span></div><div class="line">                GroupByValue groupByValue = <span class="keyword">new</span> GroupByValue(each, selectStatement.getGroupByItems());</div><div class="line">                <span class="comment">// 初始化分组条件到 dataMap、aggregationMap 映射</span></div><div class="line">                initForFirstGroupByValue(each, groupByValue, dataMap, aggregationMap);</div><div class="line">                <span class="comment">// 归并聚合值</span></div><div class="line">                aggregate(each, groupByValue, aggregationMap);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 设置聚合列结果到内存记录</span></div><div class="line">        setAggregationValueToMemoryRow(dataMap, aggregationMap);</div><div class="line">        <span class="comment">// 内存排序</span></div><div class="line">        List&lt;MemoryResultSetRow&gt; result = getMemoryResultSetRows(dataMap);</div><div class="line">        <span class="comment">// 设置当前 ResultSet，这样 #getValue() 能拿到记录</span></div><div class="line">        <span class="keyword">if</span> (!result.isEmpty()) &#123;</div><div class="line">            setCurrentResultSetRow(result.get(<span class="number">0</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result.iterator();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p><code>#initForFirstGroupByValue()</code> 初始化<strong>分组条件</strong>到 <code>dataMap</code>，<code>aggregationMap</code> 映射中，这样可以调用 <code>#aggregate()</code> 将聚合值归并到 <code>aggregationMap</code> 里的该分组条件。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initForFirstGroupByValue</span><span class="params">(<span class="keyword">final</span> ResultSet resultSet, <span class="keyword">final</span> GroupByValue groupByValue, <span class="keyword">final</span> Map&lt;GroupByValue, MemoryResultSetRow&gt; dataMap, </span></span></div><div class="line">                                          <span class="keyword">final</span> Map&lt;GroupByValue, Map&lt;AggregationSelectItem, AggregationUnit&gt;&gt; aggregationMap) <span class="keyword">throws</span> SQLException &#123;</div><div class="line">        <span class="comment">// 初始化分组条件到 dataMap</span></div><div class="line">        <span class="keyword">if</span> (!dataMap.containsKey(groupByValue)) &#123;</div><div class="line">            dataMap.put(groupByValue, <span class="keyword">new</span> MemoryResultSetRow(resultSet));</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 初始化分组条件到 aggregationMap</span></div><div class="line">        <span class="keyword">if</span> (!aggregationMap.containsKey(groupByValue)) &#123;</div><div class="line">            Map&lt;AggregationSelectItem, AggregationUnit&gt; map = Maps.toMap(selectStatement.getAggregationSelectItems(), <span class="keyword">new</span> Function&lt;AggregationSelectItem, AggregationUnit&gt;() &#123;</div><div class="line">                </div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> AggregationUnit <span class="title">apply</span><span class="params">(<span class="keyword">final</span> AggregationSelectItem input)</span> </span>&#123;</div><div class="line">                    <span class="keyword">return</span> AggregationUnitFactory.create(input.getType());</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            aggregationMap.put(groupByValue, map);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ``` </div><div class="line">* 聚合完每个分组条件后，将聚合列结果 `aggregationMap` 合并到 `dataMap`。</div><div class="line"></div><div class="line">    ```<span class="function">Java</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setAggregationValueToMemoryRow</span><span class="params">(<span class="keyword">final</span> Map&lt;GroupByValue, MemoryResultSetRow&gt; dataMap, <span class="keyword">final</span> Map&lt;GroupByValue, Map&lt;AggregationSelectItem, AggregationUnit&gt;&gt; aggregationMap)</span> &#123;</div><div class="line">       <span class="keyword">for</span> (Entry&lt;GroupByValue, MemoryResultSetRow&gt; entry : dataMap.entrySet()) &#123; <span class="comment">// 遍 历内存记录</span></div><div class="line">           <span class="keyword">for</span> (AggregationSelectItem each : selectStatement.getAggregationSelectItems()) &#123; <span class="comment">// 遍历 每个聚合列</span></div><div class="line">               entry.getValue().setCell(each.getIndex(), aggregationMap.get(entry.getKey()).get(each).getResult());</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>调用 <code>#getMemoryResultSetRows()</code> 方法对内存记录进行<strong>内存排序</strong>。</p>
</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// GroupByMemoryResultSetMerger.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> List&lt;MemoryResultSetRow&gt; <span class="title">getMemoryResultSetRows</span><span class="params">(<span class="keyword">final</span> Map&lt;GroupByValue, MemoryResultSetRow&gt; dataMap)</span> </span>&#123;</div><div class="line">   List&lt;MemoryResultSetRow&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(dataMap.values());</div><div class="line">   Collections.sort(result, <span class="keyword">new</span> GroupByRowComparator(selectStatement, nullOrderType)); <span class="comment">// 内存排序</span></div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// GroupByRowComparator.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">final</span> MemoryResultSetRow o1, <span class="keyword">final</span> MemoryResultSetRow o2, <span class="keyword">final</span> List&lt;OrderItem&gt; orderItems)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (OrderItem each : orderItems) &#123;</div><div class="line">       Object orderValue1 = o1.getCell(each.getIndex());</div><div class="line">       Preconditions.checkState(<span class="keyword">null</span> == orderValue1 || orderValue1 <span class="keyword">instanceof</span> Comparable, <span class="string">"Order by value must implements Comparable"</span>);</div><div class="line">       Object orderValue2 = o2.getCell(each.getIndex());</div><div class="line">       Preconditions.checkState(<span class="keyword">null</span> == orderValue2 || orderValue2 <span class="keyword">instanceof</span> Comparable, <span class="string">"Order by value must implements Comparable"</span>);</div><div class="line">       <span class="keyword">int</span> result = ResultSetUtil.compareTo((Comparable) orderValue1, (Comparable) orderValue2, each.getType(), nullOrderType);</div><div class="line">       <span class="keyword">if</span> (<span class="number">0</span> != result) &#123;</div><div class="line">           <span class="keyword">return</span> result;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>总的来说，GROUP BY 内存归并和我们日常使用 Map 计算用户订单数是比较相似的。</li>
</ul>
<h2>5.1 #next()</h2>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">if</span> (memoryResultSetRows.hasNext()) &#123;</div><div class="line">       setCurrentResultSetRow(memoryResultSetRows.next());</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>内存归并完成后，使用 <code>memoryResultSetRows</code> 不断获得下一条记录。</li>
</ul>
<h1>6. IteratorStreamResultSetMerger</h1>
<p>IteratorStreamResultSetMerger，基于 <strong>Stream</strong> 迭代归并结果集实现。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorStreamResultSetMerger</span> <span class="keyword">extends</span> <span class="title">AbstractStreamResultSetMerger</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * ResultSet 数组迭代器</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Iterator&lt;ResultSet&gt; resultSets;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IteratorStreamResultSetMerger</span><span class="params">(<span class="keyword">final</span> List&lt;ResultSet&gt; resultSets)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.resultSets = resultSets.iterator();</div><div class="line">        <span class="comment">// 设置当前 ResultSet，这样 #getValue() 能拿到记录</span></div><div class="line">        setCurrentResultSet(<span class="keyword">this</span>.resultSets.next());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="comment">// 当前 ResultSet 迭代下一条记录</span></div><div class="line">        <span class="keyword">if</span> (getCurrentResultSet().next()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!resultSets.hasNext()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 获得下一个ResultSet， 设置当前 ResultSet</span></div><div class="line">        setCurrentResultSet(resultSets.next());</div><div class="line">        <span class="keyword">boolean</span> hasNext = getCurrentResultSet().next();</div><div class="line">        <span class="keyword">if</span> (hasNext) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (!hasNext &amp;&amp; resultSets.hasNext()) &#123;</div><div class="line">            setCurrentResultSet(resultSets.next());</div><div class="line">            hasNext = getCurrentResultSet().next();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> hasNext;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>7. LimitDecoratorResultSetMerger</h1>
<p>LimitDecoratorResultSetMerger，基于 <strong>Decorator</strong> 分页结果集归并实现。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LimitDecoratorResultSetMerger</span> <span class="keyword">extends</span> <span class="title">AbstractDecoratorResultSetMerger</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 分页条件</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Limit limit;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 是否全部记录都跳过了，即无符合条件记录</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> skipAll;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 当前已返回行数</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rowNumber;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LimitDecoratorResultSetMerger</span><span class="params">(<span class="keyword">final</span> ResultSetMerger resultSetMerger, <span class="keyword">final</span> Limit limit)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">super</span>(resultSetMerger);</div><div class="line">        <span class="keyword">this</span>.limit = limit;</div><div class="line">        skipAll = skipOffset();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">skipOffset</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="comment">// 跳过 skip 记录</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit.getOffsetValue(); i++) &#123;</div><div class="line">            <span class="keyword">if</span> (!getResultSetMerger().next()) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 行数</span></div><div class="line">        rowNumber = limit.isRowCountRewriteFlag() ? <span class="number">0</span> : limit.getOffsetValue();</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (skipAll) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 获得下一条记录</span></div><div class="line">        <span class="keyword">if</span> (limit.getRowCountValue() &gt; -<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> ++rowNumber &lt;= limit.getRowCountValue() &amp;&amp; getResultSetMerger().next();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 部分db 可以直 offset，不写 limit 行数，例如 oracle</span></div><div class="line">        <span class="keyword">return</span> getResultSetMerger().next();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>LimitDecoratorResultSetMerger 可以对其他 ResultSetMerger 进行装饰，调用其他 ResultSetMerger 的 <code>#next()</code> 不断获得下一条记录。</li>
</ul>
<h1>666. 彩蛋</h1>
<p>诶？应该是有蛮多地方解释的不是很清晰，如果让您阅读误解或是阻塞，非常抱歉。代码读起来比较易懂，使用文字来解释，对表述能力较差的自己，可能就绞尽脑汁，一脸懵逼。</p>
<p>恩，如果可以，还烦请把读起来不太爽的地方告诉我，谢谢。</p>
<p>厚着脸皮，道友，分享一波朋友圈可好？</p>
<p>如下是小礼包，嘿嘿</p>
<table>
<thead>
<tr>
<th>归并结果集接口</th>
<th>SQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>OrderByStreamResultSetMerger</td>
<td><code>SELECT * FROM t_order ORDER BY id</code></td>
</tr>
<tr>
<td>GroupByStreamResultSetMerger</td>
<td><code>SELECT uid, AVG(id) FROM t_order GROUP BY uid</code></td>
</tr>
<tr>
<td>GroupByMemoryResultSetMerger</td>
<td><code>SELECT uid FROM t_order GROUP BY id ORDER BY id DESC</code></td>
</tr>
<tr>
<td>IteratorStreamResultSetMerger</td>
<td><code>SELECT * FROM t_order</code></td>
</tr>
<tr>
<td>LimitDecoratorResultSetMerger</td>
<td><code>SELECT * FROM t_order ORDER BY id LIMIT 10</code></td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：&lt;/p&gt;
&lt;ol&gt;

    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— SQL 执行</title>
    <link href="http://www.yunai.me/Sharding-JDBC/sql-execute/"/>
    <id>http://www.yunai.me/Sharding-JDBC/sql-execute/</id>
    <published>2017-08-13T16:00:00.000Z</published>
    <updated>2017-08-14T18:34:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<p><strong>本文主要基于 Sharding-JDBC 1.5.0 正式版</strong></p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. ExecutorEngine</a>
<ul>
<li><a href="#">2.1 ListeningExecutorService</a></li>
<li><a href="#">2.2 关闭</a></li>
<li><a href="#">2.3 执行 SQL 任务</a></li>
</ul>
</li>
<li><a href="#">3. Executor</a>
<ul>
<li><a href="#">3.1 StatementExecutor</a></li>
<li><a href="#">3.2 PreparedStatementExecutor</a></li>
<li><a href="#">3.3 BatchPreparedStatementExecutor</a></li>
</ul>
</li>
<li><a href="#">4. ExecutionEvent</a>
<ul>
<li><a href="#">4.1 EventBus</a></li>
<li><a href="#">4.2 BestEffortsDeliveryListener</a></li>
</ul>
</li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<h1>1. 概述</h1>
<p>越过千山万水（SQL 解析、SQL 路由、SQL 改写），我们终于来到了 <strong>SQL 执行</strong>。开森不开森？！</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_14/01.png" alt=""></p>
<p>本文主要分享<strong>SQL 执行</strong>的过程，不包括<strong>结果聚合</strong>。<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《结果聚合》</a> <strong>东半球第二良心笔者</strong>会更新，关注微信公众号<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">【芋道源码】</a>完稿后<strong>第一时间</strong>通知您哟。</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_14/06.png" alt=""></p>
<p><strong>绿框部分</strong> SQL 执行主流程。</p>
<hr>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>
🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
<h1>2. ExecutorEngine</h1>
<p>ExecutorEngine，SQL执行引擎。</p>
<p>分表分库，需要执行的 SQL 数量从单条变成了多条，此时有两种方式执行：</p>
<ul>
<li><strong>串行</strong>执行 SQL</li>
<li><strong>并行</strong>执行 SQL</li>
</ul>
<p>前者，编码容易，性能较差，总耗时是多条 SQL 执行时间累加。<br>
后者，编码复杂，性能较好，总耗时约等于执行时间最长的 SQL。</p>
<p>👼 ExecutorEngine 当然采用的是<strong>后者</strong>，并行执行 SQL。</p>
<h2>2.1 ListeningExecutorService</h2>
<p><a href="http://www.yiibai.com/guava/" rel="external nofollow noopener noreferrer" target="_blank">Guava( Java 工具库 )</a> 提供的继承自  ExecutorService 的<strong>线程服务接口</strong>，提供创建 ListenableFuture 功能。ListenableFuture 接口，继承 Future 接口，有如下好处：</p>
<blockquote>
<p>我们强烈地建议你在代码中多使用ListenableFuture来代替JDK的 Future, 因为：</p>
</blockquote>
<ul>
<li>大多数Futures 方法中需要它。</li>
<li>转到ListenableFuture 编程比较容易。</li>
<li>Guava提供的通用公共类封装了公共的操作方方法，不需要提供Future和ListenableFuture的扩展方法。</li>
</ul>
<blockquote>
<p>传统JDK中的Future通过异步的方式计算返回结果:在多线程运算中可能或者可能在没有结束返回结果，Future是运行中的多线程的一个引用句柄，确保在服务执行返回一个Result。</p>
</blockquote>
<blockquote>
<p>ListenableFuture可以允许你注册回调方法(callbacks)，在运算（多线程执行）完成的时候进行调用,  或者在运算（多线程执行）完成后立即执行。这样简单的改进，使得可以明显的支持更多的操作，这样的功能在JDK concurrent中的Future是不支持的。</p>
</blockquote>
<p>如上内容来自<a href="http://ifeve.com/google-guava-listenablefuture/" rel="external nofollow noopener noreferrer" target="_blank">《Google Guava包的ListenableFuture解析
》</a>，文章写的很棒。下文你会看到 Sharding-JDBC 是<strong>如何通过 ListenableFuture 简化并发编程的</strong>。</p>
<p>下面看看 ExecutorEngine 如何<strong>初始化</strong> ListeningExecutorService</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingDataSource.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ShardingDataSource</span><span class="params">(<span class="keyword">final</span> ShardingRule shardingRule, <span class="keyword">final</span> Properties props)</span> </span>&#123;</div><div class="line">    <span class="comment">// .... 省略部分代码</span></div><div class="line">   shardingProperties = <span class="keyword">new</span> ShardingProperties(props);</div><div class="line">   <span class="keyword">int</span> executorSize = shardingProperties.getValue(ShardingPropertiesConstant.EXECUTOR_SIZE);</div><div class="line">   executorEngine = <span class="keyword">new</span> ExecutorEngine(executorSize);</div><div class="line">   <span class="comment">// .... 省略部分代码</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ExecutorEngine</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorEngine</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> executorSize)</span> </span>&#123;</div><div class="line">   executorService = MoreExecutors.listeningDecorator(<span class="keyword">new</span> ThreadPoolExecutor(</div><div class="line">           executorSize, executorSize, <span class="number">0</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</div><div class="line">           <span class="keyword">new</span> ThreadFactoryBuilder().setDaemon(<span class="keyword">true</span>).setNameFormat(<span class="string">"ShardingJDBC-%d"</span>).build()));</div><div class="line">   MoreExecutors.addDelayedShutdownHook(executorService, <span class="number">60</span>, TimeUnit.SECONDS);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>一个分片数据源( ShardingDataSource ) <strong>独占</strong> 一个 SQL执行引擎( ExecutorEngine )。</li>
<li><code>MoreExecutors#listeningDecorator()</code> 创建 ListeningExecutorService，这样 <code>#submit()</code>，<code>#invokeAll()</code> 可以返回 ListenableFuture。</li>
<li>默认情况下，线程池大小为 <strong>8</strong>。可以根据实际业务需要，设置 ShardingProperties 进行调整。</li>
<li><code>#setNameFormat()</code> 并发编程时，一定要对线程名字做下定义，这样排查问题会方便很多。</li>
<li><code>MoreExecutors#addDelayedShutdownHook()</code>，<strong>应用关闭</strong>时，等待<strong>所有任务全部完成</strong>再关闭。默认配置等待时间为 60 秒，<strong>建议</strong>将等待时间做成可配的。</li>
</ul>
<h2>2.2 关闭</h2>
<p>数据源关闭时，会调用 ExecutorEngine 也进行关闭。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingDataSource.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</div><div class="line">   executorEngine.close();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ExecutorEngine</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</div><div class="line">   executorService.shutdownNow();</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       executorService.awaitTermination(<span class="number">5</span>, TimeUnit.SECONDS);</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> InterruptedException ignored) &#123;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (!executorService.isTerminated()) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ShardingJdbcException(<span class="string">"ExecutorEngine can not been terminated"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>#shutdownNow()</code> 尝试使用 <code>Thread.interrupt()</code> 打断正在执行中的任务，未执行的任务不再执行。<strong>建议</strong>打印下哪些任务未执行，因为 SQL 未执行，可能数据未能持久化。</li>
<li><code>#awaitTermination()</code> 因为 <code>#shutdownNow()</code> 打断不是<strong>立即</strong>结束，需要一个过程，因此这里<strong>等待</strong>了 5 秒。</li>
<li><strong>等待</strong> 5 秒后，线程池不一定已经关闭，此时抛出异常给上层。<strong>建议</strong>打印下日志，记录出现这个情况。</li>
</ul>
<h2>2.3 执行 SQL 任务</h2>
<p>ExecutorEngine 对外暴露 <code>#executeStatement()</code>，<code>#executePreparedStatement()</code>，<code>#executeBatch()</code></p>
<p>三个方法分别提供给 StatementExecutor、PreparedStatementExecutor、BatchPreparedStatementExecutor 调用。而这三个方法，内部调用的都是 <code>#execute()</code> 私有方法。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ExecutorEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 执行Statement.</div><div class="line">* <span class="doctag">@param</span> sqlType SQL类型</div><div class="line">* <span class="doctag">@param</span> statementUnits 语句对象执行单元集合</div><div class="line">* <span class="doctag">@param</span> executeCallback 执行回调函数</div><div class="line">* <span class="doctag">@param</span> &lt;T&gt; 返回值类型</div><div class="line">* <span class="doctag">@return</span> 执行结果</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">executeStatement</span><span class="params">(<span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> Collection&lt;StatementUnit&gt; statementUnits, <span class="keyword">final</span> ExecuteCallback&lt;T&gt; executeCallback)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> execute(sqlType, statementUnits, Collections.&lt;List&lt;Object&gt;&gt;emptyList(), executeCallback);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">/**</span></div><div class="line">* 执行PreparedStatement.</div><div class="line">* <span class="doctag">@param</span> sqlType SQL类型</div><div class="line">* <span class="doctag">@param</span> preparedStatementUnits 语句对象执行单元集合</div><div class="line">* <span class="doctag">@param</span> parameters 参数列表</div><div class="line">* <span class="doctag">@param</span> executeCallback 执行回调函数</div><div class="line">* <span class="doctag">@param</span> &lt;T&gt; 返回值类型</div><div class="line">* <span class="doctag">@return</span> 执行结果</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">executePreparedStatement</span><span class="params">(</span></span></div><div class="line">       <span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> Collection&lt;PreparedStatementUnit&gt; preparedStatementUnits, <span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> ExecuteCallback&lt;T&gt; executeCallback) &#123;</div><div class="line">   <span class="keyword">return</span> execute(sqlType, preparedStatementUnits, Collections.singletonList(parameters), executeCallback);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">/**</span></div><div class="line">* 执行Batch.</div><div class="line">* <span class="doctag">@param</span> sqlType SQL类型</div><div class="line">* <span class="doctag">@param</span> batchPreparedStatementUnits 语句对象执行单元集合</div><div class="line">* <span class="doctag">@param</span> parameterSets 参数列表集</div><div class="line">* <span class="doctag">@param</span> executeCallback 执行回调函数</div><div class="line">* <span class="doctag">@return</span> 执行结果</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; executeBatch(</div><div class="line">       <span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> Collection&lt;BatchPreparedStatementUnit&gt; batchPreparedStatementUnits, <span class="keyword">final</span> List&lt;List&lt;Object&gt;&gt; parameterSets, <span class="keyword">final</span> ExecuteCallback&lt;<span class="keyword">int</span>[]&gt; executeCallback) &#123;</div><div class="line">   <span class="keyword">return</span> execute(sqlType, batchPreparedStatementUnits, parameterSets, executeCallback);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>#execute()</code> 执行过程大体流程如下图：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_14/02.png" alt=""></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 执行</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> sqlType SQL 类型</div><div class="line">* <span class="doctag">@param</span> baseStatementUnits 语句对象执行单元集合</div><div class="line">* <span class="doctag">@param</span> parameterSets 参数列表集</div><div class="line">* <span class="doctag">@param</span> executeCallback 执行回调函数</div><div class="line">* <span class="doctag">@param</span> &lt;T&gt; 返回值类型</div><div class="line">* <span class="doctag">@return</span> 执行结果</div><div class="line">*/</div><div class="line"><span class="keyword">private</span>  &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">execute</span><span class="params">(</span></span></div><div class="line">       <span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> Collection&lt;? extends BaseStatementUnit&gt; baseStatementUnits, <span class="keyword">final</span> List&lt;List&lt;Object&gt;&gt; parameterSets, <span class="keyword">final</span> ExecuteCallback&lt;T&gt; executeCallback) &#123;</div><div class="line">   <span class="keyword">if</span> (baseStatementUnits.isEmpty()) &#123;</div><div class="line">       <span class="keyword">return</span> Collections.emptyList();</div><div class="line">   &#125;</div><div class="line">   Iterator&lt;? extends BaseStatementUnit&gt; iterator = baseStatementUnits.iterator();</div><div class="line">   BaseStatementUnit firstInput = iterator.next();</div><div class="line">   <span class="comment">// 第二个任务开始所有 SQL任务 提交线程池【异步】执行任务</span></div><div class="line">   ListenableFuture&lt;List&lt;T&gt;&gt; restFutures = asyncExecute(sqlType, Lists.newArrayList(iterator), parameterSets, executeCallback);</div><div class="line">   T firstOutput;</div><div class="line">   List&lt;T&gt; restOutputs;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 第一个任务【同步】执行任务</span></div><div class="line">       firstOutput = syncExecute(sqlType, firstInput, parameterSets, executeCallback);</div><div class="line">       <span class="comment">// 等待第二个任务开始所有 SQL任务完成</span></div><div class="line">       restOutputs = restFutures.get();</div><div class="line">       <span class="comment">//CHECKSTYLE:OFF</span></div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       <span class="comment">//CHECKSTYLE:ON</span></div><div class="line">       ExecutorExceptionHandler.handleException(ex);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 返回结果</span></div><div class="line">   List&lt;T&gt; result = Lists.newLinkedList(restOutputs);</div><div class="line">   result.add(<span class="number">0</span>, firstOutput);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>第一个任务**【同步】**调用 <code>#executeInternal()</code> 执行任务。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">syncExecute</span><span class="params">(<span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> BaseStatementUnit baseStatementUnit, <span class="keyword">final</span> List&lt;List&lt;Object&gt;&gt; parameterSets, <span class="keyword">final</span> ExecuteCallback&lt;T&gt; executeCallback)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">   <span class="comment">// 【同步】执行任务</span></div><div class="line">   <span class="keyword">return</span> executeInternal(sqlType, baseStatementUnit, parameterSets, executeCallback, ExecutorExceptionHandler.isExceptionThrown(), ExecutorDataMap.getDataMap());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>第二个开始的任务<strong>提交线程池异步</strong>调用 <code>#executeInternal()</code> 执行任务。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> &lt;T&gt; ListenableFuture&lt;List&lt;T&gt;&gt; asyncExecute(</div><div class="line">       <span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> Collection&lt;BaseStatementUnit&gt; baseStatementUnits, <span class="keyword">final</span> List&lt;List&lt;Object&gt;&gt; parameterSets, <span class="keyword">final</span> ExecuteCallback&lt;T&gt; executeCallback) &#123;</div><div class="line">   List&lt;ListenableFuture&lt;T&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(baseStatementUnits.size());</div><div class="line">   <span class="keyword">final</span> <span class="keyword">boolean</span> isExceptionThrown = ExecutorExceptionHandler.isExceptionThrown();</div><div class="line">   <span class="keyword">final</span> Map&lt;String, Object&gt; dataMap = ExecutorDataMap.getDataMap();</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">final</span> BaseStatementUnit each : baseStatementUnits) &#123;</div><div class="line">       <span class="comment">// 提交线程池【异步】执行任务</span></div><div class="line">       result.add(executorService.submit(<span class="keyword">new</span> Callable&lt;T&gt;() &#123;</div><div class="line">           </div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">               <span class="keyword">return</span> executeInternal(sqlType, each, parameterSets, executeCallback, isExceptionThrown, dataMap);</div><div class="line">           &#125;</div><div class="line">       &#125;));</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 返回 ListenableFuture</span></div><div class="line">   <span class="keyword">return</span> Futures.allAsList(result);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>我们注意下 <code>Futures.allAsList(result);</code> 和 <code>restOutputs = restFutures.get();</code>。神器 Guava <strong>简化并发编程</strong> 的好处就提现出来了。<code>ListenableFuture#get()</code> 当<strong>所有任务都成功</strong>时，返回所有任务执行结果；当<strong>任何一个任务失败</strong>时，<strong>马上</strong>抛出异常，无需等待其他任务执行完成。</li>
</ul>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_14/03.gif" alt=""></p>
<p><em>😮 Guava 真她喵神器，公众号：<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">【芋道源码】</a>会更新 Guava 源码分享的一个系列哟！老司机还不赶紧上车？</em></p>
<ul>
<li>为什么会分同步执行和异步执行呢？猜测，当<strong>SQL 执行是单表时</strong>，只要进行第一个任务的同步调用，性能更加优秀。等跟张亮大神请教确认原因后，咱会进行更新。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ExecutorEngine.java</span></div><div class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">executeInternal</span><span class="params">(<span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> BaseStatementUnit baseStatementUnit, <span class="keyword">final</span> List&lt;List&lt;Object&gt;&gt; parameterSets, <span class="keyword">final</span> ExecuteCallback&lt;T&gt; executeCallback, </span></span></div><div class="line">                     <span class="keyword">final</span> <span class="keyword">boolean</span> isExceptionThrown, <span class="keyword">final</span> Map&lt;String, Object&gt; dataMap) <span class="keyword">throws</span> Exception &#123;</div><div class="line">   <span class="keyword">synchronized</span> (baseStatementUnit.getStatement().getConnection()) &#123;</div><div class="line">       T result;</div><div class="line">       ExecutorExceptionHandler.setExceptionThrown(isExceptionThrown);</div><div class="line">       ExecutorDataMap.setDataMap(dataMap);</div><div class="line">       List&lt;AbstractExecutionEvent&gt; events = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">       <span class="comment">// 生成 Event</span></div><div class="line">       <span class="keyword">if</span> (parameterSets.isEmpty()) &#123;</div><div class="line">           events.add(getExecutionEvent(sqlType, baseStatementUnit, Collections.emptyList()));</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">for</span> (List&lt;Object&gt; each : parameterSets) &#123;</div><div class="line">               events.add(getExecutionEvent(sqlType, baseStatementUnit, each));</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// EventBus 发布 EventExecutionType.BEFORE_EXECUTE</span></div><div class="line">       <span class="keyword">for</span> (AbstractExecutionEvent event : events) &#123;</div><div class="line">           EventBusInstance.getInstance().post(event);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           <span class="comment">// 执行回调函数</span></div><div class="line">           result = executeCallback.execute(baseStatementUnit);</div><div class="line">       &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">           <span class="comment">// EventBus 发布 EventExecutionType.EXECUTE_FAILURE</span></div><div class="line">           <span class="keyword">for</span> (AbstractExecutionEvent each : events) &#123;</div><div class="line">               each.setEventExecutionType(EventExecutionType.EXECUTE_FAILURE);</div><div class="line">               each.setException(Optional.of(ex));</div><div class="line">               EventBusInstance.getInstance().post(each);</div><div class="line">               ExecutorExceptionHandler.handleException(ex);</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// EventBus 发布 EventExecutionType.EXECUTE_SUCCESS</span></div><div class="line">       <span class="keyword">for</span> (AbstractExecutionEvent each : events) &#123;</div><div class="line">           each.setEventExecutionType(EventExecutionType.EXECUTE_SUCCESS);</div><div class="line">           EventBusInstance.getInstance().post(each);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> result;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>result = executeCallback.execute(baseStatementUnit);</code> 执行回调函数。StatementExecutor，PreparedStatementExecutor，BatchPreparedStatementExecutor 通过传递<strong>执行回调函数</strong>( ExecuteCallback )实现给 ExecutorEngine 实现并行执行。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecuteCallback</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 执行任务.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> baseStatementUnit 语句对象执行单元</div><div class="line">     * <span class="doctag">@return</span> 处理结果</div><div class="line">     * <span class="doctag">@throws</span> Exception 执行期异常</div><div class="line">     */</div><div class="line">    <span class="function">T <span class="title">execute</span><span class="params">(BaseStatementUnit baseStatementUnit)</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p><code>synchronized (baseStatementUnit.getStatement().getConnection())</code> 原以为 Connection 非线程安全，因此需要用<strong>同步</strong>，后翻查资料<a href="http://blog.csdn.net/goldenfish1919/article/details/9089667" rel="external nofollow noopener noreferrer" target="_blank">《数据库连接池为什么要建立多个连接》</a>，Connection 是线程安全的。等跟张亮大神请教确认原因后，咱会进行更新。</p>
<ul>
<li>解答：MySQL、Oracle 的 Connection 实现是线程安全的。数据库连接池实现的 Connection 不一定是线程安全，例如 Druid 的线程池 Connection 非线程安全</li>
</ul>
<blockquote>
<p>FROM https://github.com/dangdangdotcom/sharding-jdbc/issues/166<br>
druid的数据源的stat这种filter在并发使用同一个connection链接时没有考虑线程安全的问题，故造成多个线程修改filter中的状态异常。
改造这个问题时，考虑到mysql驱动在执行statement时对同一个connection是线程安全的。也就是说同一个数据库链接的会话是串行执行的。故在sjdbc的executor对于多线程执行的情况也进行了针对数据库链接级别的同步。故该方案不会降低sjdbc的性能。
同时jdk1.7版本的同步采用了锁升级技术，在碰撞较低的情况下开销也是很小的。</p>
</blockquote>
</li>
<li>
<p>ExecutionEvent 这里先不解释，在本文第四节【EventBus】分享。</p>
</li>
<li>
<p>ExecutorExceptionHandler、ExecutorDataMap 和 柔性事务 ( AbstractSoftTransaction )，放在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《柔性事务》</a>分享。</p>
</li>
</ul>
<h1>3. Executor</h1>
<p>Executor，执行器，目前一共有三个执行器。不同的执行器对应不同的执行单元 (BaseStatementUnit)。</p>
<table>
<thead>
<tr>
<th style="text-align:left">执行器类</th>
<th style="text-align:left">执行器名</th>
<th style="text-align:left">执行单元</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">StatementExecutor</td>
<td style="text-align:left">静态语句对象执行单元</td>
<td style="text-align:left">StatementUnit</td>
</tr>
<tr>
<td style="text-align:left">PreparedStatementExecutor</td>
<td style="text-align:left">预编译语句对象请求的执行器</td>
<td style="text-align:left">PreparedStatementUnit</td>
</tr>
<tr>
<td style="text-align:left">BatchPreparedStatementExecutor</td>
<td style="text-align:left">批量预编译语句对象请求的执行器</td>
<td style="text-align:left">BatchPreparedStatementUnit</td>
</tr>
</tbody>
</table>
<ul>
<li>执行器提供的方法不同，因此不存在公用接口或者抽象类。</li>
<li>执行单元继承自 BaseStatementUnit</li>
</ul>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_14/04.png" alt=""></p>
<h2>3.1 StatementExecutor</h2>
<p>StatementExecutor，<strong>多线程</strong>执行静态语句对象请求的执行器，一共有三类方法：</p>
<ul>
<li><code>#executeQuery()</code></li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// StatementExecutor.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 执行SQL查询.</div><div class="line">* <span class="doctag">@return</span> 结果集列表</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;ResultSet&gt; <span class="title">executeQuery</span><span class="params">()</span> </span>&#123;</div><div class="line">   Context context = MetricsContext.start(<span class="string">"ShardingStatement-executeQuery"</span>);</div><div class="line">   List&lt;ResultSet&gt; result;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       result = executorEngine.executeStatement(sqlType, statementUnits, <span class="keyword">new</span> ExecuteCallback&lt;ResultSet&gt;() &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> ResultSet <span class="title">execute</span><span class="params">(<span class="keyword">final</span> BaseStatementUnit baseStatementUnit)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">               <span class="keyword">return</span> baseStatementUnit.getStatement().executeQuery(baseStatementUnit.getSqlExecutionUnit().getSql());</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       MetricsContext.stop(context);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>#executeUpdate()</code> 因为有四个不同情况的<code>#executeUpdate()</code>，所以抽象了 Updater 接口，从而达到逻辑重用。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// StatementExecutor.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 执行SQL更新.</div><div class="line">* <span class="doctag">@return</span> 更新数量</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> executeUpdate(<span class="keyword">new</span> Updater() &#123;</div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">(<span class="keyword">final</span> Statement statement, <span class="keyword">final</span> String sql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">           <span class="keyword">return</span> statement.executeUpdate(sql);</div><div class="line">       &#125;</div><div class="line">   &#125;);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">(<span class="keyword">final</span> Updater updater)</span> </span>&#123;</div><div class="line">   Context context = MetricsContext.start(<span class="string">"ShardingStatement-executeUpdate"</span>);</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       List&lt;Integer&gt; results = executorEngine.executeStatement(sqlType, statementUnits, <span class="keyword">new</span> ExecuteCallback&lt;Integer&gt;() &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> Integer <span class="title">execute</span><span class="params">(<span class="keyword">final</span> BaseStatementUnit baseStatementUnit)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">               <span class="keyword">return</span> updater.executeUpdate(baseStatementUnit.getStatement(), baseStatementUnit.getSqlExecutionUnit().getSql());</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">       <span class="keyword">return</span> accumulate(results);</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       MetricsContext.stop(context);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 计算总的更新数量</div><div class="line">* <span class="doctag">@param</span> results 更新数量数组</div><div class="line">* <span class="doctag">@return</span> 更新数量</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">accumulate</span><span class="params">(<span class="keyword">final</span> List&lt;Integer&gt; results)</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">   <span class="keyword">for</span> (Integer each : results) &#123;</div><div class="line">       result += <span class="keyword">null</span> == each ? <span class="number">0</span> : each;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>#execute()</code> 因为有四个不同情况的<code>#execute()</code>，所以抽象了 Executor 接口，从而达到逻辑重用。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 执行SQL请求.</div><div class="line">* <span class="doctag">@return</span> true表示执行DQL语句, false表示执行的DML语句</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> execute(<span class="keyword">new</span> Executor() &#123;</div><div class="line">       </div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Statement statement, <span class="keyword">final</span> String sql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">           <span class="keyword">return</span> statement.execute(sql);</div><div class="line">       &#125;</div><div class="line">   &#125;);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Executor executor)</span> </span>&#123;</div><div class="line">   Context context = MetricsContext.start(<span class="string">"ShardingStatement-execute"</span>);</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       List&lt;Boolean&gt; result = executorEngine.executeStatement(sqlType, statementUnits, <span class="keyword">new</span> ExecuteCallback&lt;Boolean&gt;() &#123; </div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> Boolean <span class="title">execute</span><span class="params">(<span class="keyword">final</span> BaseStatementUnit baseStatementUnit)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">               <span class="keyword">return</span> executor.execute(baseStatementUnit.getStatement(), baseStatementUnit.getSqlExecutionUnit().getSql());</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> == result || result.isEmpty() || <span class="keyword">null</span> == result.get(<span class="number">0</span>)) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> result.get(<span class="number">0</span>);</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       MetricsContext.stop(context);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>3.2 PreparedStatementExecutor</h2>
<p>PreparedStatementExecutor，<strong>多线程</strong>执行预编译语句对象请求的执行器。比 StatementExecutor 多了 <code>parameters</code> 参数，方法逻辑上基本一致，就不重复分享啦。</p>
<h2>3.3 BatchPreparedStatementExecutor</h2>
<p>BatchPreparedStatementExecutor，<strong>多线程</strong>执行批量预编译语句对象请求的执行器。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// BatchPreparedStatementExecutor.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 执行批量SQL.</div><div class="line">* </div><div class="line">* <span class="doctag">@return</span> 执行结果</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] executeBatch() &#123;</div><div class="line">   Context context = MetricsContext.start(<span class="string">"ShardingPreparedStatement-executeBatch"</span>);</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">return</span> accumulate(executorEngine.executeBatch(sqlType, batchPreparedStatementUnits, parameterSets, <span class="keyword">new</span> ExecuteCallback&lt;<span class="keyword">int</span>[]&gt;() &#123;</div><div class="line">           </div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="keyword">public</span> <span class="keyword">int</span>[] execute(<span class="keyword">final</span> BaseStatementUnit baseStatementUnit) <span class="keyword">throws</span> Exception &#123;</div><div class="line">               <span class="keyword">return</span> baseStatementUnit.getStatement().executeBatch();</div><div class="line">           &#125;</div><div class="line">       &#125;));</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       MetricsContext.stop(context);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 计算每个语句的更新数量</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> results 每条 SQL 更新数量</div><div class="line">* <span class="doctag">@return</span> 每个语句的更新数量</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] accumulate(<span class="keyword">final</span> List&lt;<span class="keyword">int</span>[]&gt; results) &#123;</div><div class="line">   <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[parameterSets.size()];</div><div class="line">   <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">   <span class="comment">// 每个语句按照顺序，读取到其对应的每个分片SQL影响的行数进行累加</span></div><div class="line">   <span class="keyword">for</span> (BatchPreparedStatementUnit each : batchPreparedStatementUnits) &#123;</div><div class="line">       <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : each.getJdbcAndActualAddBatchCallTimesMap().entrySet()) &#123;</div><div class="line">           result[entry.getKey()] += <span class="keyword">null</span> == results.get(count) ? <span class="number">0</span> : results.get(count)[entry.getValue()];</div><div class="line">       &#125;</div><div class="line">       count++;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>眼尖</strong>的同学会发现，为什么有 BatchPreparedStatementExecutor，而没有 BatchStatementExecutor 呢？目前 Sharding-JDBC 不支持 Statement 批量操作，只能进行 PreparedStatement 的批操作。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// PreparedStatement 批量操作，不会报错</span></div><div class="line">PreparedStatement ps = conn.prepareStatement(sql)</div><div class="line">ps.addBatch();</div><div class="line">ps.addBatch();</div><div class="line"></div><div class="line"><span class="comment">// Statement 批量操作，会报错</span></div><div class="line">ps.addBatch(sql); <span class="comment">// 报错：at com.dangdang.ddframe.rdb.sharding.jdbc.unsupported.AbstractUnsupportedOperationStatement.addBatch</span></div></pre></td></tr></table></figure></p>
<h1>4. ExecutionEvent</h1>
<p>AbstractExecutionEvent，SQL 执行事件抽象接口。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExecutionEvent</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 事件编号</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String id;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 数据源</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String dataSource;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * SQL</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String sql;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 参数</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; parameters;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 事件类型</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> EventExecutionType eventExecutionType;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 异常</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Optional&lt;SQLException&gt; exception;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>AbstractExecutionEvent 有两个实现子类：</p>
<ul>
<li>DMLExecutionEvent：DML类SQL执行时事件</li>
<li>DQLExecutionEvent：DQL类SQL执行时事件</li>
</ul>
<p>EventExecutionType，事件触发类型。</p>
<ul>
<li>BEFORE_EXECUTE：执行前</li>
<li>EXECUTE_SUCCESS：执行成功</li>
<li>EXECUTE_FAILURE：执行失败</li>
</ul>
<h2>4.1 EventBus</h2>
<p><strong>那究竟有什么用途呢？</strong> Sharding-JDBC 使用 Guava（<strong>没错，又是它</strong>）的 <strong>EventBus</strong> 实现了<strong>事件的发布和订阅</strong>。从上文 <code>ExecutorEngine#executeInternal()</code> 我们可以看到<strong>每个分片</strong> SQL 执行的过程中会发布相应事件：</p>
<ul>
<li>执行 SQL 前：发布类型类型为 BEFORE_EXECUTE 的事件</li>
<li>执行 SQL 成功：发布类型类型为 EXECUTE_SUCCESS 的事件</li>
<li>执行 SQL 失败：发布类型类型为 EXECUTE_FAILURE 的事件</li>
</ul>
<p>**怎么订阅事件呢？**非常简单，例子如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">EventBusInstance.getInstance().register(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Subscribe</span> <span class="comment">// 订阅</span></div><div class="line">  <span class="meta">@AllowConcurrentEvents</span> <span class="comment">// 是否允许并发执行，即线程安全</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(<span class="keyword">final</span> DMLExecutionEvent event)</span> </span>&#123; <span class="comment">// DMLExecutionEvent</span></div><div class="line">      System.out.println(<span class="string">"DMLExecutionEvent："</span> + event.getSql() + <span class="string">"\t"</span> + event.getEventExecutionType());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Subscribe</span> <span class="comment">// 订阅</span></div><div class="line">  <span class="meta">@AllowConcurrentEvents</span> <span class="comment">// 是否允许并发执行，即线程安全</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen2</span><span class="params">(<span class="keyword">final</span> DQLExecutionEvent event)</span> </span>&#123; <span class="comment">//DQLExecutionEvent</span></div><div class="line">      System.out.println(<span class="string">"DQLExecutionEvent："</span> + event.getSql() + <span class="string">"\t"</span> + event.getEventExecutionType());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<ul>
<li><code>#register()</code> 任何类都可以，并非一定需要使用 Runnable 类。此处例子单纯因为方便</li>
<li><code>@Subscribe</code> 注解在方法上，实现对事件的订阅</li>
<li><code>@AllowConcurrentEvents</code> 注解在方法上，表示线程安全，允许并发执行</li>
<li>方法上的<strong>参数对应的类</strong>即是订阅的事件。例如，<code>#listen()</code> 订阅了 DMLExecutionEvent 事件</li>
<li><code>EventBus#post()</code> 发布事件，<strong>同步</strong>调用订阅逻辑</li>
</ul>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_14/05.png" alt=""></p>
<ul>
<li>推荐阅读文章：<a href="http://www.cnblogs.com/peida/p/EventBus.html" rel="external nofollow noopener noreferrer" target="_blank">《Guava学习笔记：EventBus》</a></li>
</ul>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>
🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
<h2>4.2 BestEffortsDeliveryListener</h2>
<p>BestEffortsDeliveryListener，最大努力送达型事务监听器。</p>
<p>本文暂时暂时不分析其实现，仅仅作为另外一个<strong>订阅者</strong>的例子。我们会在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《柔性事务》</a>进行分享。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BestEffortsDeliveryListener</span> </span>&#123;</div><div class="line">    <span class="meta">@Subscribe</span></div><div class="line">    <span class="meta">@AllowConcurrentEvents</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(<span class="keyword">final</span> DMLExecutionEvent event)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!isProcessContinuously()) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        SoftTransactionConfiguration transactionConfig = SoftTransactionManager.getCurrentTransactionConfiguration().get();</div><div class="line">        TransactionLogStorage transactionLogStorage = TransactionLogStorageFactory.createTransactionLogStorage(transactionConfig.buildTransactionLogDataSource());</div><div class="line">        BEDSoftTransaction bedSoftTransaction = (BEDSoftTransaction) SoftTransactionManager.getCurrentTransaction().get();</div><div class="line">        <span class="keyword">switch</span> (event.getEventExecutionType()) &#123;</div><div class="line">            <span class="keyword">case</span> BEFORE_EXECUTE:</div><div class="line">                <span class="comment">//TODO 对于批量执行的SQL需要解析成两层列表</span></div><div class="line">                transactionLogStorage.add(<span class="keyword">new</span> TransactionLog(event.getId(), bedSoftTransaction.getTransactionId(), bedSoftTransaction.getTransactionType(), </div><div class="line">                        event.getDataSource(), event.getSql(), event.getParameters(), System.currentTimeMillis(), <span class="number">0</span>));</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            <span class="keyword">case</span> EXECUTE_SUCCESS: </div><div class="line">                transactionLogStorage.remove(event.getId());</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            <span class="keyword">case</span> EXECUTE_FAILURE: </div><div class="line">                <span class="keyword">boolean</span> deliverySuccess = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; transactionConfig.getSyncMaxDeliveryTryTimes(); i++) &#123;</div><div class="line">                    <span class="keyword">if</span> (deliverySuccess) &#123;</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">boolean</span> isNewConnection = <span class="keyword">false</span>;</div><div class="line">                    Connection conn = <span class="keyword">null</span>;</div><div class="line">                    PreparedStatement preparedStatement = <span class="keyword">null</span>;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        conn = bedSoftTransaction.getConnection().getConnection(event.getDataSource(), SQLType.UPDATE);</div><div class="line">                        <span class="keyword">if</span> (!isValidConnection(conn)) &#123;</div><div class="line">                            bedSoftTransaction.getConnection().release(conn);</div><div class="line">                            conn = bedSoftTransaction.getConnection().getConnection(event.getDataSource(), SQLType.UPDATE);</div><div class="line">                            isNewConnection = <span class="keyword">true</span>;</div><div class="line">                        &#125;</div><div class="line">                        preparedStatement = conn.prepareStatement(event.getSql());</div><div class="line">                        <span class="comment">//TODO 对于批量事件需要解析成两层列表</span></div><div class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> parameterIndex = <span class="number">0</span>; parameterIndex &lt; event.getParameters().size(); parameterIndex++) &#123;</div><div class="line">                            preparedStatement.setObject(parameterIndex + <span class="number">1</span>, event.getParameters().get(parameterIndex));</div><div class="line">                        &#125;</div><div class="line">                        preparedStatement.executeUpdate();</div><div class="line">                        deliverySuccess = <span class="keyword">true</span>;</div><div class="line">                        transactionLogStorage.remove(event.getId());</div><div class="line">                    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">                        log.error(String.format(<span class="string">"Delivery times %s error, max try times is %s"</span>, i + <span class="number">1</span>, transactionConfig.getSyncMaxDeliveryTryTimes()), ex);</div><div class="line">                    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                        close(isNewConnection, conn, preparedStatement);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            <span class="keyword">default</span>: </div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(event.getEventExecutionType().toString());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>666. 彩蛋</h1>
<p>本文完，但也未完。</p>
<p><strong>跨分片事务问题</strong>。例如：</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">UPDATE</span> t_order <span class="keyword">SET</span> nickname = ? <span class="keyword">WHERE</span> user_id = ?</div></pre></td></tr></table></figure></p>
<p>A 节点 <code>connection.commit()</code> 时，应用突然挂了！B节点 <code>connection.commit()</code> 还来不及执行。<br>
我们一起去<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《柔性事务》</a>寻找答案。</p>
<p><strong>道友，分享一波朋友圈可好？</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：&lt;/p&gt;
&lt;ol&gt;

    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— 分布式主键</title>
    <link href="http://www.yunai.me/Sharding-JDBC/distributed-id/"/>
    <id>http://www.yunai.me/Sharding-JDBC/distributed-id/</id>
    <published>2017-08-11T16:00:00.000Z</published>
    <updated>2017-08-14T18:34:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<p><strong>本文主要基于 Sharding-JDBC 1.5.0 正式版</strong></p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2.KeyGenerator</a>
<ul>
<li><a href="#">2.1 DefaultKeyGenerator</a></li>
<li><a href="#">2.2 HostNameKeyGenerator</a></li>
<li><a href="#">2.3 IPKeyGenerator</a></li>
<li><a href="#">2.4 IPSectionKeyGenerator</a></li>
</ul>
</li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<h1>1. 概述</h1>
<p>本文分享 Sharding-JDBC <strong>分布式主键</strong>实现。</p>
<p>官方文档<a href="http://dangdangdotcom.github.io/sharding-jdbc/02-guide/key-generator/" rel="external nofollow noopener noreferrer" target="_blank">《分布式主键》</a>对其介绍及使用方式介绍很完整，强烈先阅读。下面先引用下分布式主键的<strong>实现动机</strong>：</p>
<blockquote>
<p>传统数据库软件开发中，主键自动生成技术是基本需求。而各大数据库对于该需求也提供了相应的支持，比如MySQL的自增键。对于MySQL而言，分库分表之后，不同表生成全局唯一的Id是非常棘手的问题。因为同一个逻辑表内的不同实际表之间的自增键是无法互相感知的，这样会造成重复Id的生成。我们当然可以通过约束表生成键的规则来达到数据的不重复，但是这需要引入额外的运维力量来解决重复性问题，并使框架缺乏扩展性。</p>
</blockquote>
<blockquote>
<p>目前有许多第三方解决方案可以完美解决这个问题，比如UUID等依靠特定算法自生成不重复键，或者通过引入Id生成服务等。 但也正因为这种多样性导致了Sharding-JDBC如果强依赖于任何一种方案就会限制其自身的发展。</p>
</blockquote>
<blockquote>
<p>基于以上的原因，最终采用了以JDBC接口来实现对于生成Id的访问，而将底层具体的Id生成实现分离出来。</p>
</blockquote>
<hr>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>
🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
<h1>2. KeyGenerator</h1>
<p>KeyGenerator，主键生成器接口。实现类通过实现 <code>#generateKey()</code> 方法对外提供<strong>生成主键</strong>的功能。</p>
<h2>2.1 DefaultKeyGenerator</h2>
<p>DefaultKeyGenerator，默认的主键生成器。该生成器采用 Twitter Snowflake 算法实现，生成 <strong>64 Bits</strong> 的 <strong>Long</strong> 型编号。国内另外一款数据库中间件 MyCAT 分布式主键也是基于该算法实现。国内很多大型互联网公司<strong>发号器</strong>服务基于该算法加部分改造实现。所以 DefaultKeyGenerator 必须是<strong>根正苗红</strong>。如果你对<strong>分布式主键</strong>感兴趣，可以看看逗比笔者整理的<a href="http://www.yunai.me/Architecture/talk-about-global-id/?self">《谈谈 ID》</a>。</p>
<p>咳咳咳，有点跑题了。<strong>编号</strong>由四部分组成，从高位到低位（从左到右）分别是：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_12/01.png" alt=""></p>
<table>
<thead>
<tr>
<th style="text-align:left">Bits</th>
<th style="text-align:left">名字</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">符号位</td>
<td style="text-align:left">等于 0</td>
</tr>
<tr>
<td style="text-align:left">41</td>
<td style="text-align:left">时间戳</td>
<td style="text-align:left">从 2016/11/01 零点开始的毫秒数，支持 2 ^41 /365/24/60/60/1000=69.7年</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">工作进程编号</td>
<td style="text-align:left">支持 1024 个进程</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left">序列号</td>
<td style="text-align:left">每毫秒从 0 开始自增，支持 4096 个编号</td>
</tr>
</tbody>
</table>
<ul>
<li>每个工作进程每秒可以产生 4096000 个编号。是不是灰常牛比 💯</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// </span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultKeyGenerator</span> <span class="keyword">implements</span> <span class="title">KeyGenerator</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 时间偏移量，从2016年11月1日零点开始</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> EPOCH;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 自增量占用比特</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SEQUENCE_BITS = <span class="number">12L</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 工作进程ID比特</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> WORKER_ID_BITS = <span class="number">10L</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 自增量掩码（最大值）</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SEQUENCE_MASK = (<span class="number">1</span> &lt;&lt; SEQUENCE_BITS) - <span class="number">1</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 工作进程ID左移比特数（位数）</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> WORKER_ID_LEFT_SHIFT_BITS = SEQUENCE_BITS;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 时间戳左移比特数（位数）</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TIMESTAMP_LEFT_SHIFT_BITS = WORKER_ID_LEFT_SHIFT_BITS + WORKER_ID_BITS;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 工作进程ID最大值</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> WORKER_ID_MAX_VALUE = <span class="number">1L</span> &lt;&lt; WORKER_ID_BITS;</div><div class="line">    </div><div class="line">    <span class="meta">@Setter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TimeService timeService = <span class="keyword">new</span> TimeService();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 工作进程ID</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> workerId;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        Calendar calendar = Calendar.getInstance();</div><div class="line">        calendar.set(<span class="number">2016</span>, Calendar.NOVEMBER, <span class="number">1</span>);</div><div class="line">        calendar.set(Calendar.HOUR_OF_DAY, <span class="number">0</span>);</div><div class="line">        calendar.set(Calendar.MINUTE, <span class="number">0</span>);</div><div class="line">        calendar.set(Calendar.SECOND, <span class="number">0</span>);</div><div class="line">        calendar.set(Calendar.MILLISECOND, <span class="number">0</span>);</div><div class="line">        EPOCH = calendar.getTimeInMillis();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 最后自增量</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 最后生成编号时间戳，单位：毫秒</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastTime;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置工作进程Id.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> workerId 工作进程Id</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setWorkerId</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> workerId)</span> </span>&#123;</div><div class="line">        Preconditions.checkArgument(workerId &gt;= <span class="number">0L</span> &amp;&amp; workerId &lt; WORKER_ID_MAX_VALUE);</div><div class="line">        DefaultKeyGenerator.workerId = workerId;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 生成Id.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@return</span> 返回@&#123;<span class="doctag">@link</span> Long&#125;类型的Id</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Number <span class="title">generateKey</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 保证当前时间大于最后时间。时间回退会导致产生重复id</span></div><div class="line">        <span class="keyword">long</span> currentMillis = timeService.getCurrentMillis();</div><div class="line">        Preconditions.checkState(lastTime &lt;= currentMillis, <span class="string">"Clock is moving backwards, last time is %d milliseconds, current time is %d milliseconds"</span>, lastTime, currentMillis);</div><div class="line">        <span class="comment">// 获取序列号</span></div><div class="line">        <span class="keyword">if</span> (lastTime == currentMillis) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="number">0L</span> == (sequence = ++sequence &amp; SEQUENCE_MASK)) &#123; <span class="comment">// 当获得序号超过最大值时，归0，并去获得新的时间</span></div><div class="line">                currentMillis = waitUntilNextTime(currentMillis);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            sequence = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 设置最后时间戳</span></div><div class="line">        lastTime = currentMillis;</div><div class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</div><div class="line">            log.debug(<span class="string">"&#123;&#125;-&#123;&#125;-&#123;&#125;"</span>, <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>).format(<span class="keyword">new</span> Date(lastTime)), workerId, sequence);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 生成编号</span></div><div class="line">        <span class="keyword">return</span> ((currentMillis - EPOCH) &lt;&lt; TIMESTAMP_LEFT_SHIFT_BITS) | (workerId &lt;&lt; WORKER_ID_LEFT_SHIFT_BITS) | sequence;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 不停获得时间，直到大于最后时间</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> lastTime 最后时间</div><div class="line">     * <span class="doctag">@return</span> 时间</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">waitUntilNextTime</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> lastTime)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> time = timeService.getCurrentMillis();</div><div class="line">        <span class="keyword">while</span> (time &lt;= lastTime) &#123;</div><div class="line">            time = timeService.getCurrentMillis();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> time;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>EPOCH = calendar.getTimeInMillis();</code> 计算 2016/11/01 零点开始的毫秒数。</li>
<li><code>#generateKey()</code> 实现逻辑
<ol>
<li>校验当前时间<strong>小于等于</strong>最后生成编号时间戳，避免服务器时钟同步，可能产生时间回退，导致产生<strong>重复</strong>编号</li>
</ol>
<ul>
<li>获得序列号。当前时间戳可获得自增量到达最大值时，调用 <code>#waitUntilNextTime()</code> 获得下一毫秒</li>
<li>设置最后生成编号时间戳，用于校验时间回退情况</li>
<li>位操作生成<strong>编号</strong></li>
</ul>
</li>
</ul>
<p>总的来说，Twitter Snowflake 算法实现上是相对简单易懂的，较为麻烦的是<strong>怎么解决工作进程编号的分配</strong>？</p>
<ol>
<li>超过 1024 个怎么办？</li>
<li>怎么保证全局唯一？</li>
</ol>
<p>第一个问题，将分布式主键生成独立成一个<strong>发号器</strong>服务，提供生成分布式编号的功能。这个不在本文的范围内，有兴趣的同学可以 Google 下。</p>
<p>第二个问题，通过 Zookeeper、Consul、Etcd 等提供分布式配置功能的中间件。当然 Sharding-JDBC 也提供了不依赖这些服务的方式，我们一个一个往下看。</p>
<h2>2.2 HostNameKeyGenerator</h2>
<blockquote>
<p>根据<strong>机器名最后的数字编号</strong>获取工作进程编号。<br>
如果线上机器命名有统一规范,建议使用此种方式。<br>
例如，机器的 HostName 为: <code>dangdang-db-sharding-dev-01</code>(公司名-部门名-服务名-环境名-编号)，会截取 HostName 最后的编号 01 作为工作进程编号( workId )。</p>
</blockquote>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// HostNameKeyGenerator.java</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initWorkerId</span><span class="params">()</span> </span>&#123;</div><div class="line">   InetAddress address;</div><div class="line">   Long workerId;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       address = InetAddress.getLocalHost();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> UnknownHostException e) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot get LocalHost InetAddress, please check your network!"</span>);</div><div class="line">   &#125;</div><div class="line">   String hostName = address.getHostName();</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       workerId = Long.valueOf(hostName.replace(hostName.replaceAll(<span class="string">"\\d+$"</span>, <span class="string">""</span>), <span class="string">""</span>));</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> NumberFormatException e) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"Wrong hostname:%s, hostname must be end with number!"</span>, hostName));</div><div class="line">   &#125;</div><div class="line">   DefaultKeyGenerator.setWorkerId(workerId);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>2.3 IPKeyGenerator</h2>
<blockquote>
<p>根据<strong>机器IP</strong>获取工作进程编号。<br>
如果线上机器的IP二进制表示的最后10位不重复,建议使用此种方式。<br>
例如，机器的IP为192.168.1.108，二进制表示:<code>11000000 10101000 00000001 01101100</code>，截取最后 10 位 <code>01 01101100</code>，转为十进制 364，设置工作进程编号为 364。</p>
</blockquote>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// IPKeyGenerator.java</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initWorkerId</span><span class="params">()</span> </span>&#123;</div><div class="line">   InetAddress address;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       address = InetAddress.getLocalHost();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> UnknownHostException e) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot get LocalHost InetAddress, please check your network!"</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">byte</span>[] ipAddressByteArray = address.getAddress();</div><div class="line">   DefaultKeyGenerator.setWorkerId((<span class="keyword">long</span>) (((ipAddressByteArray[ipAddressByteArray.length - <span class="number">2</span>] &amp; <span class="number">0B11</span>) &lt;&lt; Byte.SIZE)</div><div class="line">           + (ipAddressByteArray[ipAddressByteArray.length - <span class="number">1</span>] &amp; <span class="number">0xFF</span>)));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>2.4 IPSectionKeyGenerator</h2>
<p>来自 <strong>DogFc</strong> 贡献，对 IPKeyGenerator 进行改造。</p>
<blockquote>
<p>浏览 IPKeyGenerator 工作进程编号生成的规则后，感觉对服务器IP后10位（特别是IPV6）数值比较约束。<br>
有以下优化思路：<br>
因为工作进程编号最大限制是 2^10，我们生成的工程进程编号只要满足小于 1024 即可。<br>
1.针对IPV4:<br>
....IP最大 255.255.255.255。而（255+255+255+255) &lt; 1024。<br>
....因此采用IP段数值相加即可生成唯一的workerId，不受IP位限制。</p>
</blockquote>
<ol start="2">
<li>针对IPV6:<br>
....IP最大 ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff<br>
....为了保证相加生成出的工程进程编号 &lt; 1024,思路是将每个 Bit 位的后6位相加。这样在一定程度上也可以满足workerId不重复的问题。<br>
使用这种 IP 生成工作进程编号的方法,必须保证IP段相加不能重复</li>
</ol>
<p>对于 IPV6 ：2^ 6 = 64。64 * 8 = 512 &lt; 1024。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// IPSectionKeyGenerator.java</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initWorkerId</span><span class="params">()</span> </span>&#123;</div><div class="line">   InetAddress address;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       address = InetAddress.getLocalHost();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> UnknownHostException e) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot get LocalHost InetAddress, please check your network!"</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">byte</span>[] ipAddressByteArray = address.getAddress();</div><div class="line">   <span class="keyword">long</span> workerId = <span class="number">0L</span>;</div><div class="line">   <span class="comment">// IPV4</span></div><div class="line">   <span class="keyword">if</span> (ipAddressByteArray.length == <span class="number">4</span>) &#123;</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">byte</span> byteNum : ipAddressByteArray) &#123;</div><div class="line">           workerId += byteNum &amp; <span class="number">0xFF</span>;</div><div class="line">       &#125;</div><div class="line">   <span class="comment">// IPV6</span></div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ipAddressByteArray.length == <span class="number">16</span>) &#123;</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">byte</span> byteNum : ipAddressByteArray) &#123;</div><div class="line">           workerId += byteNum &amp; <span class="number">0B111111</span>;</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Bad LocalHost InetAddress, please check your network!"</span>);</div><div class="line">   &#125;</div><div class="line">   DefaultKeyGenerator.setWorkerId(workerId);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>666. 彩蛋</h1>
<p>没有彩蛋。HOHOHO</p>
<p>道友，分享一波朋友圈可好。</p>
<p>感谢你，技术如此只好，还关注我的公众号。</p>
<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：&lt;/p&gt;
&lt;ol&gt;

    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— SQL 路由改写</title>
    <link href="http://www.yunai.me/Sharding-JDBC/sql-rewrite/"/>
    <id>http://www.yunai.me/Sharding-JDBC/sql-rewrite/</id>
    <published>2017-08-09T16:00:00.000Z</published>
    <updated>2017-08-14T18:34:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<p><strong>本文主要基于 Sharding-JDBC 1.5.0 正式版</strong></p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. SQLToken</a></li>
<li><a href="#">3.SQL 改写</a>
<ul>
<li><a href="#">3.1 TableToken</a></li>
<li><a href="#">3.2 ItemsToken</a></li>
<li><a href="#">3.3 OffsetToken</a></li>
<li><a href="#">3.4 RowCountToken</a>
<ul>
<li><a href="#">3.4.1 分页补充</a></li>
</ul>
</li>
<li><a href="#">3.5 OrderByToken</a></li>
<li><a href="#">3.6 GeneratedKeyToken</a></li>
</ul>
</li>
<li><a href="#">4. SQL 生成</a></li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<h1>1. 概述</h1>
<p>前置阅读：<a href="http://www.yunai.me/Sharding-JDBC/sql-parse-3/?mp">《SQL 解析（三）之查询SQL》</a></p>
<p>本文分享<strong>SQL 改写</strong>的源码实现。主要涉及两方面：</p>
<ol>
<li>SQL 改写：改写 SQL，解决分库分表后，查询结果需要聚合，需要对 SQL 进行调整，例如分页</li>
<li>SQL 生成：生成分表分库的执行 SQL</li>
</ol>
<p>SQLRewriteEngine，SQL重写引擎，实现 SQL 改写、生成功能。从 Sharding-JDBC 1.5.0 版本，SQL 改写进行了调整和大量优化。</p>
<blockquote>
<p>1.4.x及之前版本，SQL改写是在SQL路由之前完成的，在1.5.x中调整为SQL路由之后，因为SQL改写可以根据路由至单库表还是多库表而进行进一步优化。</p>
</blockquote>
<p>😆 很多同学看完<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《SQL 解析-系列》</a> 可能是一脸懵逼，特别对**“SQL 半理解”**。<img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_10/01.png" alt="">希望本文能给你一些启发。</p>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>
🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
<h1>2. SQLToken</h1>
<p>😁 SQLToken 在本文中很重要，所以即使在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《SQL 解析-系列》</a>已经分享过，我们也换个姿势，再来一次。</p>
<p>SQLToken，SQL标记对象<strong>接口</strong>。SQLRewriteEngine 基于 SQLToken 实现 <strong>SQL改写</strong>。SQL解析器在 SQL解析过程中，很重要的一个目的是<strong>标记需要SQL改写的部分</strong>，也就是 SQLToken。</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_10/02.png" alt=""></p>
<p><strong>各 SQLToken 生成条件如下</strong>(<em>悲伤，做成表格形式排版是乱的</em>)：</p>
<ol>
<li>GeneratedKeyToken 自增主键标记对象
<ul>
<li>插入SQL自增列不存在：<code>INSERT INTO t_order(nickname) VALUES ...</code> 中没有自增列 <code>order_id</code></li>
</ul>
</li>
<li>TableToken 表标记对象
<ul>
<li>查询列的表别名：<code>SELECT o.order_id</code> 的 <code>o</code></li>
<li>查询的表名：<code>SELECT * FROM t_order</code> 的 <code>t_order</code></li>
</ul>
</li>
<li>ItemsToken 选择项标记对象
<ul>
<li>AVG查询列：<code>SELECT AVG(price) FROM t_order</code> 的 <code>AVG(price)</code></li>
<li>ORDER BY 字段不在查询列：<code>SELECT order_id FROM t_order ORDER BY create_time</code> 的 <code>create_time</code></li>
<li>GROUP BY 字段不在查询列：<code>SELECT COUNT(order_id) FROM t_order GROUP BY user_id</code> 的 <code>user_id</code></li>
<li>自增主键未在插入列中：<code>INSERT INTO t_order(nickname) VALUES ...</code> 中没有自增列 <code>order_id</code></li>
</ul>
</li>
<li>OffsetToken 分页偏移量标记对象
<ul>
<li>分页有偏移量，但<strong>不是</strong>占位符 <code>?</code></li>
</ul>
</li>
<li>RowCountToken 分页长度标记对象
<ul>
<li>分页有长度，但<strong>不是</strong>占位符 <code>?</code></li>
</ul>
</li>
<li>OrderByToken 排序标记对象
<ul>
<li>有 GROUP BY 条件，无 ORDER BY 条件：<code>SELECT COUNT(*) FROM t_order GROUP BY order_id</code> 的 <code>order_id</code></li>
</ul>
</li>
</ol>
<h1>3.SQL 改写</h1>
<p><code>SQLRewriteEngine#rewrite()</code> 实现了 <strong>SQL改写</strong> 功能。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLRewriteEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* SQL改写.</div><div class="line">* <span class="doctag">@param</span> isRewriteLimit 是否重写Limit</div><div class="line">* <span class="doctag">@return</span> SQL构建器</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> SQLBuilder <span class="title">rewrite</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> isRewriteLimit)</span> </span>&#123;</div><div class="line">   SQLBuilder result = <span class="keyword">new</span> SQLBuilder();</div><div class="line">   <span class="keyword">if</span> (sqlTokens.isEmpty()) &#123;</div><div class="line">       result.appendLiterals(originalSQL);</div><div class="line">       <span class="keyword">return</span> result;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">   <span class="comment">// 排序SQLToken，按照 beginPosition 递增</span></div><div class="line">   sortByBeginPosition();</div><div class="line">   <span class="keyword">for</span> (SQLToken each : sqlTokens) &#123;</div><div class="line">       <span class="keyword">if</span> (<span class="number">0</span> == count) &#123; <span class="comment">// 拼接第一个 SQLToken 前的字符串</span></div><div class="line">           result.appendLiterals(originalSQL.substring(<span class="number">0</span>, each.getBeginPosition()));</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 拼接每个SQLToken</span></div><div class="line">       <span class="keyword">if</span> (each <span class="keyword">instanceof</span> TableToken) &#123;</div><div class="line">           appendTableToken(result, (TableToken) each, count, sqlTokens);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (each <span class="keyword">instanceof</span> ItemsToken) &#123;</div><div class="line">           appendItemsToken(result, (ItemsToken) each, count, sqlTokens);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (each <span class="keyword">instanceof</span> RowCountToken) &#123;</div><div class="line">           appendLimitRowCount(result, (RowCountToken) each, count, sqlTokens, isRewriteLimit);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (each <span class="keyword">instanceof</span> OffsetToken) &#123;</div><div class="line">           appendLimitOffsetToken(result, (OffsetToken) each, count, sqlTokens, isRewriteLimit);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (each <span class="keyword">instanceof</span> OrderByToken) &#123;</div><div class="line">           appendOrderByToken(result);</div><div class="line">       &#125;</div><div class="line">       count++;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>SQL改写以 SQLToken 为<strong>间隔</strong>，<strong>顺序</strong>改写。
<ul>
<li>顺序：调用 <code>#sortByBeginPosition()</code> 将 SQLToken 按照 <code>beginPosition</code> <strong>升序</strong>。</li>
<li>间隔：遍历 SQLToken，逐个拼接。</li>
</ul>
</li>
</ul>
<p>例如：
<img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_10/03.png" alt=""></p>
<hr>
<p>SQLBuilder，SQL构建器。下文会大量用到，我们看下实现代码。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SQLBuilder</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 段集合</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; segments;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 当前段</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> StringBuilder currentSegment;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SQLBuilder</span><span class="params">()</span> </span>&#123;</div><div class="line">        segments = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        currentSegment = <span class="keyword">new</span> StringBuilder();</div><div class="line">        segments.add(currentSegment);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 追加字面量.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> literals 字面量</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendLiterals</span><span class="params">(<span class="keyword">final</span> String literals)</span> </span>&#123;</div><div class="line">        currentSegment.append(literals);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 追加表占位符.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> tableName 表名称</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTable</span><span class="params">(<span class="keyword">final</span> String tableName)</span> </span>&#123;</div><div class="line">        <span class="comment">// 添加 TableToken</span></div><div class="line">        segments.add(<span class="keyword">new</span> TableToken(tableName));</div><div class="line">        <span class="comment">// 新建当前段</span></div><div class="line">        currentSegment = <span class="keyword">new</span> StringBuilder();</div><div class="line">        segments.add(currentSegment);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toSQL</span><span class="params">(<span class="keyword">final</span> Map&lt;String, String&gt; tableTokens)</span> </span>&#123;</div><div class="line">        <span class="comment">// ... 省略代码，【SQL生成】处分享</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@RequiredArgsConstructor</span></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TableToken</span> </span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 表名</div><div class="line">         */</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String tableName;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>现在我们来逐个分析每种 SQLToken 的<strong>拼接</strong>实现。</p>
<h2>3.1 TableToken</h2>
<p>调用 <code>#appendTableToken()</code> 方法拼接。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLRewriteEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 拼接 TableToken</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> sqlBuilder SQL构建器</div><div class="line">* <span class="doctag">@param</span> tableToken tableToken</div><div class="line">* <span class="doctag">@param</span> count tableToken 在 sqlTokens 的顺序</div><div class="line">* <span class="doctag">@param</span> sqlTokens sqlTokens</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendTableToken</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder, <span class="keyword">final</span> TableToken tableToken, <span class="keyword">final</span> <span class="keyword">int</span> count, <span class="keyword">final</span> List&lt;SQLToken&gt; sqlTokens)</span> </span>&#123;</div><div class="line">   <span class="comment">// 拼接 TableToken</span></div><div class="line">   String tableName = sqlStatement.getTables().getTableNames().contains(tableToken.getTableName()) ? tableToken.getTableName() : tableToken.getOriginalLiterals();</div><div class="line">   sqlBuilder.appendTable(tableName);</div><div class="line">   <span class="comment">// 拼接 SQLToken 后面的字符串</span></div><div class="line">   <span class="keyword">int</span> beginPosition = tableToken.getBeginPosition() + tableToken.getOriginalLiterals().length();</div><div class="line">   <span class="keyword">int</span> endPosition = sqlTokens.size() - <span class="number">1</span> == count ? originalSQL.length() : sqlTokens.get(count + <span class="number">1</span>).getBeginPosition();</div><div class="line">   sqlBuilder.appendLiterals(originalSQL.substring(beginPosition, endPosition));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>调用 <code>SQLBuilder#appendTable()</code> 拼接 TableToken。</li>
<li><code>sqlStatement.getTables().getTableNames().contains(tableToken.getTableName())</code> 目的是处理掉<strong>表名前后有的特殊字符</strong>，例如<code>SELECT * FROM 't_order'</code> 中 <code>t_order</code> 前后有 <code>'</code> 符号。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TableToken.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 获取表名称.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getTableName</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> SQLUtil.getExactlyValue(originalLiterals);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// SQLUtil.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getExactlyValue</span><span class="params">(<span class="keyword">final</span> String value)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">null</span> == value ? <span class="keyword">null</span> : CharMatcher.anyOf(<span class="string">"[]`'\""</span>).removeFrom(value);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>当 SQL 为 <code>SELECT o.* FROM t_order o</code>
<ul>
<li>TableToken 为查询列前的表别名 <code>o</code> 时返回结果：
<img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_10/04.png" alt=""></li>
<li>TableToken 为表名 <code>t_order</code> 时返回结果：
<img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_10/05.png" alt=""></li>
</ul>
</li>
</ul>
<h2>3.2 ItemsToken</h2>
<p>调用 <code>#appendItemsToken()</code> 方法拼接。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLRewriteEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 拼接 TableToken</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> sqlBuilder SQL构建器</div><div class="line">* <span class="doctag">@param</span> itemsToken itemsToken</div><div class="line">* <span class="doctag">@param</span> count itemsToken 在 sqlTokens 的顺序</div><div class="line">* <span class="doctag">@param</span> sqlTokens sqlTokens</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendItemsToken</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder, <span class="keyword">final</span> ItemsToken itemsToken, <span class="keyword">final</span> <span class="keyword">int</span> count, <span class="keyword">final</span> List&lt;SQLToken&gt; sqlTokens)</span> </span>&#123;</div><div class="line">   <span class="comment">// 拼接 ItemsToken</span></div><div class="line">   <span class="keyword">for</span> (String item : itemsToken.getItems()) &#123;</div><div class="line">       sqlBuilder.appendLiterals(<span class="string">", "</span>);</div><div class="line">       sqlBuilder.appendLiterals(item);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// SQLToken 后面的字符串</span></div><div class="line">   <span class="keyword">int</span> beginPosition = itemsToken.getBeginPosition();</div><div class="line">   <span class="keyword">int</span> endPosition = sqlTokens.size() - <span class="number">1</span> == count ? originalSQL.length() : sqlTokens.get(count + <span class="number">1</span>).getBeginPosition();</div><div class="line">   sqlBuilder.appendLiterals(originalSQL.substring(beginPosition, endPosition));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>第一种情况，<strong>AVG查询列</strong>，SQL 为 <code>SELECT AVG(order_id) FROM t_order o</code> 时返回结果：
<img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_10/06.png" alt=""></li>
<li>第二种情况，<strong>ORDER BY 字段不在查询列</strong>，SQL 为 <code>SELECT userId FROM t_order o ORDER BY order_id</code> 时返回结果：
<img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_10/07.png" alt=""></li>
<li>第三种情况，<strong>GROUP BY 字段不在查询列</strong>，类似第二种情况，就不举例子列。</li>
</ul>
<h2>3.3 OffsetToken</h2>
<p>调用 <code>#appendLimitOffsetToken()</code> 方法拼接。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLRewriteEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 拼接 OffsetToken</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> sqlBuilder SQL构建器</div><div class="line">* <span class="doctag">@param</span> offsetToken offsetToken</div><div class="line">* <span class="doctag">@param</span> count offsetToken 在 sqlTokens 的顺序</div><div class="line">* <span class="doctag">@param</span> sqlTokens sqlTokens</div><div class="line">* <span class="doctag">@param</span> isRewrite 是否重写。当路由结果为单分片时无需重写</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendLimitOffsetToken</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder, <span class="keyword">final</span> OffsetToken offsetToken, <span class="keyword">final</span> <span class="keyword">int</span> count, <span class="keyword">final</span> List&lt;SQLToken&gt; sqlTokens, <span class="keyword">final</span> <span class="keyword">boolean</span> isRewrite)</span> </span>&#123;</div><div class="line">   <span class="comment">// 拼接 OffsetToken</span></div><div class="line">   sqlBuilder.appendLiterals(isRewrite ? <span class="string">"0"</span> : String.valueOf(offsetToken.getOffset()));</div><div class="line">   <span class="comment">// SQLToken 后面的字符串</span></div><div class="line">   <span class="keyword">int</span> beginPosition = offsetToken.getBeginPosition() + String.valueOf(offsetToken.getOffset()).length();</div><div class="line">   <span class="keyword">int</span> endPosition = sqlTokens.size() - <span class="number">1</span> == count ? originalSQL.length() : sqlTokens.get(count + <span class="number">1</span>).getBeginPosition();</div><div class="line">   sqlBuilder.appendLiterals(originalSQL.substring(beginPosition, endPosition));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>当分页<strong>跨分片</strong>时，需要每个分片都查询后在<strong>内存</strong>中进行聚合。此时 <code>isRewrite = true</code>。为什么是 <code>&quot;0&quot;</code> 开始呢？每个分片在 [0, offset) 的记录<strong>可能</strong>属于实际分页结果，因而查询每个分片需要从 0 开始。</li>
<li>当分页<strong>单分片</strong>时，则无需重写，该分片执行的结果即是最终结果。<strong>SQL改写在SQL路由之后就有这个好处</strong>。如果先改写，因为没办法知道最终是单分片还是跨分片，考虑正确性，只能统一使用跨分片。</li>
</ul>
<h2>3.4 RowCountToken</h2>
<p>调用 <code>#appendLimitRowCount()</code> 方法拼接。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLRewriteEngine.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendLimitRowCount</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder, <span class="keyword">final</span> RowCountToken rowCountToken, <span class="keyword">final</span> <span class="keyword">int</span> count, <span class="keyword">final</span> List&lt;SQLToken&gt; sqlTokens, <span class="keyword">final</span> <span class="keyword">boolean</span> isRewrite)</span> </span>&#123;</div><div class="line">   SelectStatement selectStatement = (SelectStatement) sqlStatement;</div><div class="line">   Limit limit = selectStatement.getLimit();</div><div class="line">   <span class="keyword">if</span> (!isRewrite) &#123; <span class="comment">// 路由结果为单分片</span></div><div class="line">       sqlBuilder.appendLiterals(String.valueOf(rowCountToken.getRowCount()));</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((!selectStatement.getGroupByItems().isEmpty() || <span class="comment">// [1.1] 跨分片分组需要在内存计算，可能需要全部加载</span></div><div class="line">           !selectStatement.getAggregationSelectItems().isEmpty()) <span class="comment">// [1.2] 跨分片聚合列需要在内存计算，可能需要全部加载</span></div><div class="line">           &amp;&amp; !selectStatement.isSameGroupByAndOrderByItems()) &#123; <span class="comment">// [2] 如果排序一致，即各分片已经排序好结果，就不需要全部加载</span></div><div class="line">       sqlBuilder.appendLiterals(String.valueOf(Integer.MAX_VALUE));</div><div class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">// 路由结果为多分片</span></div><div class="line">       sqlBuilder.appendLiterals(String.valueOf(limit.isRowCountRewriteFlag() ? rowCountToken.getRowCount() + limit.getOffsetValue() : rowCountToken.getRowCount()));</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// SQLToken 后面的字符串</span></div><div class="line">   <span class="keyword">int</span> beginPosition = rowCountToken.getBeginPosition() + String.valueOf(rowCountToken.getRowCount()).length();</div><div class="line">   <span class="keyword">int</span> endPosition = sqlTokens.size() - <span class="number">1</span> == count ? originalSQL.length() : sqlTokens.get(count + <span class="number">1</span>).getBeginPosition();</div><div class="line">   sqlBuilder.appendLiterals(originalSQL.substring(beginPosition, endPosition));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>[1.1] <code>!selectStatement.getGroupByItems().isEmpty()</code> 跨分片<strong>分组</strong>需要在内存计算，<strong>可能</strong>需要全部加载。如果不全部加载，部分结果被分页条件错误结果，会导致结果不正确。</li>
<li>[1.2] <code>!selectStatement.getAggregationSelectItems().isEmpty())</code> 跨分片<strong>聚合列</strong>需要在内存计算，<strong>可能</strong>需要全部加载。如果不全部加载，部分结果被分页条件错误结果，会导致结果不正确。</li>
<li>[1.1][1.2]，<strong>可能</strong>变成必须的前提是 GROUP BY 和 ORDER BY 排序不一致。如果一致，各分片已经排序完成，无需内存中排序。</li>
</ul>
<h3>3.4.1 分页补充</h3>
<p>OffsetToken、RowCountToken 只有在分页对应位置非占位符 <code>?</code> 才存在。当对应位置是占位符时，会对<strong>分页条件对应的预编译 SQL 占位符参数</strong>进行重写，<strong>整体逻辑和 OffsetToken、RowCountToken 是一致的</strong>。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 👼 ParsingSQLRouter#route() 调用 #processLimit() </span></div><div class="line"></div><div class="line"><span class="comment">// ParsingSQLRouter.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 处理分页条件</div><div class="line">*</div><div class="line">* <span class="doctag">@see</span> SQLRewriteEngine#appendLimitRowCount(SQLBuilder, RowCountToken, int, List, boolean) </div><div class="line">* <span class="doctag">@param</span> parameters 占位符对应参数列表</div><div class="line">* <span class="doctag">@param</span> selectStatement Select SQL语句对象</div><div class="line">* <span class="doctag">@param</span> isSingleRouting 是否单表路由</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processLimit</span><span class="params">(<span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> SelectStatement selectStatement, <span class="keyword">final</span> <span class="keyword">boolean</span> isSingleRouting)</span> </span>&#123;</div><div class="line">   <span class="keyword">boolean</span> isNeedFetchAll = (!selectStatement.getGroupByItems().isEmpty() <span class="comment">// // [1.1] 跨分片分组需要在内存计算，可能需要全部加载</span></div><div class="line">                               || !selectStatement.getAggregationSelectItems().isEmpty()) <span class="comment">// [1.2] 跨分片聚合列需要在内存计算，可能需要全部加载</span></div><div class="line">                           &amp;&amp; !selectStatement.isSameGroupByAndOrderByItems(); <span class="comment">// [2] 如果排序一致，即各分片已经排序好结果，就不需要全部加载</span></div><div class="line">   selectStatement.getLimit().processParameters(parameters, !isSingleRouting, isNeedFetchAll);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Limit.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 填充改写分页参数.</div><div class="line">* <span class="doctag">@param</span> parameters 参数</div><div class="line">* <span class="doctag">@param</span> isRewrite 是否重写参数</div><div class="line">* <span class="doctag">@param</span> isFetchAll 是否获取所有数据</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processParameters</span><span class="params">(<span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> <span class="keyword">boolean</span> isRewrite, <span class="keyword">final</span> <span class="keyword">boolean</span> isFetchAll)</span> </span>&#123;</div><div class="line">   fill(parameters);</div><div class="line">   <span class="keyword">if</span> (isRewrite) &#123;</div><div class="line">       rewrite(parameters, isFetchAll);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 将占位符参数里是分页的参数赋值给 offset 、rowCount</div><div class="line">* 赋值的前提条件是 offset、rowCount 是 占位符</div><div class="line">* <span class="doctag">@param</span> parameters 占位符参数</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">final</span> List&lt;Object&gt; parameters)</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> offset = <span class="number">0</span>;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != <span class="keyword">this</span>.offset) &#123;</div><div class="line">       offset = -<span class="number">1</span> == <span class="keyword">this</span>.offset.getIndex() ? getOffsetValue() : NumberUtil.roundHalfUp(parameters.get(<span class="keyword">this</span>.offset.getIndex()));</div><div class="line">       <span class="keyword">this</span>.offset.setValue(offset);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">int</span> rowCount = <span class="number">0</span>;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != <span class="keyword">this</span>.rowCount) &#123;</div><div class="line">       rowCount = -<span class="number">1</span> == <span class="keyword">this</span>.rowCount.getIndex() ? getRowCountValue() : NumberUtil.roundHalfUp(parameters.get(<span class="keyword">this</span>.rowCount.getIndex()));</div><div class="line">       <span class="keyword">this</span>.rowCount.setValue(rowCount);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (offset &lt; <span class="number">0</span> || rowCount &lt; <span class="number">0</span>) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> SQLParsingException(<span class="string">"LIMIT offset and row count can not be a negative value."</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 重写分页条件对应的参数</div><div class="line">* <span class="doctag">@param</span> parameters 参数</div><div class="line">* <span class="doctag">@param</span> isFetchAll 是否拉取所有</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rewrite</span><span class="params">(<span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> <span class="keyword">boolean</span> isFetchAll)</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> rewriteOffset = <span class="number">0</span>;</div><div class="line">   <span class="keyword">int</span> rewriteRowCount;</div><div class="line">   <span class="comment">// 重写</span></div><div class="line">   <span class="keyword">if</span> (isFetchAll) &#123;</div><div class="line">       rewriteRowCount = Integer.MAX_VALUE;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rowCountRewriteFlag) &#123;</div><div class="line">       rewriteRowCount = <span class="keyword">null</span> == rowCount ? -<span class="number">1</span> : getOffsetValue() + rowCount.getValue();</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       rewriteRowCount = rowCount.getValue();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 参数设置</span></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != offset &amp;&amp; offset.getIndex() &gt; -<span class="number">1</span>) &#123;</div><div class="line">       parameters.set(offset.getIndex(), rewriteOffset);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != rowCount &amp;&amp; rowCount.getIndex() &gt; -<span class="number">1</span>) &#123;</div><div class="line">       parameters.set(rowCount.getIndex(), rewriteRowCount);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>3.5 OrderByToken</h2>
<p>调用 <code>#appendOrderByToken()</code> 方法拼接。数据库里，当无 ORDER BY条件 而有 GROUP BY 条件时候，会使用 GROUP BY条件将结果升序排序：</p>
<ul>
<li><code>SELECT order_id FROM t_order GROUP BY order_id</code> 等价于 <code>SELECT order_id FROM t_order GROUP BY order_id ORDER BY order_id ASC</code></li>
<li><code>SELECT order_id FROM t_order GROUP BY order_id DESC</code> 等价于 <code>SELECT order_id FROM t_order GROUP BY order_id ORDER BY order_id DESC</code></li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ParsingSQLRouter.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 拼接 OrderByToken</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> sqlBuilder SQL构建器</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendOrderByToken</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder)</span> </span>&#123;</div><div class="line">   SelectStatement selectStatement = (SelectStatement) sqlStatement;</div><div class="line">   <span class="comment">// 拼接 OrderByToken</span></div><div class="line">   StringBuilder orderByLiterals = <span class="keyword">new</span> StringBuilder(<span class="string">" ORDER BY "</span>);</div><div class="line">   <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">   <span class="keyword">for</span> (OrderItem each : selectStatement.getOrderByItems()) &#123;</div><div class="line">       <span class="keyword">if</span> (<span class="number">0</span> == i) &#123;</div><div class="line">           orderByLiterals.append(each.getColumnLabel()).append(<span class="string">" "</span>).append(each.getType().name());</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           orderByLiterals.append(<span class="string">","</span>).append(each.getColumnLabel()).append(<span class="string">" "</span>).append(each.getType().name());</div><div class="line">       &#125;</div><div class="line">       i++;</div><div class="line">   &#125;</div><div class="line">   orderByLiterals.append(<span class="string">" "</span>);</div><div class="line">   sqlBuilder.appendLiterals(orderByLiterals.toString());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>当 SQL 为 <code>SELECT order_id FROM t_order o GROUP BY order_id</code> 返回结果：
<img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_10/08.png" alt=""></li>
</ul>
<h2>3.6 GeneratedKeyToken</h2>
<p>前置阅读：<a href="http://www.yunai.me/Sharding-JDBC/sql-parse-4/?mp">《SQL 解析（四）之插入SQL》</a></p>
<p>GeneratedKeyToken，和其它 SQLToken 不同，在 <strong>SQL解析</strong> 完进行处理。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ParsingSQLRouter.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> SQLStatement <span class="title">parse</span><span class="params">(<span class="keyword">final</span> String logicSQL, <span class="keyword">final</span> <span class="keyword">int</span> parametersSize)</span> </span>&#123;</div><div class="line">   SQLParsingEngine parsingEngine = <span class="keyword">new</span> SQLParsingEngine(databaseType, logicSQL, shardingRule);</div><div class="line">   Context context = MetricsContext.start(<span class="string">"Parse SQL"</span>);</div><div class="line">   SQLStatement result = parsingEngine.parse();</div><div class="line">   <span class="keyword">if</span> (result <span class="keyword">instanceof</span> InsertStatement) &#123; <span class="comment">// 处理 GenerateKeyToken</span></div><div class="line">       ((InsertStatement) result).appendGenerateKeyToken(shardingRule, parametersSize);</div><div class="line">   &#125;</div><div class="line">   MetricsContext.stop(context);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// InsertStatement.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 追加自增主键标记对象.</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> shardingRule 分片规则</div><div class="line">* <span class="doctag">@param</span> parametersSize 参数个数</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendGenerateKeyToken</span><span class="params">(<span class="keyword">final</span> ShardingRule shardingRule, <span class="keyword">final</span> <span class="keyword">int</span> parametersSize)</span> </span>&#123;</div><div class="line">   <span class="comment">// SQL 里有主键列</span></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != generatedKey) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// TableRule 存在</span></div><div class="line">   Optional&lt;TableRule&gt; tableRule = shardingRule.tryFindTableRule(getTables().getSingleTableName());</div><div class="line">   <span class="keyword">if</span> (!tableRule.isPresent()) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// GeneratedKeyToken 存在</span></div><div class="line">   Optional&lt;GeneratedKeyToken&gt; generatedKeysToken = findGeneratedKeyToken();</div><div class="line">   <span class="keyword">if</span> (!generatedKeysToken.isPresent()) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 处理 GenerateKeyToken</span></div><div class="line">   ItemsToken valuesToken = <span class="keyword">new</span> ItemsToken(generatedKeysToken.get().getBeginPosition());</div><div class="line">   <span class="keyword">if</span> (<span class="number">0</span> == parametersSize) &#123;</div><div class="line">       appendGenerateKeyToken(shardingRule, tableRule.get(), valuesToken);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       appendGenerateKeyToken(shardingRule, tableRule.get(), valuesToken, parametersSize);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 移除 generatedKeysToken</span></div><div class="line">   getSqlTokens().remove(generatedKeysToken.get());</div><div class="line">   <span class="comment">// 新增 ItemsToken</span></div><div class="line">   getSqlTokens().add(valuesToken);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>根据<strong>占位符参数</strong>数量不同，调用的 <code>#appendGenerateKeyToken()</code> 是<strong>不同</strong>的：</li>
<li><strong>占位符参数数量 = 0</strong> 时，直接生成<strong>分布式主键</strong>，保持无占位符的做法。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// InsertStatement.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendGenerateKeyToken</span><span class="params">(<span class="keyword">final</span> ShardingRule shardingRule, <span class="keyword">final</span> TableRule tableRule, <span class="keyword">final</span> ItemsToken valuesToken)</span> </span>&#123;</div><div class="line">   <span class="comment">// 生成分布式主键</span></div><div class="line">   Number generatedKey = shardingRule.generateKey(tableRule.getLogicTable());</div><div class="line">   <span class="comment">// 添加到 ItemsToken</span></div><div class="line">   valuesToken.getItems().add(generatedKey.toString());</div><div class="line">   <span class="comment">// 增加 Condition，用于路由</span></div><div class="line">   getConditions().add(<span class="keyword">new</span> Condition(<span class="keyword">new</span> Column(tableRule.getGenerateKeyColumn(), tableRule.getLogicTable()), <span class="keyword">new</span> SQLNumberExpression(generatedKey)), shardingRule);</div><div class="line">   <span class="comment">// 生成 GeneratedKey</span></div><div class="line">   <span class="keyword">this</span>.generatedKey = <span class="keyword">new</span> GeneratedKey(tableRule.getLogicTable(), -<span class="number">1</span>, generatedKey);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><strong>占位符参数数量 &gt; 0</strong> 时，生成自增列的占位符，保持有占位符的做法。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendGenerateKeyToken</span><span class="params">(<span class="keyword">final</span> ShardingRule shardingRule, <span class="keyword">final</span> TableRule tableRule, <span class="keyword">final</span> ItemsToken valuesToken, <span class="keyword">final</span> <span class="keyword">int</span> parametersSize)</span> </span>&#123;</div><div class="line">   <span class="comment">// 生成占位符</span></div><div class="line">   valuesToken.getItems().add(<span class="string">"?"</span>);</div><div class="line">   <span class="comment">// 增加 Condition，用于路由</span></div><div class="line">   getConditions().add(<span class="keyword">new</span> Condition(<span class="keyword">new</span> Column(tableRule.getGenerateKeyColumn(), tableRule.getLogicTable()), <span class="keyword">new</span> SQLPlaceholderExpression(parametersSize)), shardingRule);</div><div class="line">   <span class="comment">// 生成 GeneratedKey</span></div><div class="line">   generatedKey = <span class="keyword">new</span> GeneratedKey(tableRule.getGenerateKeyColumn(), parametersSize, <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>因为 GenerateKeyToken 已经处理完，所以移除，避免 <code>SQLRewriteEngine#rewrite()</code> 二次改写。另外，通过 ItemsToken 补充自增列。</li>
<li>生成 GeneratedKey 会在 ParsingSQLRouter 进一步处理。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ParsingSQLRouter.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> SQLRouteResult <span class="title">route</span><span class="params">(<span class="keyword">final</span> String logicSQL, <span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> SQLStatement sqlStatement)</span> </span>&#123;</div><div class="line">   <span class="keyword">final</span> Context context = MetricsContext.start(<span class="string">"Route SQL"</span>);</div><div class="line">   SQLRouteResult result = <span class="keyword">new</span> SQLRouteResult(sqlStatement);</div><div class="line">   <span class="comment">// 处理 插入SQL 主键字段</span></div><div class="line">   <span class="keyword">if</span> (sqlStatement <span class="keyword">instanceof</span> InsertStatement &amp;&amp; <span class="keyword">null</span> != ((InsertStatement) sqlStatement).getGeneratedKey()) &#123;</div><div class="line">       processGeneratedKey(parameters, (InsertStatement) sqlStatement, result);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// ... 省略部分代码</span></div><div class="line">&#125;  </div><div class="line"><span class="comment">/**</span></div><div class="line">* 处理 插入SQL 主键字段</div><div class="line">* 当 主键编号 未生成时，&#123;<span class="doctag">@link</span> ShardingRule#generateKey(String)&#125; 进行生成</div><div class="line">* <span class="doctag">@param</span> parameters 占位符参数</div><div class="line">* <span class="doctag">@param</span> insertStatement Insert SQL语句对象</div><div class="line">* <span class="doctag">@param</span> sqlRouteResult SQL路由结果</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processGeneratedKey</span><span class="params">(<span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> InsertStatement insertStatement, <span class="keyword">final</span> SQLRouteResult sqlRouteResult)</span> </span>&#123;</div><div class="line">   GeneratedKey generatedKey = insertStatement.getGeneratedKey();</div><div class="line">   <span class="keyword">if</span> (parameters.isEmpty()) &#123; <span class="comment">// 已有主键，无占位符，INSERT INTO t_order(order_id, user_id) VALUES (1, 100);</span></div><div class="line">       sqlRouteResult.getGeneratedKeys().add(generatedKey.getValue());</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameters.size() == generatedKey.getIndex()) &#123; <span class="comment">// 主键字段不存在存在，INSERT INTO t_order(user_id) VALUES(?);</span></div><div class="line">       Number key = shardingRule.generateKey(insertStatement.getTables().getSingleTableName()); <span class="comment">// 生成主键编号</span></div><div class="line">       parameters.add(key);</div><div class="line">       setGeneratedKeys(sqlRouteResult, key);</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (-<span class="number">1</span> != generatedKey.getIndex()) &#123; <span class="comment">// 主键字段存在，INSERT INTO t_order(order_id, user_id) VALUES(?, ?);</span></div><div class="line">       setGeneratedKeys(sqlRouteResult, (Number) parameters.get(generatedKey.getIndex()));</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 设置 主键编号 到 SQL路由结果</div><div class="line">* <span class="doctag">@param</span> sqlRouteResult SQL路由结果</div><div class="line">* <span class="doctag">@param</span> generatedKey 主键编号</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setGeneratedKeys</span><span class="params">(<span class="keyword">final</span> SQLRouteResult sqlRouteResult, <span class="keyword">final</span> Number generatedKey)</span> </span>&#123;</div><div class="line">   generatedKeys.add(generatedKey);</div><div class="line">   sqlRouteResult.getGeneratedKeys().clear();</div><div class="line">   sqlRouteResult.getGeneratedKeys().addAll(generatedKeys);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>parameters.size() == generatedKey.getIndex()</code> 处对应 <code>#appendGenerateKeyToken()</code> 的 <strong>占位符参数数量 &gt; 0</strong> 情况，此时会生成<strong>分布式主键</strong>。😈 该处是不是可以考虑把生成<strong>分布式主键</strong>挪到 <code>#appendGenerateKeyToken()</code>，这样更加统一一些。</li>
</ul>
<h1>4. SQL 生成</h1>
<p><strong>SQL路由</strong>完后，会生成各数据分片的<strong>执行SQL</strong>。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ParsingSQLRouter.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> SQLRouteResult <span class="title">route</span><span class="params">(<span class="keyword">final</span> String logicSQL, <span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> SQLStatement sqlStatement)</span> </span>&#123;</div><div class="line">   SQLRouteResult result = <span class="keyword">new</span> SQLRouteResult(sqlStatement);</div><div class="line">   <span class="comment">// 省略部分代码... 处理 插入SQL 主键字段</span></div><div class="line">   </div><div class="line">   <span class="comment">// 路由</span></div><div class="line">   RoutingResult routingResult = route(parameters, sqlStatement);</div><div class="line">   </div><div class="line">   <span class="comment">// 省略部分代码... SQL重写引擎</span></div><div class="line">   SQLRewriteEngine rewriteEngine = <span class="keyword">new</span> SQLRewriteEngine(shardingRule, logicSQL, sqlStatement);</div><div class="line">   <span class="keyword">boolean</span> isSingleRouting = routingResult.isSingleRouting();</div><div class="line">   <span class="comment">// 省略部分代码... 处理分页</span></div><div class="line">   <span class="comment">// SQL 重写</span></div><div class="line">   SQLBuilder sqlBuilder = rewriteEngine.rewrite(!isSingleRouting);</div><div class="line">   <span class="comment">// 生成 ExecutionUnit</span></div><div class="line">   <span class="keyword">if</span> (routingResult <span class="keyword">instanceof</span> CartesianRoutingResult) &#123;</div><div class="line">       <span class="keyword">for</span> (CartesianDataSource cartesianDataSource : ((CartesianRoutingResult) routingResult).getRoutingDataSources()) &#123;</div><div class="line">           <span class="keyword">for</span> (CartesianTableReference cartesianTableReference : cartesianDataSource.getRoutingTableReferences()) &#123;</div><div class="line">               <span class="comment">// 👼 生成 SQL</span></div><div class="line">               result.getExecutionUnits().add(<span class="keyword">new</span> SQLExecutionUnit(cartesianDataSource.getDataSource(), rewriteEngine.generateSQL(cartesianTableReference, sqlBuilder)));</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">for</span> (TableUnit each : routingResult.getTableUnits().getTableUnits()) &#123;</div><div class="line">           <span class="comment">// 👼 生成 SQL</span></div><div class="line">           result.getExecutionUnits().add(<span class="keyword">new</span> SQLExecutionUnit(each.getDataSourceName(), rewriteEngine.generateSQL(each, sqlBuilder)));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>调用 <code>RewriteEngine#generateSQL()</code> 生成<strong>执行SQL</strong>。对于笛卡尔积路由结果和简单路由结果传递的参数略有不同：前者使用 CartesianDataSource ( CartesianTableReference )，后者使用路由表单元 ( TableUnit )。对路由结果不是很了解的同学，建议看下 <a href="http://www.yunai.me/Sharding-JDBC/sql-route-2/?mp">《SQL 路由（二）之分库分表路由》</a>。</li>
</ul>
<p><code>RewriteEngine#generateSQL()</code> 对于笛卡尔积路由结果和简单路由结果两种情况，处理上大体是一致的：1. 获得 SQL 相关<strong>逻辑表</strong>对应的<strong>真实表</strong>映射，2. 根据映射改写 SQL 相关<strong>逻辑表</strong>为<strong>真实表</strong>。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLRewriteEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 生成SQL语句.</div><div class="line">* <span class="doctag">@param</span> tableUnit 路由表单元</div><div class="line">* <span class="doctag">@param</span> sqlBuilder SQL构建器</div><div class="line">* <span class="doctag">@return</span> SQL语句</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">generateSQL</span><span class="params">(<span class="keyword">final</span> TableUnit tableUnit, <span class="keyword">final</span> SQLBuilder sqlBuilder)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> sqlBuilder.toSQL(getTableTokens(tableUnit));</div><div class="line">&#125;  </div><div class="line"><span class="comment">/**</span></div><div class="line">* 生成SQL语句.</div><div class="line">* <span class="doctag">@param</span> cartesianTableReference 笛卡尔积路由表单元</div><div class="line">* <span class="doctag">@param</span> sqlBuilder SQL构建器</div><div class="line">* <span class="doctag">@return</span> SQL语句</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">generateSQL</span><span class="params">(<span class="keyword">final</span> CartesianTableReference cartesianTableReference, <span class="keyword">final</span> SQLBuilder sqlBuilder)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> sqlBuilder.toSQL(getTableTokens(cartesianTableReference));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// SQLRewriteEngine.java</span></div><div class="line"><span class="comment">// SQLBuilder.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 生成SQL语句.</div><div class="line">* <span class="doctag">@param</span> tableTokens 占位符集合（逻辑表与真实表映射）</div><div class="line">* <span class="doctag">@return</span> SQL语句</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toSQL</span><span class="params">(<span class="keyword">final</span> Map&lt;String, String&gt; tableTokens)</span> </span>&#123;</div><div class="line">   StringBuilder result = <span class="keyword">new</span> StringBuilder();</div><div class="line">   <span class="keyword">for</span> (Object each : segments) &#123;</div><div class="line">       <span class="keyword">if</span> (each <span class="keyword">instanceof</span> TableToken &amp;&amp; tableTokens.containsKey(((TableToken) each).tableName)) &#123;</div><div class="line">           result.append(tableTokens.get(((TableToken) each).tableName));</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           result.append(each);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>#toSQL()</code> 结果如图： <img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_10/09.png" alt="">
😜 对 <strong>SQL改写</strong> 是不是清晰很多了。</li>
</ul>
<hr>
<p>下面我们以<strong>笛卡尔积路由结果</strong>获得 SQL 相关<strong>逻辑表</strong>对应的<strong>真实表</strong>映射为例子(<em>简单路由结果基本类似而且简单</em>)。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLRewriteEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 获得（笛卡尔积表路由组里的路由表单元逻辑表 和 与其互为BindingTable关系的逻辑表）对应的真实表映射（逻辑表需要在 SQL 中存在）</div><div class="line">* <span class="doctag">@param</span> cartesianTableReference 笛卡尔积表路由组</div><div class="line">* <span class="doctag">@return</span> 集合</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> Map&lt;String, String&gt; <span class="title">getTableTokens</span><span class="params">(<span class="keyword">final</span> CartesianTableReference cartesianTableReference)</span> </span>&#123;</div><div class="line">   Map&lt;String, String&gt; tableTokens = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">   <span class="keyword">for</span> (TableUnit each : cartesianTableReference.getTableUnits()) &#123;</div><div class="line">       tableTokens.put(each.getLogicTableName(), each.getActualTableName());</div><div class="line">       <span class="comment">// 查找 BindingTableRule</span></div><div class="line">       Optional&lt;BindingTableRule&gt; bindingTableRule = shardingRule.findBindingTableRule(each.getLogicTableName());</div><div class="line">       <span class="keyword">if</span> (bindingTableRule.isPresent()) &#123;</div><div class="line">           tableTokens.putAll(getBindingTableTokens(each, bindingTableRule.get()));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> tableTokens;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 获得 BindingTable 关系的逻辑表对应的真实表映射（逻辑表需要在 SQL 中存在）</div><div class="line">* <span class="doctag">@param</span> tableUnit 路由单元</div><div class="line">* <span class="doctag">@param</span> bindingTableRule Binding表规则配置对象</div><div class="line">* <span class="doctag">@return</span> 映射</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> Map&lt;String, String&gt; <span class="title">getBindingTableTokens</span><span class="params">(<span class="keyword">final</span> TableUnit tableUnit, <span class="keyword">final</span> BindingTableRule bindingTableRule)</span> </span>&#123;</div><div class="line">   Map&lt;String, String&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">   <span class="keyword">for</span> (String eachTable : sqlStatement.getTables().getTableNames()) &#123;</div><div class="line">       <span class="keyword">if</span> (!eachTable.equalsIgnoreCase(tableUnit.getLogicTableName()) &amp;&amp; bindingTableRule.hasLogicTable(eachTable)) &#123;</div><div class="line">           result.put(eachTable, bindingTableRule.getBindingActualTable(tableUnit.getDataSourceName(), eachTable, tableUnit.getActualTableName()));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>笛卡尔积表路由组( CartesianTableReference )包含<strong>多个</strong>路由表单元( TableUnit )。每个路由表单元需要遍历。</li>
<li>路由表单元本身包含逻辑表和真实表，直接添加到映射即可。</li>
<li>互为 BindingTable 关系的表只计算一次路由分片，因此<strong>未计算</strong>的真实表需要以其对应的<strong>已计算</strong>的真实表去查找，即 <code>bindingTableRule.getBindingActualTable(tableUnit.getDataSourceName(), eachTable, tableUnit.getActualTableName())</code> 处逻辑。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// BindingTableRule.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 根据其他Binding表真实表名称获取相应的真实Binding表名称.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> dataSource 数据源名称</div><div class="line">* <span class="doctag">@param</span> logicTable 逻辑表名称</div><div class="line">* <span class="doctag">@param</span> otherActualTable 其他真实Binding表名称</div><div class="line">* <span class="doctag">@return</span> 真实Binding表名称</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getBindingActualTable</span><span class="params">(<span class="keyword">final</span> String dataSource, <span class="keyword">final</span> String logicTable, <span class="keyword">final</span> String otherActualTable)</span> </span>&#123;</div><div class="line">   <span class="comment">// 计算 otherActualTable 在其 TableRule 的 actualTable 是第几个</span></div><div class="line">   <span class="keyword">int</span> index = -<span class="number">1</span>;</div><div class="line">   <span class="keyword">for</span> (TableRule each : tableRules) &#123;</div><div class="line">       <span class="keyword">if</span> (each.isDynamic()) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Dynamic table cannot support Binding table."</span>);</div><div class="line">       &#125;</div><div class="line">       index = each.findActualTableIndex(dataSource, otherActualTable);</div><div class="line">       <span class="keyword">if</span> (-<span class="number">1</span> != index) &#123;</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   Preconditions.checkState(-<span class="number">1</span> != index, String.format(<span class="string">"Actual table [%s].[%s] is not in table config"</span>, dataSource, otherActualTable));</div><div class="line">   <span class="comment">// 计算 logicTable 在其 TableRule 的 第index 的 真实表</span></div><div class="line">   <span class="keyword">for</span> (TableRule each : tableRules) &#123;</div><div class="line">       <span class="keyword">if</span> (each.getLogicTable().equalsIgnoreCase(logicTable)) &#123;</div><div class="line">           <span class="keyword">return</span> each.getActualTables().get(index).getTableName();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(String.format(<span class="string">"Cannot find binding actual table, data source: %s, logic table: %s, other actual table: %s"</span>, dataSource, logicTable, otherActualTable));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可能看起来有些绕，我们看张图：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_10/10.png" alt=""></p>
<p><strong>友情提示</strong>：这里不嫌啰嗦在提一句，互为 BindingTable 的表，配置 TableRule 时，<code>actualTables</code> 数量一定要一致，否则多出来的表，可能会无法被路由到。</p>
<h1>666. 彩蛋</h1>
<p>哈哈哈，看完<strong>SQL改写</strong>后，<strong>SQL解析</strong>是不是清晰多了！嘿嘿嘿，反正我现在有点嗨。恩，蛮嗨的。</p>
<p>当然，如果<strong>SQL解析</strong>理解上有点疑惑的你，<strong>欢迎</strong>加我的微信，咱 <strong>1对1</strong> 搞基。关注我的微信公众号：<a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">【芋道源码】</a> 即可获得。</p>
<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<p>道友，转发一波朋友圈可好？</p>
<p>Let's Go! <a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《分布式主键》</a>、<a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《SQL 执行》</a>、<a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《结果聚合》</a> 继续。</p>
<p><em>感谢技术牛逼如你耐心的阅读本文。</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：&lt;/p&gt;
&lt;ol&gt;

    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— SQL 路由（三）之Spring与YAML配置</title>
    <link href="http://www.yunai.me/Sharding-JDBC/sql-route-3/"/>
    <id>http://www.yunai.me/Sharding-JDBC/sql-route-3/</id>
    <published>2017-08-07T16:00:00.000Z</published>
    <updated>2017-08-14T18:34:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<p>抱歉，站坑文。近期看情况更新。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：&lt;/p&gt;
&lt;ol&gt;

    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— SQL 路由（二）之分库分表路由</title>
    <link href="http://www.yunai.me/Sharding-JDBC/sql-route-2/"/>
    <id>http://www.yunai.me/Sharding-JDBC/sql-route-2/</id>
    <published>2017-08-05T16:00:00.000Z</published>
    <updated>2017-08-14T18:34:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<p><strong>本文主要基于 Sharding-JDBC 1.5.0 正式版</strong></p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. SQLRouteResult</a></li>
<li><a href="#">3. 路由策略 x 算法</a></li>
<li><a href="#">4. SQL 路由</a></li>
<li><a href="#">5. DatabaseHintSQLRouter</a></li>
<li><a href="#">6. ParsingSQLRouter</a>
<ul>
<li><a href="#">6.1 SimpleRoutingEngine</a></li>
<li><a href="#">6.2 ComplexRoutingEngine</a></li>
<li><a href="#">6.3 CartesianRoutingEngine</a></li>
<li><a href="#">6.3 ParsingSQLRouter 主#route()</a></li>
</ul>
</li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<h1>1. 概述</h1>
<p>本文分享分表分库<strong>路由</strong>相关的实现。涉及内容如下：</p>
<ol>
<li>SQL 路由结果</li>
<li>路由策略 x 算法</li>
<li>SQL 路由器</li>
</ol>
<p>内容顺序如编号。</p>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>
🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
<p>SQL 路由大体流程如下：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_06/06.png" alt=""></p>
<h1>2. SQLRouteResult</h1>
<p>经过 <strong>SQL解析</strong>、<strong>SQL路由</strong>后，产生<strong>SQL路由结果</strong>，即 SQLRouteResult。根据路由结果，<strong>生成SQL</strong>，<strong>执行SQL</strong>。</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_06/01.png" alt=""></p>
<ul>
<li><code>sqlStatement</code> ：SQL语句对象，经过<strong>SQL解析</strong>的结果对象。</li>
<li><code>executionUnits</code> ：SQL最小执行单元集合。<strong>SQL执行</strong>时，执行每个单元。</li>
<li><code>generatedKeys</code> ：<strong>插入</strong>SQL语句生成的主键编号集合。目前不支持批量插入而使用集合的原因，猜测是为了未来支持批量插入做准备。</li>
</ul>
<h1>3. 路由策略 x 算法</h1>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_04/04.png" alt=""></p>
<p>ShardingStrategy，分片策略。目前支持两种分片：</p>
<p><em>分片资源：在分库策略里指的是库，在分表策略里指的是表。</em></p>
<p>【1】 计算<strong>静态</strong>分片（常用）</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingStrategy.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 计算静态分片.</div><div class="line">* <span class="doctag">@param</span> sqlType SQL语句的类型</div><div class="line">* <span class="doctag">@param</span> availableTargetNames 所有的可用分片资源集合</div><div class="line">* <span class="doctag">@param</span> shardingValues 分片值集合</div><div class="line">* <span class="doctag">@return</span> 分库后指向的数据源名称集合</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doStaticSharding</span><span class="params">(<span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> Collection&lt;ShardingValue&lt;?&gt;&gt; shardingValues)</span> </span>&#123;</div><div class="line">   Collection&lt;String&gt; result = <span class="keyword">new</span> TreeSet&lt;&gt;(String.CASE_INSENSITIVE_ORDER);</div><div class="line">   <span class="keyword">if</span> (shardingValues.isEmpty()) &#123;</div><div class="line">       Preconditions.checkState(!isInsertMultiple(sqlType, availableTargetNames), <span class="string">"INSERT statement should contain sharding value."</span>); <span class="comment">// 插入不能有多资源对象</span></div><div class="line">       result.addAll(availableTargetNames);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       result.addAll(doSharding(shardingValues, availableTargetNames));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 插入SQL 是否插入多个分片</div><div class="line">* <span class="doctag">@param</span> sqlType SQL类型</div><div class="line">* <span class="doctag">@param</span> availableTargetNames 所有的可用分片资源集合</div><div class="line">* <span class="doctag">@return</span> 是否</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isInsertMultiple</span><span class="params">(<span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> SQLType.INSERT == sqlType &amp;&amp; availableTargetNames.size() &gt; <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>插入SQL 需要有片键值，否则无法判断单个分片资源。<em>（Sharding-JDBC 目前仅支持单条记录插入）</em></li>
</ul>
<p>【2】计算<strong>动态</strong>分片</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingStrategy.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 计算动态分片.</div><div class="line">* <span class="doctag">@param</span> shardingValues 分片值集合</div><div class="line">* <span class="doctag">@return</span> 分库后指向的分片资源集合</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doDynamicSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;ShardingValue&lt;?&gt;&gt; shardingValues)</span> </span>&#123;</div><div class="line">   Preconditions.checkState(!shardingValues.isEmpty(), <span class="string">"Dynamic table should contain sharding value."</span>); <span class="comment">// 动态分片必须有分片值</span></div><div class="line">   Collection&lt;String&gt; availableTargetNames = Collections.emptyList();</div><div class="line">   Collection&lt;String&gt; result = <span class="keyword">new</span> TreeSet&lt;&gt;(String.CASE_INSENSITIVE_ORDER);</div><div class="line">   result.addAll(doSharding(shardingValues, availableTargetNames));</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>动态分片对应 <code>TableRule.dynamic=true</code></li>
<li>动态分片必须有分片值</li>
</ul>
<p>😈 闷了，看起来两者没啥区别？答案在<strong>分片算法</strong>上。我们先看 <code>#doSharding()</code> 方法的实现。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingStrategy.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 计算分片</div><div class="line">* <span class="doctag">@param</span> shardingValues 分片值集合</div><div class="line">* <span class="doctag">@param</span> availableTargetNames 所有的可用分片资源集合</div><div class="line">* <span class="doctag">@return</span> 分库后指向的分片资源集合</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> Collection&lt;String&gt; <span class="title">doSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;ShardingValue&lt;?&gt;&gt; shardingValues, <span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames)</span> </span>&#123;</div><div class="line">   <span class="comment">// 无片键</span></div><div class="line">   <span class="keyword">if</span> (shardingAlgorithm <span class="keyword">instanceof</span> NoneKeyShardingAlgorithm) &#123;</div><div class="line">       <span class="keyword">return</span> Collections.singletonList(((NoneKeyShardingAlgorithm) shardingAlgorithm).doSharding(availableTargetNames, shardingValues.iterator().next()));</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 单片键</span></div><div class="line">   <span class="keyword">if</span> (shardingAlgorithm <span class="keyword">instanceof</span> SingleKeyShardingAlgorithm) &#123;</div><div class="line">       SingleKeyShardingAlgorithm&lt;?&gt; singleKeyShardingAlgorithm = (SingleKeyShardingAlgorithm&lt;?&gt;) shardingAlgorithm;</div><div class="line">       ShardingValue shardingValue = shardingValues.iterator().next();</div><div class="line">       <span class="keyword">switch</span> (shardingValue.getType()) &#123;</div><div class="line">           <span class="keyword">case</span> SINGLE:</div><div class="line">               <span class="keyword">return</span> Collections.singletonList(singleKeyShardingAlgorithm.doEqualSharding(availableTargetNames, shardingValue));</div><div class="line">           <span class="keyword">case</span> LIST:</div><div class="line">               <span class="keyword">return</span> singleKeyShardingAlgorithm.doInSharding(availableTargetNames, shardingValue);</div><div class="line">           <span class="keyword">case</span> RANGE:</div><div class="line">               <span class="keyword">return</span> singleKeyShardingAlgorithm.doBetweenSharding(availableTargetNames, shardingValue);</div><div class="line">           <span class="keyword">default</span>:</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(shardingValue.getType().getClass().getName());</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 多片键</span></div><div class="line">   <span class="keyword">if</span> (shardingAlgorithm <span class="keyword">instanceof</span> MultipleKeysShardingAlgorithm) &#123;</div><div class="line">       <span class="keyword">return</span> ((MultipleKeysShardingAlgorithm) shardingAlgorithm).doSharding(availableTargetNames, shardingValues);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(shardingAlgorithm.getClass().getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>无分片键算法：对应 NoneKeyShardingAlgorithm 分片算法接口。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NoneKeyShardingAlgorithm</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;?&gt;&gt; <span class="keyword">extends</span> <span class="title">ShardingAlgorithm</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">doSharding</span><span class="params">(Collection&lt;String&gt; availableTargetNames, ShardingValue&lt;T&gt; shardingValue)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>单片键算法：对应 SingleKeyShardingAlgorithm 分片算法接口。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SingleKeyShardingAlgorithm</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;?&gt;&gt; <span class="keyword">extends</span> <span class="title">ShardingAlgorithm</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">doEqualSharding</span><span class="params">(Collection&lt;String&gt; availableTargetNames, ShardingValue&lt;T&gt; shardingValue)</span></span>;</div><div class="line">    <span class="function">Collection&lt;String&gt; <span class="title">doInSharding</span><span class="params">(Collection&lt;String&gt; availableTargetNames, ShardingValue&lt;T&gt; shardingValue)</span></span>;</div><div class="line">    <span class="function">Collection&lt;String&gt; <span class="title">doBetweenSharding</span><span class="params">(Collection&lt;String&gt; availableTargetNames, ShardingValue&lt;T&gt; shardingValue)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th style="text-align:left">ShardingValueType</th>
<th style="text-align:left">SQL 操作符</th>
<th style="text-align:left">接口方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SINGLE</td>
<td style="text-align:left">=</td>
<td style="text-align:left"><code>#doEqualSharding()</code></td>
</tr>
<tr>
<td style="text-align:left">LIST</td>
<td style="text-align:left">IN</td>
<td style="text-align:left"><code>#doInSharding()</code></td>
</tr>
<tr>
<td style="text-align:left">RANGE</td>
<td style="text-align:left">BETWEEN</td>
<td style="text-align:left"><code>#doBetweenSharding()</code></td>
</tr>
</tbody>
</table>
<ul>
<li>多片键算法：对应 MultipleKeysShardingAlgorithm 分片算法接口。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MultipleKeysShardingAlgorithm</span> <span class="keyword">extends</span> <span class="title">ShardingAlgorithm</span> </span>&#123;</div><div class="line">    <span class="function">Collection&lt;String&gt; <span class="title">doSharding</span><span class="params">(Collection&lt;String&gt; availableTargetNames, Collection&lt;ShardingValue&lt;?&gt;&gt; shardingValues)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>分片算法类结构如下：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_06/02.png" alt=""></p>
<p>来看看 Sharding-JDBC 实现的无需分库的分片算法 NoneDatabaseShardingAlgorithm (NoneTableShardingAlgorithm 基本一模一样)：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NoneDatabaseShardingAlgorithm</span> <span class="keyword">implements</span> <span class="title">SingleKeyDatabaseShardingAlgorithm</span>&lt;<span class="title">String</span>&gt;, <span class="title">MultipleKeysDatabaseShardingAlgorithm</span> </span>&#123; </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> Collection&lt;ShardingValue&lt;?&gt;&gt; shardingValues)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> availableTargetNames;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doEqualSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> ShardingValue&lt;String&gt; shardingValue)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> availableTargetNames.isEmpty() ? <span class="keyword">null</span> : availableTargetNames.iterator().next();</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doInSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> ShardingValue&lt;String&gt; shardingValue)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> availableTargetNames;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doBetweenSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> ShardingValue&lt;String&gt; shardingValue)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> availableTargetNames;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>**一定要注意，NoneXXXXShardingAlgorithm 只适用于无分库/表的需求，否则会是错误的路由结果。**例如，<code>#doEqualSharding()</code> 返回的是第一个分片资源。</li>
</ul>
<hr>
<p>再来看测试目录下实现的<strong>余数基偶分表算法</strong> ModuloTableShardingAlgorithm 的实现：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// com.dangdang.ddframe.rdb.integrate.fixture.ModuloTableShardingAlgorithm.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ModuloTableShardingAlgorithm</span> <span class="keyword">implements</span> <span class="title">SingleKeyTableShardingAlgorithm</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doEqualSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; tableNames, <span class="keyword">final</span> ShardingValue&lt;Integer&gt; shardingValue)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (String each : tableNames) &#123;</div><div class="line">            <span class="keyword">if</span> (each.endsWith(shardingValue.getValue() % <span class="number">2</span> + <span class="string">""</span>)) &#123;</div><div class="line">                <span class="keyword">return</span> each;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doInSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; tableNames, <span class="keyword">final</span> ShardingValue&lt;Integer&gt; shardingValue)</span> </span>&#123;</div><div class="line">        Collection&lt;String&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(tableNames.size());</div><div class="line">        <span class="keyword">for</span> (Integer value : shardingValue.getValues()) &#123;</div><div class="line">            <span class="keyword">for</span> (String tableName : tableNames) &#123;</div><div class="line">                <span class="keyword">if</span> (tableName.endsWith(value % <span class="number">2</span> + <span class="string">""</span>)) &#123;</div><div class="line">                    result.add(tableName);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doBetweenSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; tableNames, <span class="keyword">final</span> ShardingValue&lt;Integer&gt; shardingValue)</span> </span>&#123;</div><div class="line">        Collection&lt;String&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(tableNames.size());</div><div class="line">        Range&lt;Integer&gt; range = shardingValue.getValueRange();</div><div class="line">        <span class="keyword">for</span> (Integer i = range.lowerEndpoint(); i &lt;= range.upperEndpoint(); i++) &#123;</div><div class="line">            <span class="keyword">for</span> (String each : tableNames) &#123;</div><div class="line">                <span class="keyword">if</span> (each.endsWith(i % <span class="number">2</span> + <span class="string">""</span>)) &#123;</div><div class="line">                    result.add(each);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>我们可以参考这个例子编写自己的分片算哟 👼。</li>
<li>多片键分库算法接口实现例子：<a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/d6ac50704f5e45beeeded09a4f0b160c7320b993/sharding-jdbc-core/src/test/java/com/dangdang/ddframe/rdb/integrate/fixture/MultipleKeysModuloDatabaseShardingAlgorithm.java" rel="external nofollow noopener noreferrer" target="_blank">MultipleKeysModuloDatabaseShardingAlgorithm.java</a></li>
</ul>
<hr>
<p>😈 来看看<strong>动态计算分片</strong>需要怎么实现分片算法。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// com.dangdang.ddframe.rdb.integrate.fixture.SingleKeyDynamicModuloTableShardingAlgorithm.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleKeyDynamicModuloTableShardingAlgorithm</span> <span class="keyword">implements</span> <span class="title">SingleKeyTableShardingAlgorithm</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">    * 表前缀</div><div class="line">    */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String tablePrefix;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doEqualSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> ShardingValue&lt;Integer&gt; shardingValue)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> tablePrefix + shardingValue.getValue() % <span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doInSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> ShardingValue&lt;Integer&gt; shardingValue)</span> </span>&#123;</div><div class="line">        Collection&lt;String&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(shardingValue.getValues().size());</div><div class="line">        <span class="keyword">for</span> (Integer value : shardingValue.getValues()) &#123;</div><div class="line">            result.add(tablePrefix + value % <span class="number">10</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doBetweenSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> ShardingValue&lt;Integer&gt; shardingValue)</span> </span>&#123;</div><div class="line">        Collection&lt;String&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(availableTargetNames.size());</div><div class="line">        Range&lt;Integer&gt; range = shardingValue.getValueRange();</div><div class="line">        <span class="keyword">for</span> (Integer i = range.lowerEndpoint(); i &lt;= range.upperEndpoint(); i++) &#123;</div><div class="line">            result.add(tablePrefix + i % <span class="number">10</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>骚年，是不是明白了一些？<strong>动态表</strong>无需把真实表配置到 TableRule，而是通过<strong>分片算法</strong>计算出<strong>真实表</strong>。</li>
</ul>
<h1>4. SQL 路由</h1>
<p>SQLRouter，SQL 路由器接口，共有两种实现：</p>
<ul>
<li>DatabaseHintSQLRouter：通过提示且仅路由至数据库的SQL路由器</li>
<li>ParsingSQLRouter：需要解析的SQL路由器</li>
</ul>
<p>它们实现 <code>#parse()</code>进行<strong>SQL解析</strong>，<code>#route()</code>进行<strong>SQL路由</strong>。</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_06/03.png" alt=""></p>
<hr>
<p>RoutingEngine，路由引擎接口，共有四种实现：</p>
<ul>
<li>DatabaseHintRoutingEngine：基于数据库提示的路由引擎</li>
<li>SimpleRoutingEngine：简单路由引擎</li>
<li>CartesianRoutingEngine：笛卡尔积的库表路由</li>
<li>ComplexRoutingEngine：混合多库表路由引擎</li>
</ul>
<p><strong>ComplexRoutingEngine 根据路由结果会转化成 SimpleRoutingEngine 或 ComplexRoutingEngine</strong>。下文会看相应源码。</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_06/04.png" alt=""></p>
<hr>
<p>路由结果有两种：</p>
<ul>
<li>RoutingResult：简单路由结果</li>
<li>CartesianRoutingResult：笛卡尔积路由结果</li>
</ul>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_06/05.png" alt=""></p>
<p>从图中，我们已经能大概看到两者有什么区别，更具体的下文随源码一起分享。</p>
<p>😈 SQLRouteResult 和 RoutingResult 有什么区别？</p>
<ul>
<li>SQLRouteResult：<strong>整个SQL路由</strong>返回的路由结果</li>
<li>RoutingResult：<strong>RoutingEngine</strong>返回路由结果</li>
</ul>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_06/06.png" alt=""></p>
<hr>
<p>一下子看到这么多**&quot;对象&quot;<strong>，可能有点</strong>紧张**。不要紧张，我们一起在整理下。</p>
<table>
<thead>
<tr>
<th style="text-align:left">路由器</th>
<th style="text-align:left">路由引擎</th>
<th style="text-align:left">路由结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DatabaseHintSQLRouter</td>
<td style="text-align:left">DatabaseHintRoutingEngine</td>
<td style="text-align:left">RoutingResult</td>
</tr>
<tr>
<td style="text-align:left">ParsingSQLRouter</td>
<td style="text-align:left">SimpleRoutingEngine</td>
<td style="text-align:left">RoutingResult</td>
</tr>
<tr>
<td style="text-align:left">ParsingSQLRouter</td>
<td style="text-align:left">CartesianRoutingEngine</td>
<td style="text-align:left">CartesianRoutingResult</td>
</tr>
</tbody>
</table>
<p>😈 逗比博主给大家解决了**&quot;对象&quot;<strong>，是不是应该</strong>分享朋友圈**。</p>
<h1>5. DatabaseHintSQLRouter</h1>
<p>DatabaseHintSQLRouter，基于数据库提示的路由引擎。路由器工厂 SQLRouterFactory 创建路由器时，判断到使用数据库提示( Hint ) 时，创建 DatabaseHintSQLRouter。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DatabaseHintRoutingEngine.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SQLRouter <span class="title">createSQLRouter</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> HintManagerHolder.isDatabaseShardingOnly() ? <span class="keyword">new</span> DatabaseHintSQLRouter(shardingContext) : <span class="keyword">new</span> ParsingSQLRouter(shardingContext);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先来看下 HintManagerHolder、HintManager <strong>部分相关</strong>的代码：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// HintManagerHolder.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HintManagerHolder</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * HintManager 线程变量</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;HintManager&gt; HINT_MANAGER_HOLDER = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 判断是否当前只分库.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@return</span> 是否当前只分库.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDatabaseShardingOnly</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span> != HINT_MANAGER_HOLDER.get() &amp;&amp; HINT_MANAGER_HOLDER.get().isDatabaseShardingOnly();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 清理线索分片管理器的本地线程持有者.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        HINT_MANAGER_HOLDER.remove();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// HintManager.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HintManager</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 库分片值集合</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ShardingKey, ShardingValue&lt;?&gt;&gt; databaseShardingValues = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 只做库分片</div><div class="line">     * &#123;<span class="doctag">@link</span> DatabaseHintRoutingEngine&#125;</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> databaseShardingOnly;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取线索分片管理器实例.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@return</span> 线索分片管理器实例</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HintManager <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        HintManager result = <span class="keyword">new</span> HintManager();</div><div class="line">        HintManagerHolder.setHintManager(result);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置分库分片值.</div><div class="line">     * </div><div class="line">     * &lt;p&gt;分片操作符为等号.该方法适用于只分库的场景&lt;/p&gt;</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> value 分片值</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDatabaseShardingValue</span><span class="params">(<span class="keyword">final</span> Comparable&lt;?&gt; value)</span> </span>&#123;</div><div class="line">        databaseShardingOnly = <span class="keyword">true</span>;</div><div class="line">        addDatabaseShardingValue(HintManagerHolder.DB_TABLE_NAME, HintManagerHolder.DB_COLUMN_NAME, value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么如果要使用 DatabaseHintSQLRouter，我们只需要 <code>HintManager.getInstance().setDatabaseShardingValue(库分片值)</code> 即可。这里有两点要注意下：</p>
<ul>
<li><code>HintManager#getInstance()</code>，每次获取到的都是<strong>新</strong>的 HintManager，多次赋值需要小心。</li>
<li><code>HintManager#close()</code>，使用完需要去清理，避免下个请求读到遗漏的线程变量。</li>
</ul>
<hr>
<p>看看 DatabaseHintSQLRouter 的实现：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DatabaseHintSQLRouter.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> SQLStatement <span class="title">parse</span><span class="params">(<span class="keyword">final</span> String logicSQL, <span class="keyword">final</span> <span class="keyword">int</span> parametersSize)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> SQLJudgeEngine(logicSQL).judge(); <span class="comment">// 只解析 SQL 类型</span></div><div class="line">&#125;  </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="comment">// TODO insert的SQL仍然需要解析自增主键</span></div><div class="line"><span class="function"><span class="keyword">public</span> SQLRouteResult <span class="title">route</span><span class="params">(<span class="keyword">final</span> String logicSQL, <span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> SQLStatement sqlStatement)</span> </span>&#123;</div><div class="line">   Context context = MetricsContext.start(<span class="string">"Route SQL"</span>);</div><div class="line">   SQLRouteResult result = <span class="keyword">new</span> SQLRouteResult(sqlStatement);</div><div class="line">   <span class="comment">// 路由</span></div><div class="line">   RoutingResult routingResult = <span class="keyword">new</span> DatabaseHintRoutingEngine(shardingRule.getDataSourceRule(), shardingRule.getDatabaseShardingStrategy(), sqlStatement.getType())</div><div class="line">           .route();</div><div class="line">   <span class="comment">// SQL最小执行单元</span></div><div class="line">   <span class="keyword">for</span> (TableUnit each : routingResult.getTableUnits().getTableUnits()) &#123;</div><div class="line">       result.getExecutionUnits().add(<span class="keyword">new</span> SQLExecutionUnit(each.getDataSourceName(), logicSQL));</div><div class="line">   &#125;</div><div class="line">   MetricsContext.stop(context);</div><div class="line">   <span class="keyword">if</span> (showSQL) &#123;</div><div class="line">       SQLLogger.logSQL(logicSQL, sqlStatement, result.getExecutionUnits(), parameters);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>#parse()</code> 只解析了 SQL 类型，即 SELECT / UPDATE / DELETE / INSERT 。</li>
<li><strong>使用的分库策略来自 ShardingRule，不是 TableRule，这个一定要留心。<strong>❓因为 SQL 未解析</strong>表名</strong>。因此，即使在 TableRule 设置了 <code>actualTables</code> 属性也是没有效果的。</li>
<li>目前不支持 Sharding-JDBC 的主键自增。❓因为 SQL 未解析<strong>自增主键</strong>。从代码上的<code>TODO</code>应该会支持。</li>
<li><code>HintManager.getInstance().setDatabaseShardingValue(库分片值)</code> 设置的库分片值使用的是  EQUALS，因而分库策略计算出来的只有<strong>一个库分片</strong>，即 TableUnit 只有一个，SQLExecutionUnit 只有一个。</li>
</ul>
<hr>
<p>看看 DatabaseHintSQLRouter 的实现：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DatabaseHintRoutingEngine.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> RoutingResult <span class="title">route</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 从 Hint 获得 分片键值</span></div><div class="line">   Optional&lt;ShardingValue&lt;?&gt;&gt; shardingValue = HintManagerHolder.getDatabaseShardingValue(<span class="keyword">new</span> ShardingKey(HintManagerHolder.DB_TABLE_NAME, HintManagerHolder.DB_COLUMN_NAME));</div><div class="line">   Preconditions.checkState(shardingValue.isPresent());</div><div class="line">   log.debug(<span class="string">"Before database sharding only db:&#123;&#125; sharding values: &#123;&#125;"</span>, dataSourceRule.getDataSourceNames(), shardingValue.get());</div><div class="line">   <span class="comment">// 路由。表分片规则使用的是 ShardingRule 里的。因为没 SQL 解析。</span></div><div class="line">   Collection&lt;String&gt; routingDataSources = databaseShardingStrategy.doStaticSharding(sqlType, dataSourceRule.getDataSourceNames(), Collections.&lt;ShardingValue&lt;?&gt;&gt;singleton(shardingValue.get()));</div><div class="line">   Preconditions.checkState(!routingDataSources.isEmpty(), <span class="string">"no database route info"</span>);</div><div class="line">   log.debug(<span class="string">"After database sharding only result: &#123;&#125;"</span>, routingDataSources);</div><div class="line">   <span class="comment">// 路由结果</span></div><div class="line">   RoutingResult result = <span class="keyword">new</span> RoutingResult();</div><div class="line">   <span class="keyword">for</span> (String each : routingDataSources) &#123;</div><div class="line">       result.getTableUnits().getTableUnits().add(<span class="keyword">new</span> TableUnit(each, <span class="string">""</span>, <span class="string">""</span>));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><strong>只</strong>调用 <code>databaseShardingStrategy.doStaticSharding()</code> 方法计算<strong>库</strong>分片。</li>
<li><code>new TableUnit(each, &quot;&quot;, &quot;&quot;)</code> 的 <code>logicTableName</code>，<code>actualTableName</code> 都是空串，相信原因你已经知道。</li>
</ul>
<h1>6. ParsingSQLRouter</h1>
<p>ParsingSQLRouter，需要解析的SQL路由器。</p>
<p>ParsingSQLRouter 使用 SQLParsingEngine <strong>解析SQL</strong>。对<strong>SQL解析</strong>有兴趣的同学可以看看拙作<a href="http://www.yunai.me/categories/Sharding-JDBC/?mp">《Sharding-JDBC 源码分析 —— SQL 解析》</a>。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ParsingSQLRouter.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> SQLStatement <span class="title">parse</span><span class="params">(<span class="keyword">final</span> String logicSQL, <span class="keyword">final</span> <span class="keyword">int</span> parametersSize)</span> </span>&#123;</div><div class="line">   SQLParsingEngine parsingEngine = <span class="keyword">new</span> SQLParsingEngine(databaseType, logicSQL, shardingRule);</div><div class="line">   Context context = MetricsContext.start(<span class="string">"Parse SQL"</span>);</div><div class="line">   SQLStatement result = parsingEngine.parse();</div><div class="line">   <span class="keyword">if</span> (result <span class="keyword">instanceof</span> InsertStatement) &#123;</div><div class="line">       ((InsertStatement) result).appendGenerateKeyToken(shardingRule, parametersSize);</div><div class="line">   &#125;</div><div class="line">   MetricsContext.stop(context);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>#appendGenerateKeyToken()</code> 会在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《SQL 改写》</a>分享</li>
</ul>
<hr>
<p>ParsingSQLRouter 在路由时，会根据<strong>表情况</strong>使用 SimpleRoutingEngine 或 CartesianRoutingEngine 进行路由。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> RoutingResult <span class="title">route</span><span class="params">(<span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> SQLStatement sqlStatement)</span> </span>&#123;</div><div class="line">   Collection&lt;String&gt; tableNames = sqlStatement.getTables().getTableNames();</div><div class="line">   RoutingEngine routingEngine;</div><div class="line">   <span class="keyword">if</span> (<span class="number">1</span> == tableNames.size() || shardingRule.isAllBindingTables(tableNames)) &#123;</div><div class="line">       routingEngine = <span class="keyword">new</span> SimpleRoutingEngine(shardingRule, parameters, tableNames.iterator().next(), sqlStatement);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="comment">// TODO 可配置是否执行笛卡尔积</span></div><div class="line">       routingEngine = <span class="keyword">new</span> ComplexRoutingEngine(shardingRule, parameters, tableNames, sqlStatement);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> routingEngine.route();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>当只进行<strong>一张表</strong>或者<strong>多表互为BindingTable关系</strong>时，使用 SimpleRoutingEngine 简单路由引擎。<strong>多表互为BindingTable关系</strong>时，每张表的路由结果是相同的，所以只要计算第一张表的分片即可。</li>
<li><code>tableNames.iterator().next()</code> 注意下，<code>tableNames</code> 变量是 <code>new TreeMap&lt;&gt;(String.CASE_INSENSITIVE_ORDER)</code>。所以 <code>SELECT * FROM t_order o join t_order_item i ON o.order_id = i.order_id</code> 即使 <code>t_order_item</code> 排在 <code>t_order</code> 前面，<code>tableNames.iterator().next()</code> 返回的是 <code>t_order</code>。当 <code>t_order</code> 和 <code>t_order_item</code> 为 <strong>BindingTable关系</strong> 时，计算的是 <code>t_order</code> 路由分片。</li>
<li>BindingTable关系在 ShardingRule 的 <code>tableRules</code> 配置。配置该关系 TableRule 有如下需要遵守的规则：
<ul>
<li>分片策略与算法相同</li>
<li>数据源配置对象相同</li>
<li>真实表<strong>数量</strong>相同</li>
</ul>
</li>
</ul>
<p><strong>举个例子</strong>：</p>
<ul>
<li>SQL ：<code>SELECT * FROM t_order o join t_order_item i ON o.order_id = i.order_id</code></li>
<li>分库分表情况：</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">multi_db_multi_table_01</div><div class="line">  ├── t_order_0                        ├── t_order_item_01</div><div class="line">  └── t_order_1                        ├── t_order_item_02</div><div class="line">                                       ├── t_order_item_03</div><div class="line">                                       ├── t_order_item_04</div><div class="line">multi_db_multi_table_02</div><div class="line">  ├── t_order_0                        ├── t_order_item_01</div><div class="line">  └── t_order_1                        ├── t_order_item_02</div><div class="line">                                       ├── t_order_item_03</div><div class="line">                                       ├── t_order_item_04</div></pre></td></tr></table></figure></p>
<p>最终执行的SQL如下：</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_item_01 i <span class="keyword">JOIN</span> t_order_01 o <span class="keyword">ON</span> o.order_id = i.order_id </div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_item_01 i <span class="keyword">JOIN</span> t_order_01 o <span class="keyword">ON</span> o.order_id = i.order_id </div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_item_02 i <span class="keyword">JOIN</span> t_order_02 o <span class="keyword">ON</span> o.order_id = i.order_id</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_item_02 i <span class="keyword">JOIN</span> t_order_02 o <span class="keyword">ON</span> o.order_id = i.order_id</div></pre></td></tr></table></figure></p>
<ul>
<li><code>t_order_item_03</code>、<code>t_order_item_04</code> 无法被查询到。</li>
</ul>
<p>下面我们看看 <code>#isAllBindingTables()</code> 如何实现<strong>多表互为BindingTable关系</strong>。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingRule.java</span></div><div class="line"><span class="comment">// 调用顺序 #isAllBindingTables()=&gt;#filterAllBindingTables()=&gt;#findBindingTableRule()=&gt;#findBindingTableRule()</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 判断逻辑表名称集合是否全部属于Binding表.</div><div class="line">* <span class="doctag">@param</span> logicTables 逻辑表名称集合</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAllBindingTables</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; logicTables)</span> </span>&#123;</div><div class="line">   Collection&lt;String&gt; bindingTables = filterAllBindingTables(logicTables);</div><div class="line">   <span class="keyword">return</span> !bindingTables.isEmpty() &amp;&amp; bindingTables.containsAll(logicTables);</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 过滤出所有的Binding表名称.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">filterAllBindingTables</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; logicTables)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (logicTables.isEmpty()) &#123;</div><div class="line">       <span class="keyword">return</span> Collections.emptyList();</div><div class="line">   &#125;</div><div class="line">   Optional&lt;BindingTableRule&gt; bindingTableRule = findBindingTableRule(logicTables);</div><div class="line">   <span class="keyword">if</span> (!bindingTableRule.isPresent()) &#123;</div><div class="line">       <span class="keyword">return</span> Collections.emptyList();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 交集</span></div><div class="line">   Collection&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(bindingTableRule.get().getAllLogicTables());</div><div class="line">   result.retainAll(logicTables);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 获得包含&lt;strong&gt;任一&lt;/strong&gt;在逻辑表名称集合的binding表配置的逻辑表名称集合</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> Optional&lt;BindingTableRule&gt; <span class="title">findBindingTableRule</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; logicTables)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (String each : logicTables) &#123;</div><div class="line">       Optional&lt;BindingTableRule&gt; result = findBindingTableRule(each);</div><div class="line">       <span class="keyword">if</span> (result.isPresent()) &#123;</div><div class="line">           <span class="keyword">return</span> result;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> Optional.absent();</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 根据逻辑表名称获取binding表配置的逻辑表名称集合.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> Optional&lt;BindingTableRule&gt; <span class="title">findBindingTableRule</span><span class="params">(<span class="keyword">final</span> String logicTable)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (BindingTableRule each : bindingTableRules) &#123;</div><div class="line">       <span class="keyword">if</span> (each.hasLogicTable(logicTable)) &#123;</div><div class="line">           <span class="keyword">return</span> Optional.of(each);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> Optional.absent();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>逻辑看起来比较长，目的是找到一条 BindingTableRule 包含<strong>所有</strong>逻辑表集合</li>
<li>不支持<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E9%80%92%E5%85%B3%E7%B3%BB" rel="external nofollow noopener noreferrer" target="_blank">《传递关系》</a>：配置 BindingTableRule 时，<strong>相同绑定关系一定要配置在一条</strong>，必须是 <code>[a, b, c]</code>，而不能是 <code>[a, b], [b, c]</code>。</li>
</ul>
<h2>6.1 SimpleRoutingEngine</h2>
<p>SimpleRoutingEngine，简单路由引擎。</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_06/07.png" alt=""></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SimpleRoutingEngine.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> Collection&lt;String&gt; <span class="title">routeDataSources</span><span class="params">(<span class="keyword">final</span> TableRule tableRule)</span> </span>&#123;</div><div class="line">   DatabaseShardingStrategy strategy = shardingRule.getDatabaseShardingStrategy(tableRule);</div><div class="line">   List&lt;ShardingValue&lt;?&gt;&gt; shardingValues = HintManagerHolder.isUseShardingHint() ? getDatabaseShardingValuesFromHint(strategy.getShardingColumns())</div><div class="line">           : getShardingValues(strategy.getShardingColumns());</div><div class="line">   Collection&lt;String&gt; result = strategy.doStaticSharding(sqlStatement.getType(), tableRule.getActualDatasourceNames(), shardingValues);</div><div class="line">   Preconditions.checkState(!result.isEmpty(), <span class="string">"no database route info"</span>);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> List&lt;ShardingValue&lt;?&gt;&gt; getShardingValues(<span class="keyword">final</span> Collection&lt;String&gt; shardingColumns) &#123;</div><div class="line">   List&lt;ShardingValue&lt;?&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(shardingColumns.size());</div><div class="line">   <span class="keyword">for</span> (String each : shardingColumns) &#123;</div><div class="line">       Optional&lt;Condition&gt; condition = sqlStatement.getConditions().find(<span class="keyword">new</span> Column(each, logicTableName));</div><div class="line">       <span class="keyword">if</span> (condition.isPresent()) &#123;</div><div class="line">           result.add(condition.get().getShardingValue(parameters));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>可以使用 HintManager 设置<strong>库</strong>分片值进行<strong>强制路由</strong>。</li>
<li><code>#getShardingValues()</code> 我们看到了<a href="http://www.yunai.me/Sharding-JDBC/sql-parse-2/">《SQL 解析（二）之SQL解析》</a>分享的 Condition 对象。之前我们提到过<strong>Parser 半理解SQL的目的之一是：提炼分片上下文</strong>，此处即是该目的的体现。Condition 里只放<strong>明确</strong>影响路由的条件，例如：<code>order_id = 1</code>, <code>order_id IN (1, 2)</code>, <code>order_id BETWEEN (1, 3)</code>，不放<strong>无法计算</strong>的条件，例如：<code>o.order_id = i.order_id</code>。该方法里，使用<strong>分片键</strong>从 Condition 查找 <strong>分片值</strong>。🙂 是不是对 Condition 的认识更加清晰一丢丢落。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SimpleRoutingEngine.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> Collection&lt;String&gt; <span class="title">routeTables</span><span class="params">(<span class="keyword">final</span> TableRule tableRule, <span class="keyword">final</span> Collection&lt;String&gt; routedDataSources)</span> </span>&#123;</div><div class="line">   TableShardingStrategy strategy = shardingRule.getTableShardingStrategy(tableRule);</div><div class="line">   List&lt;ShardingValue&lt;?&gt;&gt; shardingValues = HintManagerHolder.isUseShardingHint() ? getTableShardingValuesFromHint(strategy.getShardingColumns())</div><div class="line">           : getShardingValues(strategy.getShardingColumns());</div><div class="line">   Collection&lt;String&gt; result = tableRule.isDynamic() ? strategy.doDynamicSharding(shardingValues)</div><div class="line">           : strategy.doStaticSharding(sqlStatement.getType(), tableRule.getActualTableNames(routedDataSources), shardingValues);</div><div class="line">   Preconditions.checkState(!result.isEmpty(), <span class="string">"no table route info"</span>);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>可以使用 HintManager 设置<strong>表</strong>分片值进行<strong>强制路由</strong>。</li>
<li>根据 <code>dynamic</code> 属性来判断调用 <code>#doDynamicSharding()</code> 还是 <code>#doStaticSharding()</code> 计算分片。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SimpleRoutingEngine.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> RoutingResult <span class="title">generateRoutingResult</span><span class="params">(<span class="keyword">final</span> TableRule tableRule, <span class="keyword">final</span> Collection&lt;String&gt; routedDataSources, <span class="keyword">final</span> Collection&lt;String&gt; routedTables)</span> </span>&#123;</div><div class="line">   RoutingResult result = <span class="keyword">new</span> RoutingResult();</div><div class="line">   <span class="keyword">for</span> (DataNode each : tableRule.getActualDataNodes(routedDataSources, routedTables)) &#123;</div><div class="line">       result.getTableUnits().getTableUnits().add(<span class="keyword">new</span> TableUnit(each.getDataSourceName(), logicTableName, each.getTableName()));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// TableRule.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 根据数据源名称过滤获取真实数据单元.</div><div class="line">* <span class="doctag">@param</span> targetDataSources 数据源名称集合</div><div class="line">* <span class="doctag">@param</span> targetTables 真实表名称集合</div><div class="line">* <span class="doctag">@return</span> 真实数据单元</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> Collection&lt;DataNode&gt; <span class="title">getActualDataNodes</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; targetDataSources, <span class="keyword">final</span> Collection&lt;String&gt; targetTables)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> dynamic ? getDynamicDataNodes(targetDataSources, targetTables) : getStaticDataNodes(targetDataSources, targetTables);</div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">private</span> Collection&lt;DataNode&gt; <span class="title">getDynamicDataNodes</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; targetDataSources, <span class="keyword">final</span> Collection&lt;String&gt; targetTables)</span> </span>&#123;</div><div class="line">   Collection&lt;DataNode&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(targetDataSources.size() * targetTables.size());</div><div class="line">   <span class="keyword">for</span> (String targetDataSource : targetDataSources) &#123;</div><div class="line">       <span class="keyword">for</span> (String targetTable : targetTables) &#123;</div><div class="line">           result.add(<span class="keyword">new</span> DataNode(targetDataSource, targetTable));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125; </div><div class="line"><span class="function"><span class="keyword">private</span> Collection&lt;DataNode&gt; <span class="title">getStaticDataNodes</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; targetDataSources, <span class="keyword">final</span> Collection&lt;String&gt; targetTables)</span> </span>&#123;</div><div class="line">   Collection&lt;DataNode&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(actualTables.size());</div><div class="line">   <span class="keyword">for</span> (DataNode each : actualTables) &#123;</div><div class="line">       <span class="keyword">if</span> (targetDataSources.contains(each.getDataSourceName()) &amp;&amp; targetTables.contains(each.getTableName())) &#123;</div><div class="line">           result.add(each);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>在 SimpleRoutingEngine 只生成了当前表的 TableUnits。如果存在<strong>与其互为BindingTable关系</strong>的表的 TableUnits 怎么获得？你可以想想噢，当然在后文<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《SQL 改写》</a>也会给出答案，看看和你想的是否一样。</li>
</ul>
<h2>6.2 ComplexRoutingEngine</h2>
<p>ComplexRoutingEngine，混合多库表路由引擎。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ComplexRoutingEngine.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> RoutingResult <span class="title">route</span><span class="params">()</span> </span>&#123;</div><div class="line">   Collection&lt;RoutingResult&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(logicTables.size());</div><div class="line">   Collection&lt;String&gt; bindingTableNames = <span class="keyword">new</span> TreeSet&lt;&gt;(String.CASE_INSENSITIVE_ORDER);</div><div class="line">   <span class="comment">// 计算每个逻辑表的简单路由分片</span></div><div class="line">   <span class="keyword">for</span> (String each : logicTables) &#123;</div><div class="line">       Optional&lt;TableRule&gt; tableRule = shardingRule.tryFindTableRule(each);</div><div class="line">       <span class="keyword">if</span> (tableRule.isPresent()) &#123;</div><div class="line">           <span class="keyword">if</span> (!bindingTableNames.contains(each)) &#123;</div><div class="line">               result.add(<span class="keyword">new</span> SimpleRoutingEngine(shardingRule, parameters, tableRule.get().getLogicTable(), sqlStatement).route());</div><div class="line">           &#125;</div><div class="line">           <span class="comment">// 互为 BindingTable 关系的表加到 bindingTableNames 里，不重复计算分片</span></div><div class="line">           Optional&lt;BindingTableRule&gt; bindingTableRule = shardingRule.findBindingTableRule(each);</div><div class="line">           <span class="keyword">if</span> (bindingTableRule.isPresent()) &#123;</div><div class="line">               bindingTableNames.addAll(Lists.transform(bindingTableRule.get().getTableRules(), <span class="keyword">new</span> Function&lt;TableRule, String&gt;() &#123;</div><div class="line">                   </div><div class="line">                   <span class="meta">@Override</span></div><div class="line">                   <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(<span class="keyword">final</span> TableRule input)</span> </span>&#123;</div><div class="line">                       <span class="keyword">return</span> input.getLogicTable();</div><div class="line">                   &#125;</div><div class="line">               &#125;));</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   log.trace(<span class="string">"mixed tables sharding result: &#123;&#125;"</span>, result);</div><div class="line">   <span class="keyword">if</span> (result.isEmpty()) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ShardingJdbcException(<span class="string">"Cannot find table rule and default data source with logic tables: '%s'"</span>, logicTables);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 防御性编程。shardingRule#isAllBindingTables() 已经过滤了这个情况。</span></div><div class="line">   <span class="keyword">if</span> (<span class="number">1</span> == result.size()) &#123;</div><div class="line">       <span class="keyword">return</span> result.iterator().next();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 交给 CartesianRoutingEngine 形成笛卡尔积结果</span></div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> CartesianRoutingEngine(result).route();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>ComplexRoutingEngine 计算每个逻辑表的简单路由分片，路由结果交给 CartesianRoutingEngine <strong>继续</strong>路由形成笛卡尔积结果。</li>
</ul>
<p><img src="http://www.yunai.me//images/Sharding-JDBC/2017_08_06/08.png" alt=""></p>
<ul>
<li>由于目前 ComplexRoutingEngine 路由前已经判断<strong>全部表互为 BindingTable 关系</strong>，因而不会出现 <code>result.size == 1</code>，属于防御性编程。</li>
<li><strong>部分表互为 BindingTable 关系</strong>时，ComplexRoutingEngine 不重复计算分片。</li>
</ul>
<h2>6.3 CartesianRoutingEngine</h2>
<p>CartesianRoutingEngine，笛卡尔积的库表路由。</p>
<p>实现逻辑上<strong>相对</strong>复杂，请保持耐心哟，😈 其实目的就是实现<strong>连连看</strong>的效果：</p>
<ul>
<li>RoutingResult[0] <code>x</code> RoutingResult[1] …… <code>x</code> RoutingResult[n- 1] <code>x</code> RoutingResult[n]</li>
<li><strong>同库</strong> 才可以进行笛卡尔积</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// CartesianRoutingEngine.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> CartesianRoutingResult <span class="title">route</span><span class="params">()</span> </span>&#123;</div><div class="line">   CartesianRoutingResult result = <span class="keyword">new</span> CartesianRoutingResult();</div><div class="line">   <span class="keyword">for</span> (Entry&lt;String, Set&lt;String&gt;&gt; entry : getDataSourceLogicTablesMap().entrySet()) &#123; <span class="comment">// Entry&lt;数据源（库）, Set&lt;逻辑表&gt;&gt; entry</span></div><div class="line">       <span class="comment">// 获得当前数据源（库）的 路由表单元分组</span></div><div class="line">       List&lt;Set&lt;String&gt;&gt; actualTableGroups = getActualTableGroups(entry.getKey(), entry.getValue()); <span class="comment">// List&lt;Set&lt;真实表&gt;&gt;</span></div><div class="line">       List&lt;Set&lt;TableUnit&gt;&gt; tableUnitGroups = toTableUnitGroups(entry.getKey(), actualTableGroups);</div><div class="line">       <span class="comment">// 笛卡尔积，并合并结果</span></div><div class="line">       result.merge(entry.getKey(), getCartesianTableReferences(Sets.cartesianProduct(tableUnitGroups)));</div><div class="line">   &#125;</div><div class="line">   log.trace(<span class="string">"cartesian tables sharding result: &#123;&#125;"</span>, result);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>第一步，获得<strong>同库</strong>对应的<strong>逻辑表</strong>集合，即 <strong>Entry&lt;数据源（库）, Set&lt;逻辑表&gt;&gt; entry</strong>。</li>
<li>第二步，遍历<strong>数据源（库）</strong>，获得当前<strong>数据源（库）<strong>的</strong>路由表单元分组</strong>。</li>
<li>第三步，对<strong>路由表单元分组</strong>进行<strong>笛卡尔积</strong>，并合并到路由结果。</li>
</ul>
<p>下面，我们一起逐步看看代码实现。</p>
<ul>
<li>SQL ：<code>SELECT * FROM t_order o join t_order_item i ON o.order_id = i.order_id</code></li>
<li>分库分表情况：</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">multi_db_multi_table_01</div><div class="line">  ├── t_order_0                        ├── t_order_item_01</div><div class="line">  └── t_order_1                        ├── t_order_item_02</div><div class="line">multi_db_multi_table_02</div><div class="line">  ├── t_order_0                        ├── t_order_item_01</div><div class="line">  └── t_order_1                        ├── t_order_item_02</div></pre></td></tr></table></figure></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 第一步</span></div><div class="line"><span class="comment">// CartesianRoutingEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 获得同库对应的逻辑表集合</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> Map&lt;String, Set&lt;String&gt;&gt; getDataSourceLogicTablesMap() &#123;</div><div class="line">   Collection&lt;String&gt; intersectionDataSources = getIntersectionDataSources();</div><div class="line">   Map&lt;String, Set&lt;String&gt;&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;(routingResults.size());</div><div class="line">   <span class="comment">// 获得同库对应的逻辑表集合</span></div><div class="line">   <span class="keyword">for</span> (RoutingResult each : routingResults) &#123;</div><div class="line">       <span class="keyword">for</span> (Entry&lt;String, Set&lt;String&gt;&gt; entry : each.getTableUnits().getDataSourceLogicTablesMap(intersectionDataSources).entrySet()) &#123; <span class="comment">// 过滤掉不在数据源（库）交集的逻辑表</span></div><div class="line">           <span class="keyword">if</span> (result.containsKey(entry.getKey())) &#123;</div><div class="line">               result.get(entry.getKey()).addAll(entry.getValue());</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               result.put(entry.getKey(), entry.getValue());</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 获得所有路由结果里的数据源（库）交集</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> Collection&lt;String&gt; <span class="title">getIntersectionDataSources</span><span class="params">()</span> </span>&#123;</div><div class="line">   Collection&lt;String&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">   <span class="keyword">for</span> (RoutingResult each : routingResults) &#123;</div><div class="line">       <span class="keyword">if</span> (result.isEmpty()) &#123;</div><div class="line">           result.addAll(each.getTableUnits().getDataSourceNames());</div><div class="line">       &#125;</div><div class="line">       result.retainAll(each.getTableUnits().getDataSourceNames()); <span class="comment">// 交集</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>#getDataSourceLogicTablesMap()</code> 返回如图：<img src="http://www.yunai.me//images/Sharding-JDBC/2017_08_06/09.png" alt=""></li>
</ul>
<hr>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 第二步</span></div><div class="line"><span class="comment">// CartesianRoutingEngine.java</span></div><div class="line"><span class="keyword">private</span> List&lt;Set&lt;String&gt;&gt; getActualTableGroups(<span class="keyword">final</span> String dataSource, <span class="keyword">final</span> Set&lt;String&gt; logicTables) &#123;</div><div class="line">   List&lt;Set&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(logicTables.size());</div><div class="line">   <span class="keyword">for</span> (RoutingResult each : routingResults) &#123;</div><div class="line">       result.addAll(each.getTableUnits().getActualTableNameGroups(dataSource, logicTables));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> List&lt;Set&lt;TableUnit&gt;&gt; toTableUnitGroups(<span class="keyword">final</span> String dataSource, <span class="keyword">final</span> List&lt;Set&lt;String&gt;&gt; actualTableGroups) &#123;</div><div class="line">   List&lt;Set&lt;TableUnit&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(actualTableGroups.size());</div><div class="line">   <span class="keyword">for</span> (Set&lt;String&gt; each : actualTableGroups) &#123;</div><div class="line">       result.add(<span class="keyword">new</span> HashSet&lt;&gt;(Lists.transform(<span class="keyword">new</span> ArrayList&lt;&gt;(each), <span class="keyword">new</span> Function&lt;String, TableUnit&gt;() &#123;</div><div class="line">    </div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> TableUnit <span class="title">apply</span><span class="params">(<span class="keyword">final</span> String input)</span> </span>&#123;</div><div class="line">               <span class="keyword">return</span> findTableUnit(dataSource, input);</div><div class="line">           &#125;</div><div class="line">       &#125;)));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>#getActualTableGroups()</code> 返回如图：<img src="http://www.yunai.me//images/Sharding-JDBC/2017_08_06/10.png" alt=""></li>
<li><code>#toTableUnitGroups()</code> 返回如图：<img src="http://www.yunai.me//images/Sharding-JDBC/2017_08_06/11.png" alt=""></li>
</ul>
<hr>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// CartesianRoutingEngine.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> List&lt;CartesianTableReference&gt; <span class="title">getCartesianTableReferences</span><span class="params">(<span class="keyword">final</span> Set&lt;List&lt;TableUnit&gt;&gt; cartesianTableUnitGroups)</span> </span>&#123;</div><div class="line">   List&lt;CartesianTableReference&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(cartesianTableUnitGroups.size());</div><div class="line">   <span class="keyword">for</span> (List&lt;TableUnit&gt; each : cartesianTableUnitGroups) &#123;</div><div class="line">       result.add(<span class="keyword">new</span> CartesianTableReference(each));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// CartesianRoutingResult.java</span></div><div class="line"><span class="meta">@Getter</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;CartesianDataSource&gt; routingDataSources = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">final</span> String dataSource, <span class="keyword">final</span> Collection&lt;CartesianTableReference&gt; routingTableReferences)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (CartesianTableReference each : routingTableReferences) &#123;</div><div class="line">       merge(dataSource, each);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">final</span> String dataSource, <span class="keyword">final</span> CartesianTableReference routingTableReference)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (CartesianDataSource each : routingDataSources) &#123;</div><div class="line">       <span class="keyword">if</span> (each.getDataSource().equalsIgnoreCase(dataSource)) &#123;</div><div class="line">           each.getRoutingTableReferences().add(routingTableReference);</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   routingDataSources.add(<span class="keyword">new</span> CartesianDataSource(dataSource, routingTableReference));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p><code>Sets.cartesianProduct(tableUnitGroups)</code> 返回如图（Guava 工具库真强大）：<img src="http://www.yunai.me//images/Sharding-JDBC/2017_08_06/12.png" alt=""></p>
</li>
<li>
<p><code>#getCartesianTableReferences()</code> 返回如图：<img src="http://www.yunai.me//images/Sharding-JDBC/2017_08_06/13.png" alt=""></p>
<p>CartesianTableReference，笛卡尔积表<strong>路由组</strong>，包含<strong>多条</strong> TableUnit，即 TableUnit[0] <code>x</code> TableUnit[1] …… <code>x</code> TableUnit[n]。例如图中：<code>t_order_01 x t_order_item_02</code>，最终转换成 SQL 为 <code>SELECT * FROM t_order_01 o join t_order_item_02 i ON o.order_id = i.order_id</code>。</p>
</li>
<li>
<p><code>#merge()</code> 合并笛卡尔积路由结果。CartesianRoutingResult 包含多个 CartesianDataSource，因此需要将 CartesianTableReference 合并（添加）到对应的 CartesianDataSource。当然，目前在实现时已经是按照**数据源（库）**生成对应的 CartesianTableReference。</p>
</li>
</ul>
<h2>6.4 ParsingSQLRouter 主#route()</h2>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ParsingSQLRouter.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> SQLRouteResult <span class="title">route</span><span class="params">(<span class="keyword">final</span> String logicSQL, <span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> SQLStatement sqlStatement)</span> </span>&#123;</div><div class="line">   <span class="keyword">final</span> Context context = MetricsContext.start(<span class="string">"Route SQL"</span>);</div><div class="line">   SQLRouteResult result = <span class="keyword">new</span> SQLRouteResult(sqlStatement);</div><div class="line">   <span class="comment">// 处理 插入SQL 主键字段</span></div><div class="line">   <span class="keyword">if</span> (sqlStatement <span class="keyword">instanceof</span> InsertStatement &amp;&amp; <span class="keyword">null</span> != ((InsertStatement) sqlStatement).getGeneratedKey()) &#123;</div><div class="line">       processGeneratedKey(parameters, (InsertStatement) sqlStatement, result);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 🐒🐒🐒 路由 🐒🐒🐒</span></div><div class="line">   RoutingResult routingResult = route(parameters, sqlStatement);</div><div class="line">   <span class="comment">// SQL重写引擎</span></div><div class="line">   SQLRewriteEngine rewriteEngine = <span class="keyword">new</span> SQLRewriteEngine(shardingRule, logicSQL, sqlStatement);</div><div class="line">   <span class="keyword">boolean</span> isSingleRouting = routingResult.isSingleRouting();</div><div class="line">   <span class="comment">// 处理分页</span></div><div class="line">   <span class="keyword">if</span> (sqlStatement <span class="keyword">instanceof</span> SelectStatement &amp;&amp; <span class="keyword">null</span> != ((SelectStatement) sqlStatement).getLimit()) &#123;</div><div class="line">       processLimit(parameters, (SelectStatement) sqlStatement, isSingleRouting);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// SQL 重写</span></div><div class="line">   SQLBuilder sqlBuilder = rewriteEngine.rewrite(!isSingleRouting);</div><div class="line">   <span class="comment">// 生成 ExecutionUnit</span></div><div class="line">   <span class="keyword">if</span> (routingResult <span class="keyword">instanceof</span> CartesianRoutingResult) &#123;</div><div class="line">       <span class="keyword">for</span> (CartesianDataSource cartesianDataSource : ((CartesianRoutingResult) routingResult).getRoutingDataSources()) &#123;</div><div class="line">           <span class="keyword">for</span> (CartesianTableReference cartesianTableReference : cartesianDataSource.getRoutingTableReferences()) &#123;</div><div class="line">               result.getExecutionUnits().add(<span class="keyword">new</span> SQLExecutionUnit(cartesianDataSource.getDataSource(), rewriteEngine.generateSQL(cartesianTableReference, sqlBuilder))); <span class="comment">// 生成 SQL</span></div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">for</span> (TableUnit each : routingResult.getTableUnits().getTableUnits()) &#123;</div><div class="line">           result.getExecutionUnits().add(<span class="keyword">new</span> SQLExecutionUnit(each.getDataSourceName(), rewriteEngine.generateSQL(each, sqlBuilder))); <span class="comment">// 生成 SQL</span></div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   MetricsContext.stop(context);</div><div class="line">   <span class="comment">// 打印 SQL</span></div><div class="line">   <span class="keyword">if</span> (showSQL) &#123;</div><div class="line">       SQLLogger.logSQL(logicSQL, sqlStatement, result.getExecutionUnits(), parameters);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>RoutingResult routingResult = route(parameters, sqlStatement);</code> <strong>调用</strong>的就是上文分析的 SimpleRoutingEngine、ComplexRoutingEngine、CartesianRoutingEngine 的 <code>#route()</code> 方法。</li>
<li><code>#processGeneratedKey()</code>、<code>#processLimit()</code>、<code>#rewrite()</code>、<code>#generateSQL()</code> 等会放在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《SQL 改写》</a> 分享。</li>
</ul>
<h1>666. 彩蛋</h1>
<p>篇幅有些长，希望能让大家对<strong>路由</strong>有比较完整的认识。<br>
如果内容有错误，烦请您指正，我会<strong>认真</strong>修改。<br>
如果表述不清晰，不太理解的，欢迎加我微信（wangwenbin-server）一起探讨。</p>
<p>谢谢你技术这么好，还<strong>耐心</strong>看完了本文。</p>
<p>强制路由 HintManager 讲的相对略过，可以看如下内容进一步了解：</p>
<ol>
<li><a href="http://dangdangdotcom.github.io/sharding-jdbc/02-guide/hint-sharding-value/" rel="external nofollow noopener noreferrer" target="_blank">《官方文档-强制路由》</a></li>
<li><a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/9354031743b63e44cbded5618980ae71a15f0260/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/api/HintManager.java#L41" rel="external nofollow noopener noreferrer" target="_blank">HintManager.java 源码</a></li>
</ol>
<p>厚着脸皮，道友，辛苦<strong>分享朋友圈</strong>可好？！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：&lt;/p&gt;
&lt;ol&gt;

    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— SQL 路由（一）之分库分表配置</title>
    <link href="http://www.yunai.me/Sharding-JDBC/sql-route-1/"/>
    <id>http://www.yunai.me/Sharding-JDBC/sql-route-1/</id>
    <published>2017-08-03T16:00:00.000Z</published>
    <updated>2017-08-14T18:34:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<p><strong>本文主要基于 Sharding-JDBC 1.5.0 正式版</strong></p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. TableRule</a>
<ul>
<li><a href="#">2.1 logicTable</a></li>
<li><a href="#">2.2 数据单元</a>
<ul>
<li><a href="#">2.2.1 DataNode</a></li>
<li><a href="#">2.2.2 DynamicDataNode</a></li>
</ul>
</li>
<li><a href="#">2.3 分库/分表策略</a></li>
<li><a href="#">2.4 主键生成</a></li>
</ul>
</li>
<li><a href="#">3. ShardingRule</a>
<ul>
<li><a href="#">3.1 dataSourceRule</a></li>
<li><a href="#">3.2 tableRules</a></li>
<li><a href="#">3.3 bindingTableRules</a></li>
</ul>
</li>
<li><a href="#">4. ShardingStrategy</a></li>
<li><a href="#">5. ShardingAlgorithm</a></li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<h1>1. 概述</h1>
<p>😆<a href="http://www.yunai.me/categories/Sharding-JDBC/?self">《SQL 解析》</a> 已经告于段落，我们要开始新的旅程：<a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《SQL 路由》</a>。相比<strong>SQL解析</strong>，路由会容易理解很多，骗人是小🐷。整个系列预计会拆分成<strong>三小篇</strong>文章：</p>
<ol>
<li>《分库分表配置》</li>
<li>《分表分库路由》</li>
<li>《Spring与YAML配置》</li>
</ol>
<p>第一、二篇会在<strong>近期</strong>更新。第三篇会在<a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《SQL 改写》</a>、<a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《SQL 执行》</a>完成后进行更新。😈改写和执行相对有趣。</p>
<p>👼道友，您看，逗比博主**“很有规划”**，是关注公众号一波<a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">【芋道源码】</a>还是分享朋友圈。</p>
<hr>
<p>阅读本文之前，建议已经读过<strong>官方</strong>相关文章：</p>
<ul>
<li><a href="http://dangdangdotcom.github.io/sharding-jdbc/02-guide/concepts/" rel="external nofollow noopener noreferrer" target="_blank">《Sharding-JDBC 核心概念》</a></li>
<li><a href="http://dangdangdotcom.github.io/sharding-jdbc/02-guide/sharding/" rel="external nofollow noopener noreferrer" target="_blank">《Sharding-JDBC 分表分库》</a></li>
</ul>
<p>分表分库配置会涉及如下类：</p>
<ul>
<li>TableRule 表规则配置对象</li>
<li>ShardingRule 分库分表规则配置对象</li>
<li>ShardingStrategy 分片策略</li>
<li>ShardingAlgorithm 分片算法</li>
</ul>
<p>我们来一起逐个类往下看。</p>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>
🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
<h1>2. TableRule</h1>
<p>TableRule，表规则配置对象，内嵌 TableRuleBuilder 对象进行创建。</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_04/01.png" alt=""></p>
<h2>2.1 logicTable</h2>
<blockquote>
<p>数据分片的<strong>逻辑表</strong>，对于水平拆分的数据库(表)，同一类表的总称。<br>
例：订单数据根据主键尾数拆分为10张表,分别是t_order_0到t_order_9，他们的逻辑表名为t_order。</p>
</blockquote>
<h2>2.2 数据单元</h2>
<p>Sharding-JDBC 有两种类型<strong>数据单元</strong>：</p>
<ul>
<li>DataNode ：<strong>静态</strong>分库分表数据单元</li>
</ul>
<blockquote>
<p>数据分片的最小单元，由数据源名称和数据表组成。<br>
例：ds_1.t_order_0。配置时默认各个分片数据库的表结构均相同，直接配置逻辑表和真实表对应关系即可。<br>
如果各数据库的表结果不同，可使用ds.actual_table配置。</p>
</blockquote>
<ul>
<li>DynamicDataNode ：<strong>动态</strong>表的分库分表数据单元</li>
</ul>
<blockquote>
<p>逻辑表和真实表不一定需要在配置规则中静态配置。<br>
比如按照日期分片的场景，真实表的名称随着时间的推移会产生变化。<br>
此类需求Sharding-JDBC是支持的，不过目前配置并不友好，会在新版本中提升。</p>
</blockquote>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_04/02.png" alt=""></p>
<p>TableRuleBuilder 调用 <code>#build()</code> 方法创建 TableRule。核心代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TableRuleBuilder.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TableRuleBuilder</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> TableRule <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">       KeyGenerator keyGenerator = <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> != generateKeyColumn &amp;&amp; <span class="keyword">null</span> != keyGeneratorClass) &#123;</div><div class="line">           keyGenerator = KeyGeneratorFactory.createKeyGenerator(keyGeneratorClass);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> TableRule(logicTable, dynamic, actualTables, dataSourceRule, dataSourceNames, databaseShardingStrategy, tableShardingStrategy, generateKeyColumn, keyGenerator);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// TableRule.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TableRule</span><span class="params">(<span class="keyword">final</span> String logicTable, <span class="keyword">final</span> <span class="keyword">boolean</span> dynamic, <span class="keyword">final</span> List&lt;String&gt; actualTables, <span class="keyword">final</span> DataSourceRule dataSourceRule, <span class="keyword">final</span> Collection&lt;String&gt; dataSourceNames,</span></span></div><div class="line">                <span class="keyword">final</span> DatabaseShardingStrategy databaseShardingStrategy, <span class="keyword">final</span> TableShardingStrategy tableShardingStrategy,</div><div class="line">                <span class="keyword">final</span> String generateKeyColumn, <span class="keyword">final</span> KeyGenerator keyGenerator) &#123;</div><div class="line">   Preconditions.checkNotNull(logicTable);</div><div class="line">   <span class="keyword">this</span>.logicTable = logicTable;</div><div class="line">   <span class="keyword">this</span>.dynamic = dynamic;</div><div class="line">   <span class="keyword">this</span>.databaseShardingStrategy = databaseShardingStrategy;</div><div class="line">   <span class="keyword">this</span>.tableShardingStrategy = tableShardingStrategy;</div><div class="line">   <span class="keyword">if</span> (dynamic) &#123; <span class="comment">// 动态表的分库分表数据单元</span></div><div class="line">       Preconditions.checkNotNull(dataSourceRule);</div><div class="line">       <span class="keyword">this</span>.actualTables = generateDataNodes(dataSourceRule);</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> == actualTables || actualTables.isEmpty()) &#123; <span class="comment">// 静态表的分库分表数据单元</span></div><div class="line">       Preconditions.checkNotNull(dataSourceRule);</div><div class="line">       <span class="keyword">this</span>.actualTables = generateDataNodes(Collections.singletonList(logicTable), dataSourceRule, dataSourceNames);</div><div class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">// 静态表的分库分表数据单元</span></div><div class="line">       <span class="keyword">this</span>.actualTables = generateDataNodes(actualTables, dataSourceRule, dataSourceNames);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">this</span>.generateKeyColumn = generateKeyColumn;</div><div class="line">   <span class="keyword">this</span>.keyGenerator = keyGenerator;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3>2.2.1 DataNode</h3>
<p>大多数业务场景下，我们使用<strong>静态</strong>分库分表数据单元，即 DataNode。如上文注释处 <code>静态表的分库分表数据单元</code> 处所见，分成<strong>两</strong>种判断，实质上第一种是将 <code>logicTable</code> 作为 <code>actualTable</code>，即在<strong>库</strong>里不进行分表，是第二种的一种特例。</p>
<p>我们来看看 <code>#generateDataNodes()</code> 方法：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TableRule.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 生成静态数据分片节点</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> actualTables 真实表</div><div class="line">* <span class="doctag">@param</span> dataSourceRule 数据源配置对象</div><div class="line">* <span class="doctag">@param</span> actualDataSourceNames 数据源名集合</div><div class="line">* <span class="doctag">@return</span> 静态数据分片节点</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> List&lt;DataNode&gt; <span class="title">generateDataNodes</span><span class="params">(<span class="keyword">final</span> List&lt;String&gt; actualTables, <span class="keyword">final</span> DataSourceRule dataSourceRule, <span class="keyword">final</span> Collection&lt;String&gt; actualDataSourceNames)</span> </span>&#123;</div><div class="line">   Collection&lt;String&gt; dataSourceNames = getDataSourceNames(dataSourceRule, actualDataSourceNames);</div><div class="line">   List&lt;DataNode&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(actualTables.size() * (dataSourceNames.isEmpty() ? <span class="number">1</span> : dataSourceNames.size()));</div><div class="line">   <span class="keyword">for</span> (String actualTable : actualTables) &#123;</div><div class="line">       <span class="keyword">if</span> (DataNode.isValidDataNode(actualTable)) &#123; <span class="comment">// 当 actualTable 为 $&#123;dataSourceName&#125;.$&#123;tableName&#125; 时</span></div><div class="line">           result.add(<span class="keyword">new</span> DataNode(actualTable));</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">for</span> (String dataSourceName : dataSourceNames) &#123;</div><div class="line">               result.add(<span class="keyword">new</span> DataNode(dataSourceName, actualTable));</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 根据 数据源配置对象 和 数据源名集合 获得 最终的数据源名集合</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> dataSourceRule 数据源配置对象</div><div class="line">* <span class="doctag">@param</span> actualDataSourceNames 数据源名集合</div><div class="line">* <span class="doctag">@return</span> 最终的数据源名集合</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> Collection&lt;String&gt; <span class="title">getDataSourceNames</span><span class="params">(<span class="keyword">final</span> DataSourceRule dataSourceRule, <span class="keyword">final</span> Collection&lt;String&gt; actualDataSourceNames)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> == dataSourceRule) &#123;</div><div class="line">       <span class="keyword">return</span> Collections.emptyList();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> == actualDataSourceNames || actualDataSourceNames.isEmpty()) &#123;</div><div class="line">       <span class="keyword">return</span> dataSourceRule.getDataSourceNames();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> actualDataSourceNames;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>第一种情况，<strong>自定义分布</strong>。<code>actualTable</code> 为 <code>${dataSourceName}.${tableName}</code> 时，即已经明确真实表所在数据源。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">TableRule.builder(<span class="string">"t_order"</span>).actualTables(Arrays.asList(<span class="string">"db0.t_order_0"</span>, <span class="string">"db1.t_order_1"</span>, <span class="string">"db1.t_order_2"</span>))</div></pre></td></tr></table></figure></p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">db0</div><div class="line">  └── t_order_0 </div><div class="line">db1</div><div class="line">  ├── t_order_1</div><div class="line">  └── t_order_2</div></pre></td></tr></table></figure></p>
<ul>
<li>第二种情况，<strong>均匀分布</strong>。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">TableRule.builder(<span class="string">"t_order"</span>).actualTables(Arrays.asList(<span class="string">"t_order_0"</span>, <span class="string">"t_order_1"</span>))</div></pre></td></tr></table></figure></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">db0</div><div class="line">  ├── t_order_0 </div><div class="line">  └── t_order_1 </div><div class="line">db1</div><div class="line">  ├── t_order_0 </div><div class="line">  └── t_order_1</div></pre></td></tr></table></figure></p>
<p><code>#getDataSourceNames()</code> 使用 <code>dataSourceRule</code> 和 <code>actualDataSourceNames</code> 获取数据源的逻辑看起来有种“诡异”。<strong>实际 TableRuleBuilder 创建 TableRule 时，使用 <code>dataSourceRule</code> 而不要使用 <code>actualDataSourceNames</code></strong>。</p>
<h3>2.2.2 DynamicDataNode</h3>
<p>少数业务场景下，我们使用<strong>动态</strong>分库分表数据单元，即 DynamicDataNode。
<strong>通过 <code>dynamic=true</code> 属性配置</strong>。生成代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TableRule.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> List&lt;DataNode&gt; <span class="title">generateDataNodes</span><span class="params">(<span class="keyword">final</span> DataSourceRule dataSourceRule)</span> </span>&#123;</div><div class="line">   Collection&lt;String&gt; dataSourceNames = dataSourceRule.getDataSourceNames();</div><div class="line">   List&lt;DataNode&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(dataSourceNames.size());</div><div class="line">   <span class="keyword">for</span> (String each : dataSourceNames) &#123;</div><div class="line">       result.add(<span class="keyword">new</span> DynamicDataNode(each));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>😂 从代码上看，貌似和<strong>动态</strong>分库分表数据单元没一毛钱关系？！别捉鸡，答案在<a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《分表分库路由》</a> 上。</p>
<h2>2.3 分库/分表策略</h2>
<ul>
<li><code>databaseShardingStrategy</code> ：分库策略</li>
<li><code>tableShardingStrategy</code> ：分表策略</li>
</ul>
<p>当分库/分表策略不配置时，使用 ShardingRule 配置的分库/分表策略。</p>
<h2>2.4 主键生成</h2>
<ul>
<li><code>generateKeyColumn</code> ：主键字段</li>
<li><code>keyGenerator</code> ：主键生成器</li>
</ul>
<p>当主键生成器不配置时，使用 ShardingRule 配置的主键生成器。</p>
<h1>3. ShardingRule</h1>
<p>ShardingRule，分库分表规则配置对象，内嵌 ShardingRuleBuilder 对象进行创建。</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_04/03.png" alt=""></p>
<p>其中 databaseShardingStrategy、tableShardingStrategy、keyGenerator、defaultGenerator 和 TableRule 属性重复，用于当 TableRule 未配置对应属性，使用 ShardingRule 提供的该属性。</p>
<h2>3.1 dataSourceRule</h2>
<p><code>dataSourceRule</code>，数据源配置对象。ShardingRule 需要数据源配置正确。这点和 TableRule 是不同的。TableRule 对 <code>dataSourceRule</code> <strong>只使用数据源名字，最终执行SQL 使用数据源名字从 ShardingRule 获取数据源连接</strong>。大家可以回到本文【2.2.1 DataNode】细看下 DataNode 的生成过程。</p>
<h2>3.2 tableRules</h2>
<p><code>tableRules</code>，表规则配置对象<strong>集合</strong>。</p>
<h2>3.3 bindingTableRules</h2>
<blockquote>
<p>指在任何场景下分片规则均一致的主表和子表。<br>
例：订单表和订单项表，均按照订单ID分片，则此两张表互为BindingTable关系。<br>
BindingTable关系的多表关联查询不会出现笛卡尔积关联，关联查询效率将大大提升。</p>
</blockquote>
<p>😈 这么说，可能不太容易理解。<a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《分表分库路由》</a>，我们在源码的基础上，好好理解下。<strong>非常重要，特别是性能优化上面</strong>。</p>
<h1>4. ShardingStrategy</h1>
<p>ShardingStrategy，分片策略。</p>
<ul>
<li>针对分库、分表有两个子类。</li>
</ul>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_04/04.png" alt=""></p>
<ul>
<li>DatabaseShardingStrategy，使用<strong>分库</strong>算法进行分片</li>
<li>TableShardingStrategy，使用<strong>分表</strong>算法进行分片</li>
</ul>
<p><a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《分表分库路由》</a> 会进一步说明。</p>
<h1>5. ShardingAlgorithm</h1>
<p>ShardingAlgorithm，分片算法。</p>
<ul>
<li>针对分库、分表有两个子<strong>接口</strong>。</li>
<li>针对<strong>分片键</strong>数量分成：无分片键算法、单片键算法、多片键算法。</li>
</ul>
<p><strong>其中 NoneKeyDatabaseShardingAlgorithm、NoneTableShardingAlgorithm 为 ShardingRule 在未设置分库、分表算法的默认值</strong>。代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingRule.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ShardingRule</span><span class="params">(</span></span></div><div class="line">       <span class="keyword">final</span> DataSourceRule dataSourceRule, <span class="keyword">final</span> Collection&lt;TableRule&gt; tableRules, <span class="keyword">final</span> Collection&lt;BindingTableRule&gt; bindingTableRules,</div><div class="line">       <span class="keyword">final</span> DatabaseShardingStrategy databaseShardingStrategy, <span class="keyword">final</span> TableShardingStrategy tableShardingStrategy, <span class="keyword">final</span> KeyGenerator keyGenerator) &#123;</div><div class="line">   <span class="comment">// ... 省略部分代码</span></div><div class="line">   <span class="keyword">this</span>.databaseShardingStrategy = <span class="keyword">null</span> == databaseShardingStrategy ? <span class="keyword">new</span> DatabaseShardingStrategy(</div><div class="line">           Collections.&lt;String&gt;emptyList(), <span class="keyword">new</span> NoneDatabaseShardingAlgorithm()) : databaseShardingStrategy;</div><div class="line">   <span class="keyword">this</span>.tableShardingStrategy = <span class="keyword">null</span> == tableShardingStrategy ? <span class="keyword">new</span> TableShardingStrategy(</div><div class="line">           Collections.&lt;String&gt;emptyList(), <span class="keyword">new</span> NoneTableShardingAlgorithm()) : tableShardingStrategy;</div><div class="line">   <span class="comment">// ... 省略部分代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《分表分库路由》</a> 会进一步说明。</p>
<h1>666. 彩蛋</h1>
<p>本文看似在水更，实是为<a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《分表分库路由》</a>做铺垫（一阵脸红😳）。</p>
<p>But，无论怎么说，道友，我做了新的关注二维码（感谢猫🐱先生），是不是可以推荐一波公众号给基佬。</p>
<p>恩，继续更新。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：&lt;/p&gt;
&lt;ol&gt;

    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
</feed>
